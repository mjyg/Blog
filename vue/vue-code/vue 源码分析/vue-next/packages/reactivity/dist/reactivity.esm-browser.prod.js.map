{"version":3,"file":"reactivity.esm-browser.prod.js","sources":["../../shared/src/makeMap.ts","../../shared/src/index.ts","../src/lock.ts","../src/baseHandlers.ts","../src/collectionHandlers.ts","../src/reactive.ts","../src/effect.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["// Make a map and return a function for checking if a key\n// is in that map.\n//\n// IMPORTANT: all calls of this function must be prefixed with /*#__PURE__*/\n// So that rollup can tree-shake them if necessary.\nexport function makeMap(\n  str: string,\n  expectsLowerCase?: boolean\n): (key: string) => boolean {\n  const map: Record<string, boolean> = Object.create(null)\n  const list: Array<string> = str.split(',')\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\n}\n","export * from './patchFlags'\nexport { isGloballyWhitelisted } from './globalsWhitelist'\nexport { makeMap } from './makeMap'\n\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\n  ? Object.freeze({})\n  : {}\nexport const EMPTY_ARR: [] = []\n\nexport const NOOP = () => {}\n\n/**\n * Always return false.\n */\nexport const NO = () => false\n\nexport const isOn = (key: string) => key[0] === 'o' && key[1] === 'n'\n\nexport const extend = <T extends object, U extends object>(\n  a: T,\n  b: U\n): T & U => {\n  for (const key in b) {\n    ;(a as any)[key] = b[key]\n  }\n  return a as any\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const isArray = Array.isArray\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === 'function'\nexport const isString = (val: unknown): val is string => typeof val === 'string'\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport function isPromise<T = any>(val: unknown): val is Promise<T> {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\n}\n\nexport const objectToString = Object.prototype.toString\nexport const toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\nexport const isPlainObject = (val: unknown): val is object =>\n  toTypeString(val) === '[object Object]'\n\nexport const isReservedProp = (key: string): boolean =>\n  key === 'key' || key === 'ref' || key === '$once' || key.startsWith(`onVnode`)\n\nconst camelizeRE = /-(\\w)/g\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\n}\n\nconst hyphenateRE = /\\B([A-Z])/g\nexport const hyphenate = (str: string): string => {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n}\n\nexport const capitalize = (str: string): string => {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n","// global immutability lock\nexport let LOCKED = true\n\nexport function lock() {\n  LOCKED = true\n}\n\nexport function unlock() {\n  LOCKED = false\n}\n","import { reactive, readonly, toRaw } from './reactive'\nimport { OperationTypes } from './operations'\nimport { track, trigger } from './effect'\nimport { LOCKED } from './lock'\nimport { isObject, hasOwn, isSymbol } from '@vue/shared'\nimport { isRef } from './ref'\n\nconst builtInSymbols = new Set(\n  Object.getOwnPropertyNames(Symbol)\n    .map(key => (Symbol as any)[key])\n    .filter(isSymbol)\n)\n\n/**\n * 创建proxy里面的get处理函数\n * @param isReadonly 否是是处理只读\n */\nfunction createGetter(isReadonly: boolean) {\n  /**\n   * get函数\n   */\n  return function get(target: any, key: string | symbol, receiver: any) {\n    //获取到Reflect执行的结果\n    const res = Reflect.get(target, key, receiver)\n    //防止key为Symbol的内置对象，比如 Symbol.iterator\n    if (isSymbol(key) && builtInSymbols.has(key)) {\n      return res\n    }\n    //如果是ref包装过的数据，直接调用Value触发get，获取值之后，再返回\n    if (isRef(res)) {\n      return res.value\n    }\n    //TODO:看着像跟踪，依赖收集，后面再看\n    track(target, OperationTypes.GET, key)\n\n    /**\n     * 对深层对象再次包装，\n     * 判断内层是否是对象，不是就直接返回\n     * 如果是对象，判断是否是要做只读处理，\n     * 如果是只读，就调用只读\n     * 不是的话，就调用\n     */\n    return isObject(res)\n      ? isReadonly\n        ? // need to lazy access readonly and reactive here to avoid\n          // circular dependency\n          readonly(res)\n        : reactive(res)\n      : res\n  }\n}\n\n/**\n * proxy中set方法的优化,包含只读数据的处理和响应式数据的处理\n * @param target\n * @param key\n * @param value\n * @param receiver\n */\nfunction set(\n  target: any,\n  key: string | symbol,\n  value: any,\n  receiver: any\n): boolean {\n  //获取原始的数据\n  value = toRaw(value)\n  //拿到之前的老值\n  const oldValue = target[key]\n  //判断老数据是否是已经被ref处理过的，并且新数据没有没ref处理过\n  if (isRef(oldValue) && !isRef(value)) {\n    //更新老数据，并且返回\n    // 如果 value 不是响应式数据，则需要将其赋值给 oldValue，调用set value，\n    //如果 isObject(value) ，则会经过 reactive 再包装一次，将其变成响应式数据\n    oldValue.value = value\n    return true\n  }\n  /**\n   *   key是target自己的属性\n   *\n   *   这个方法是解决 数组push时，会调用两次 set 的情况，比如 arr.push(1)\n   *   第一次set，在数组尾部添加1\n   *   第二次set，给数组添加length属性\n   *   hasOwnProperty 方法用来判断目标对象是否含有指定属性。数组本身就有length的属性，所以这里是 true\n   */\n  const hadKey = hasOwn(target, key)\n  //执行返回结果\n  const result = Reflect.set(target, key, value, receiver)\n  // don't trigger if target is something up in the prototype chain of original\n  //target 如果只读 或者 存在于 reactiveToRaw 则不进入条件，reactiveToRaw 储存着代理后的对象\n  //已经是代理之后的值了\n  if (target === toRaw(receiver)) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      const extraInfo = { oldValue, newValue: value }\n      if (!hadKey) {\n        trigger(target, OperationTypes.ADD, key, extraInfo)\n      } else if (value !== oldValue) {\n        trigger(target, OperationTypes.SET, key, extraInfo)\n      }\n    } else {\n      //属性新增，触发 ADD 枚举\n      if (!hadKey) {\n        trigger(target, OperationTypes.ADD, key)\n      } else if (value !== oldValue) {\n        // 属性修改，触发 SET 枚举\n        trigger(target, OperationTypes.SET, key)\n      }\n    }\n  }\n  return result\n}\n\n//删除属性处理\nfunction deleteProperty(target: any, key: string | symbol): boolean {\n  const hadKey = hasOwn(target, key)\n  const oldValue = target[key]\n  const result = Reflect.deleteProperty(target, key)\n  if (result && hadKey) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.DELETE, key, { oldValue })\n    } else {\n      trigger(target, OperationTypes.DELETE, key)\n    }\n  }\n  return result\n}\n//查询属性处理\nfunction has(target: any, key: string | symbol): boolean {\n  const result = Reflect.has(target, key)\n  track(target, OperationTypes.HAS, key)\n  return result\n}\n//获取key的属性处理\nfunction ownKeys(target: any): (string | number | symbol)[] {\n  track(target, OperationTypes.ITERATE)\n  return Reflect.ownKeys(target)\n}\n\n//可变数据处理handler\nexport const mutableHandlers: ProxyHandler<any> = {\n  get: createGetter(false),\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n\n//只读数据handler\nexport const readonlyHandlers: ProxyHandler<any> = {\n  //创建get\n  get: createGetter(true),\n  //创建set\n  set(target: any, key: string | symbol, value: any, receiver: any): boolean {\n    //判断是否已经锁住\n    if (LOCKED) {\n      if (__DEV__) {\n        console.warn(\n          `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n          target\n        )\n      }\n      return true\n    } else {\n      return set(target, key, value, receiver)\n    }\n  },\n\n  deleteProperty(target: any, key: string | symbol): boolean {\n    if (LOCKED) {\n      if (__DEV__) {\n        console.warn(\n          `Delete operation on key \"${String(\n            key\n          )}\" failed: target is readonly.`,\n          target\n        )\n      }\n      return true\n    } else {\n      return deleteProperty(target, key)\n    }\n  },\n\n  has,\n  ownKeys\n}\n","import { toRaw, reactive, readonly } from './reactive'\nimport { track, trigger } from './effect'\nimport { OperationTypes } from './operations'\nimport { LOCKED } from './lock'\nimport { isObject, capitalize, hasOwn } from '@vue/shared'\n\nconst toReactive = (value: any) => (isObject(value) ? reactive(value) : value)\nconst toReadonly = (value: any) => (isObject(value) ? readonly(value) : value)\n\nfunction get(target: any, key: any, wrap: (t: any) => any): any {\n  target = toRaw(target)\n  key = toRaw(key)\n  const proto: any = Reflect.getPrototypeOf(target)\n  track(target, OperationTypes.GET, key)\n  const res = proto.get.call(target, key)\n  return wrap(res)\n}\n\nfunction has(this: any, key: any): boolean {\n  const target = toRaw(this)\n  key = toRaw(key)\n  const proto: any = Reflect.getPrototypeOf(target)\n  track(target, OperationTypes.HAS, key)\n  return proto.has.call(target, key)\n}\n\nfunction size(target: any) {\n  target = toRaw(target)\n  const proto = Reflect.getPrototypeOf(target)\n  track(target, OperationTypes.ITERATE)\n  return Reflect.get(proto, 'size', target)\n}\n\nfunction add(this: any, value: any) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const proto: any = Reflect.getPrototypeOf(this)\n  const hadKey = proto.has.call(target, value)\n  const result = proto.add.call(target, value)\n  if (!hadKey) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.ADD, value, { value })\n    } else {\n      trigger(target, OperationTypes.ADD, value)\n    }\n  }\n  return result\n}\n\nfunction set(this: any, key: any, value: any) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const proto: any = Reflect.getPrototypeOf(this)\n  const hadKey = proto.has.call(target, key)\n  const oldValue = proto.get.call(target, key)\n  const result = proto.set.call(target, key, value)\n  if (value !== oldValue) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      const extraInfo = { oldValue, newValue: value }\n      if (!hadKey) {\n        trigger(target, OperationTypes.ADD, key, extraInfo)\n      } else {\n        trigger(target, OperationTypes.SET, key, extraInfo)\n      }\n    } else {\n      if (!hadKey) {\n        trigger(target, OperationTypes.ADD, key)\n      } else {\n        trigger(target, OperationTypes.SET, key)\n      }\n    }\n  }\n  return result\n}\n\nfunction deleteEntry(this: any, key: any) {\n  const target = toRaw(this)\n  const proto: any = Reflect.getPrototypeOf(this)\n  const hadKey = proto.has.call(target, key)\n  const oldValue = proto.get ? proto.get.call(target, key) : undefined\n  // forward the operation before queueing reactions\n  const result = proto.delete.call(target, key)\n  if (hadKey) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.DELETE, key, { oldValue })\n    } else {\n      trigger(target, OperationTypes.DELETE, key)\n    }\n  }\n  return result\n}\n\nfunction clear(this: any) {\n  const target = toRaw(this)\n  const proto: any = Reflect.getPrototypeOf(this)\n  const hadItems = target.size !== 0\n  const oldTarget = target instanceof Map ? new Map(target) : new Set(target)\n  // forward the operation before queueing reactions\n  const result = proto.clear.call(target)\n  if (hadItems) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.CLEAR, void 0, { oldTarget })\n    } else {\n      trigger(target, OperationTypes.CLEAR)\n    }\n  }\n  return result\n}\n\nfunction createForEach(isReadonly: boolean) {\n  return function forEach(this: any, callback: Function, thisArg?: any) {\n    const observed = this\n    const target = toRaw(observed)\n    const proto: any = Reflect.getPrototypeOf(target)\n    const wrap = isReadonly ? toReadonly : toReactive\n    track(target, OperationTypes.ITERATE)\n    // important: create sure the callback is\n    // 1. invoked with the reactive map as `this` and 3rd arg\n    // 2. the value received should be a corresponding reactive/readonly.\n    function wrappedCallback(value: any, key: any) {\n      return callback.call(observed, wrap(value), wrap(key), observed)\n    }\n    return proto.forEach.call(target, wrappedCallback, thisArg)\n  }\n}\n\nfunction createIterableMethod(method: string | symbol, isReadonly: boolean) {\n  return function(this: any, ...args: any[]) {\n    const target = toRaw(this)\n    const proto: any = Reflect.getPrototypeOf(target)\n    const isPair =\n      method === 'entries' ||\n      (method === Symbol.iterator && target instanceof Map)\n    const innerIterator = proto[method].apply(target, args)\n    const wrap = isReadonly ? toReadonly : toReactive\n    track(target, OperationTypes.ITERATE)\n    // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next()\n        return done\n          ? { value, done }\n          : {\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n              done\n            }\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this\n      }\n    }\n  }\n}\n\nfunction createReadonlyMethod(\n  method: Function,\n  type: OperationTypes\n): Function {\n  return function(this: any, ...args: any[]) {\n    if (LOCKED) {\n      if (__DEV__) {\n        const key = args[0] ? `on key \"${args[0]}\" ` : ``\n        console.warn(\n          `${capitalize(type)} operation ${key}failed: target is readonly.`,\n          toRaw(this)\n        )\n      }\n      return type === OperationTypes.DELETE ? false : this\n    } else {\n      return method.apply(this, args)\n    }\n  }\n}\n\nconst mutableInstrumentations: any = {\n  get(key: any) {\n    return get(this, key, toReactive)\n  },\n  get size() {\n    return size(this)\n  },\n  has,\n  add,\n  set,\n  delete: deleteEntry,\n  clear,\n  forEach: createForEach(false)\n}\n\nconst readonlyInstrumentations: any = {\n  get(key: any) {\n    return get(this, key, toReadonly)\n  },\n  get size() {\n    return size(this)\n  },\n  has,\n  add: createReadonlyMethod(add, OperationTypes.ADD),\n  set: createReadonlyMethod(set, OperationTypes.SET),\n  delete: createReadonlyMethod(deleteEntry, OperationTypes.DELETE),\n  clear: createReadonlyMethod(clear, OperationTypes.CLEAR),\n  forEach: createForEach(true)\n}\n\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\niteratorMethods.forEach(method => {\n  mutableInstrumentations[method] = createIterableMethod(method, false)\n  readonlyInstrumentations[method] = createIterableMethod(method, true)\n})\n\nfunction createInstrumentationGetter(instrumentations: any) {\n  return function getInstrumented(\n    target: any,\n    key: string | symbol,\n    receiver: any\n  ) {\n    target =\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target\n    return Reflect.get(target, key, receiver)\n  }\n}\n\nexport const mutableCollectionHandlers: ProxyHandler<any> = {\n  get: createInstrumentationGetter(mutableInstrumentations)\n}\n\nexport const readonlyCollectionHandlers: ProxyHandler<any> = {\n  get: createInstrumentationGetter(readonlyInstrumentations)\n}\n","import { isObject, toTypeString } from '@vue/shared'\nimport { mutableHandlers, readonlyHandlers } from './baseHandlers'\nimport {\n  mutableCollectionHandlers,\n  readonlyCollectionHandlers\n} from './collectionHandlers'\nimport { ReactiveEffect } from './effect'\nimport { UnwrapRef, Ref } from './ref'\nimport { makeMap } from '@vue/shared'\n\n// The main WeakMap that stores {target -> key -> dep} connections.\n// Conceptually, it's easier to think of a dependency as a Dep class\n// which maintains a Set of subscribers, but we simply store them as\n// raw Sets to reduce memory overhead.\n//这个WeakMap储存着（target-> key->dep）,在概念上，把依赖看着Dep 类维护了一组订阅，更好理解，\n//我们只是把它储存为原始set 可以减少内存开销\n\nexport type Dep = Set<ReactiveEffect>\nexport type KeyToDepMap = Map<string | symbol, Dep>\nexport const targetMap = new WeakMap<any, KeyToDepMap>()\n\n// WeakMaps that store {raw <-> observed} pairs.\n//原始数据到响应数据之间的映射\nconst rawToReactive = new WeakMap<any, any>()\nconst reactiveToRaw = new WeakMap<any, any>()\nconst rawToReadonly = new WeakMap<any, any>()\nconst readonlyToRaw = new WeakMap<any, any>()\n\n// WeakSets for values that are marked readonly or non-reactive during\n// observable creation.\n\nconst readonlyValues = new WeakSet<any>()\nconst nonReactiveValues = new WeakSet<any>()\n\nconst collectionTypes = new Set<Function>([Set, Map, WeakMap, WeakSet])\nconst isObservableType = /*#__PURE__*/ makeMap(\n  ['Object', 'Array', 'Map', 'Set', 'WeakMap', 'WeakSet']\n    .map(t => `[object ${t}]`)\n    .join(',')\n)\n\n/**\n * 判断是否可以observable\n * @param value\n */\nconst canObserve = (value: any): boolean => {\n  return (\n    //不是Vue对象\n    !value._isVue &&\n    //不是VNode\n    !value._isVNode &&\n    //是Object、Array、Map、Set、WeakMap、WeakSet\n    isObservableType(toTypeString(value)) &&\n    //没有被代理过\n    !nonReactiveValues.has(value)\n  )\n}\n\n// only unwrap nested ref\ntype UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRef<T>\n\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\nexport function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  //如果target是只读，返回这个target\n  if (readonlyToRaw.has(target)) {\n    return target\n  }\n  // target is explicitly marked as readonly by user\n  //target被用户标记成了只读，那么就让他变成只读，并返回\n  if (readonlyValues.has(target)) {\n    return readonly(target)\n  }\n  //创建响应式数据\n  return createReactiveObject(\n    target, //原始值\n    rawToReactive, //原始值到响应数据的映射\n    reactiveToRaw, //响应数据到原始值的映射\n    mutableHandlers,\n    mutableCollectionHandlers\n  )\n}\n\nexport function readonly<T extends object>(\n  target: T\n): Readonly<UnwrapNestedRefs<T>> {\n  // value is a mutable observable, retrieve its original and return\n  // a readonly version.\n  //如果值已经是响应类型的值了，那么就取出他的原始值\n  if (reactiveToRaw.has(target)) {\n    target = reactiveToRaw.get(target)\n  }\n  //创建响应对象\n  return createReactiveObject(\n    target, //原始值\n    rawToReadonly, //原始值到只读数据的映射\n    readonlyToRaw, //只读数据到原始值的映射\n    readonlyHandlers,\n    readonlyCollectionHandlers\n  )\n}\n/**\n * 创建响应类型\n * @param target\n * @param toProxy\n * @param toRaw\n * @param baseHandlers\n * @param collectionHandlers\n */\nfunction createReactiveObject(\n  target: any,\n  toProxy: WeakMap<any, any>,\n  toRaw: WeakMap<any, any>,\n  baseHandlers: ProxyHandler<any>,\n  collectionHandlers: ProxyHandler<any>\n) {\n  //判断是否是基本元素（数字、字符串、布尔），如果是基本元素，就直接返回\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // target already has corresponding Proxy\n  //获取已经处理过的对象（可相应的、只读的）\n  let observed = toProxy.get(target)\n  //如果已经有了处理过的对象（可相应的、只读的），直接返回此对象\n  if (observed !== void 0) {\n    return observed\n  }\n  // target is already a Proxy\n  //数据已经是一个处理过的对象（可相应的、只读的），返回\n  if (toRaw.has(target)) {\n    return target\n  }\n  // only a whitelist of value types can be observed.\n  //只有白名单的对象才可以被代理\n  if (!canObserve(target)) {\n    return target\n  }\n  //collectionTypes表示Set, Map, WeakMap, WeakSet的集合，判断对象是否是这几种类型，来使用不同的处理函数\n  const handlers = collectionTypes.has(target.constructor)\n    ? collectionHandlers\n    : baseHandlers\n  //数据处理\n  observed = new Proxy(target, handlers)\n  toProxy.set(target, observed) //设置原始数据到处理后的数据的弱引用\n  toRaw.set(observed, target) //设置处理后的数据到原始数据的弱引用\n  //如果之前数据没有处理过，那么就设置target到key到Dep的引用关系\n  if (!targetMap.has(target)) {\n    targetMap.set(target, new Map())\n  }\n  return observed\n}\n\nexport function isReactive(value: any): boolean {\n  return reactiveToRaw.has(value) || readonlyToRaw.has(value)\n}\n\nexport function isReadonly(value: any): boolean {\n  return readonlyToRaw.has(value)\n}\n\n/**\n * 获取原始数据\n * @param observed\n */\nexport function toRaw<T>(observed: T): T {\n  return reactiveToRaw.get(observed) || readonlyToRaw.get(observed) || observed\n}\n\n/**\n * 标记数据为只读数据\n * @param value\n */\nexport function markReadonly<T>(value: T): T {\n  readonlyValues.add(value)\n  return value\n}\n\n//标记没有被处理过的数据\nexport function markNonReactive<T>(value: T): T {\n  nonReactiveValues.add(value)\n  return value\n}\n","import { OperationTypes } from './operations'\nimport { Dep, targetMap } from './reactive'\nimport { EMPTY_OBJ, extend } from '@vue/shared'\n\nexport const effectSymbol = Symbol(__DEV__ ? 'effect' : void 0)\n\nexport interface ReactiveEffect<T = any> {\n  (): T\n  [effectSymbol]: true\n  active: boolean\n  raw: () => T\n  deps: Array<Dep>\n  computed?: boolean\n  scheduler?: (run: Function) => void\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  onStop?: () => void\n}\n\nexport interface ReactiveEffectOptions {\n  lazy?: boolean\n  computed?: boolean\n  scheduler?: (run: Function) => void\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  onStop?: () => void\n}\n\nexport interface DebuggerEvent {\n  effect: ReactiveEffect\n  target: any\n  type: OperationTypes\n  key: string | symbol | undefined\n}\n\nexport const effectStack: ReactiveEffect[] = []\n\nexport const ITERATE_KEY = Symbol('iterate')\n\nexport function isEffect(fn: any): fn is ReactiveEffect {\n  return fn != null && fn[effectSymbol] === true\n}\n\nexport function effect<T = any>(\n  fn: () => T,\n  options: ReactiveEffectOptions = EMPTY_OBJ\n): ReactiveEffect<T> {\n  if (isEffect(fn)) {\n    fn = fn.raw\n  }\n  const effect = createReactiveEffect(fn, options)\n  if (!options.lazy) {\n    effect()\n  }\n  return effect\n}\n\nexport function stop(effect: ReactiveEffect) {\n  if (effect.active) {\n    cleanup(effect)\n    if (effect.onStop) {\n      effect.onStop()\n    }\n    effect.active = false\n  }\n}\n\nfunction createReactiveEffect<T = any>(\n  fn: () => T,\n  options: ReactiveEffectOptions\n): ReactiveEffect<T> {\n  const effect = function reactiveEffect(...args: any[]): any {\n    return run(effect, fn, args)\n  } as ReactiveEffect\n  effect[effectSymbol] = true\n  effect.active = true\n  effect.raw = fn\n  effect.scheduler = options.scheduler\n  effect.onTrack = options.onTrack\n  effect.onTrigger = options.onTrigger\n  effect.onStop = options.onStop\n  effect.computed = options.computed\n  effect.deps = []\n  return effect\n}\n\nfunction run(effect: ReactiveEffect, fn: Function, args: any[]): any {\n  if (!effect.active) {\n    return fn(...args)\n  }\n  if (!effectStack.includes(effect)) {\n    cleanup(effect)\n    try {\n      effectStack.push(effect)\n      return fn(...args)\n    } finally {\n      effectStack.pop()\n    }\n  }\n}\n\nfunction cleanup(effect: ReactiveEffect) {\n  const { deps } = effect\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect)\n    }\n    deps.length = 0\n  }\n}\n\nlet shouldTrack = true\n\nexport function pauseTracking() {\n  shouldTrack = false\n}\n\nexport function resumeTracking() {\n  shouldTrack = true\n}\n\nexport function track(\n  target: any,\n  type: OperationTypes,\n  key?: string | symbol\n) {\n  if (!shouldTrack || effectStack.length === 0) {\n    return\n  }\n  const effect = effectStack[effectStack.length - 1]\n  if (type === OperationTypes.ITERATE) {\n    key = ITERATE_KEY\n  }\n  let depsMap = targetMap.get(target)\n  if (depsMap === void 0) {\n    targetMap.set(target, (depsMap = new Map()))\n  }\n  let dep = depsMap.get(key!)\n  if (dep === void 0) {\n    depsMap.set(key!, (dep = new Set()))\n  }\n  if (!dep.has(effect)) {\n    dep.add(effect)\n    effect.deps.push(dep)\n    if (__DEV__ && effect.onTrack) {\n      effect.onTrack({\n        effect,\n        target,\n        type,\n        key\n      })\n    }\n  }\n}\n\nexport function trigger(\n  target: any,\n  type: OperationTypes,\n  key?: string | symbol,\n  extraInfo?: any\n) {\n  const depsMap = targetMap.get(target)\n  if (depsMap === void 0) {\n    // never been tracked\n    return\n  }\n  const effects = new Set<ReactiveEffect>()\n  const computedRunners = new Set<ReactiveEffect>()\n  if (type === OperationTypes.CLEAR) {\n    // collection being cleared, trigger all effects for target\n    depsMap.forEach(dep => {\n      addRunners(effects, computedRunners, dep)\n    })\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      addRunners(effects, computedRunners, depsMap.get(key))\n    }\n    // also run for iteration key on ADD | DELETE\n    if (type === OperationTypes.ADD || type === OperationTypes.DELETE) {\n      const iterationKey = Array.isArray(target) ? 'length' : ITERATE_KEY\n      addRunners(effects, computedRunners, depsMap.get(iterationKey))\n    }\n  }\n  const run = (effect: ReactiveEffect) => {\n    scheduleRun(effect, target, type, key, extraInfo)\n  }\n  // Important: computed effects must be run first so that computed getters\n  // can be invalidated before any normal effects that depend on them are run.\n  computedRunners.forEach(run)\n  effects.forEach(run)\n}\n\nfunction addRunners(\n  effects: Set<ReactiveEffect>,\n  computedRunners: Set<ReactiveEffect>,\n  effectsToAdd: Set<ReactiveEffect> | undefined\n) {\n  if (effectsToAdd !== void 0) {\n    effectsToAdd.forEach(effect => {\n      if (effect.computed) {\n        computedRunners.add(effect)\n      } else {\n        effects.add(effect)\n      }\n    })\n  }\n}\n\nfunction scheduleRun(\n  effect: ReactiveEffect,\n  target: any,\n  type: OperationTypes,\n  key: string | symbol | undefined,\n  extraInfo: any\n) {\n  if (__DEV__ && effect.onTrigger) {\n    effect.onTrigger(\n      extend(\n        {\n          effect,\n          target,\n          key,\n          type\n        },\n        extraInfo\n      )\n    )\n  }\n  if (effect.scheduler !== void 0) {\n    effect.scheduler(effect)\n  } else {\n    effect()\n  }\n}\n","import { track, trigger } from './effect'\nimport { OperationTypes } from './operations'\nimport { isObject } from '@vue/shared'\nimport { reactive } from './reactive'\nimport { ComputedRef } from './computed'\n\nexport interface Ref<T = any> {\n  _isRef: true\n  value: UnwrapRef<T>\n}\n\nconst convert = (val: any): any => (isObject(val) ? reactive(val) : val)\n\nexport function ref<T extends Ref>(raw: T): T\nexport function ref<T>(raw: T): Ref<T>\nexport function ref(raw: any) {\n  if (isRef(raw)) {\n    return raw\n  }\n  /**\n   * 如果是对象，则用 reactive 方法 包装 raw\n   * const convert = (val: any): any => (isObject(val) ? reactive(val) : val)\n   */\n  raw = convert(raw)\n\n  /**\n   * 返回v，Ref类型，获取value值的时候，调用track方法，存value值时，调用 trigger方法\n   * v.value触发get，v.value=2触发set\n   */\n  const v = {\n    _isRef: true,\n    get value() {\n      //TODO:why track\n      track(v, OperationTypes.GET, '')\n      return raw\n    },\n    set value(newVal) {\n      //对数据包装\n      raw = convert(newVal)\n      //TODO:why trigger\n      trigger(v, OperationTypes.SET, '')\n    }\n  }\n  return v as Ref\n}\n\n//判断是否是ref\nexport function isRef(v: any): v is Ref {\n  return v ? v._isRef === true : false\n}\n/**\n * 转换为ref\n * @param object\n */\nexport function toRefs<T extends object>(\n  object: T\n): { [K in keyof T]: Ref<T[K]> } {\n  const ret: any = {}\n  for (const key in object) {\n    ret[key] = toProxyRef(object, key)\n  }\n  return ret\n}\n/**\n * 转换ref数据\n * @param object\n * @param key\n */\nfunction toProxyRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K\n): Ref<T[K]> {\n  return {\n    _isRef: true,\n    get value(): any {\n      return object[key]\n    },\n    set value(newVal) {\n      object[key] = newVal\n    }\n  }\n}\n\ntype BailTypes =\n  | Function\n  | Map<any, any>\n  | Set<any>\n  | WeakMap<any, any>\n  | WeakSet<any>\n\n// Recursively unwraps nested value bindings.\nexport type UnwrapRef<T> = {\n  cRef: T extends ComputedRef<infer V> ? UnwrapRef<V> : T\n  ref: T extends Ref<infer V> ? UnwrapRef<V> : T\n  array: T extends Array<infer V> ? Array<UnwrapRef<V>> : T\n  object: { [K in keyof T]: UnwrapRef<T[K]> }\n}[T extends ComputedRef<any>\n  ? 'cRef'\n  : T extends Ref\n    ? 'ref'\n    : T extends Array<any>\n      ? 'array'\n      : T extends BailTypes\n        ? 'ref' // bail out on types that shouldn't be unwrapped\n        : T extends object ? 'object' : 'ref']\n","import { effect, ReactiveEffect, effectStack } from './effect'\nimport { Ref, UnwrapRef } from './ref'\nimport { isFunction, NOOP } from '@vue/shared'\n\nexport interface ComputedRef<T> extends WritableComputedRef<T> {\n  readonly value: UnwrapRef<T>\n}\n\nexport interface WritableComputedRef<T> extends Ref<T> {\n  readonly effect: ReactiveEffect<T>\n}\n\nexport type ComputedGetter<T> = () => T\nexport type ComputedSetter<T> = (v: T) => void\n\nexport interface WritableComputedOptions<T> {\n  get: ComputedGetter<T>\n  set: ComputedSetter<T>\n}\n\nexport function computed<T>(getter: ComputedGetter<T>): ComputedRef<T>\nexport function computed<T>(\n  options: WritableComputedOptions<T>\n): WritableComputedRef<T>\nexport function computed<T>(\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>\n): any {\n  const isReadonly = isFunction(getterOrOptions)\n  const getter = isReadonly\n    ? (getterOrOptions as ComputedGetter<T>)\n    : (getterOrOptions as WritableComputedOptions<T>).get\n  const setter = isReadonly\n    ? __DEV__\n      ? () => {\n          console.warn('Write operation failed: computed value is readonly')\n        }\n      : NOOP\n    : (getterOrOptions as WritableComputedOptions<T>).set\n\n  let dirty = true\n  let value: T\n\n  const runner = effect(getter, {\n    lazy: true,\n    // mark effect as computed so that it gets priority during trigger\n    computed: true,\n    scheduler: () => {\n      dirty = true\n    }\n  })\n  return {\n    _isRef: true,\n    // expose effect so computed can be stopped\n    effect: runner,\n    get value() {\n      if (dirty) {\n        value = runner()\n        dirty = false\n      }\n      // When computed effects are accessed in a parent effect, the parent\n      // should track all the dependencies the computed property has tracked.\n      // This should also apply for chained computed properties.\n      trackChildRun(runner)\n      return value\n    },\n    set value(newValue: T) {\n      setter(newValue)\n    }\n  }\n}\n\nfunction trackChildRun(childRunner: ReactiveEffect) {\n  if (effectStack.length === 0) {\n    return\n  }\n  const parentRunner = effectStack[effectStack.length - 1]\n  for (let i = 0; i < childRunner.deps.length; i++) {\n    const dep = childRunner.deps[i]\n    if (!dep.has(parentRunner)) {\n      dep.add(parentRunner)\n      parentRunner.deps.push(dep)\n    }\n  }\n}\n"],"names":["makeMap","str","expectsLowerCase","map","Object","create","list","split","i","length","val","toLowerCase","EMPTY_OBJ","NOOP","hasOwnProperty","prototype","hasOwn","key","call","isFunction","isSymbol","isObject","objectToString","toString","LOCKED","lock","unlock","builtInSymbols","Set","getOwnPropertyNames","Symbol","filter","createGetter","isReadonly","target","receiver","res","Reflect","get","has","isRef","value","track","readonly","reactive","set","toRaw","oldValue","hadKey","result","trigger","deleteProperty","ownKeys","mutableHandlers","readonlyHandlers","toReactive","toReadonly","wrap","proto","getPrototypeOf","this","size","add","deleteEntry","delete","clear","hadItems","createForEach","callback","thisArg","observed","forEach","createIterableMethod","method","args","isPair","iterator","Map","innerIterator","apply","[object Object]","done","next","createReadonlyMethod","type","mutableInstrumentations","readonlyInstrumentations","createInstrumentationGetter","instrumentations","mutableCollectionHandlers","readonlyCollectionHandlers","targetMap","WeakMap","rawToReactive","reactiveToRaw","rawToReadonly","readonlyToRaw","readonlyValues","WeakSet","nonReactiveValues","collectionTypes","isObservableType","t","join","canObserve","_isVue","_isVNode","toTypeString","createReactiveObject","toProxy","baseHandlers","collectionHandlers","handlers","constructor","Proxy","isReactive","markReadonly","markNonReactive","effectSymbol","effectStack","ITERATE_KEY","effect","fn","options","isEffect","raw","active","includes","cleanup","push","pop","run","scheduler","onTrack","onTrigger","onStop","computed","deps","createReactiveEffect","lazy","stop","shouldTrack","pauseTracking","resumeTracking","depsMap","dep","extraInfo","effects","computedRunners","addRunners","iterationKey","Array","isArray","scheduleRun","effectsToAdd","convert","ref","v","_isRef","newVal","toRefs","object","ret","toProxyRef","getterOrOptions","getter","setter","dirty","runner","childRunner","parentRunner","trackChildRun","newValue"],"mappings":"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"}