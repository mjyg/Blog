{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/makeMap.ts","../../shared/src/index.ts","../src/lock.ts","../src/baseHandlers.ts","../src/collectionHandlers.ts","../src/reactive.ts","../src/effect.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["// Make a map and return a function for checking if a key\n// is in that map.\n//\n// IMPORTANT: all calls of this function must be prefixed with /*#__PURE__*/\n// So that rollup can tree-shake them if necessary.\nexport function makeMap(\n  str: string,\n  expectsLowerCase?: boolean\n): (key: string) => boolean {\n  const map: Record<string, boolean> = Object.create(null)\n  const list: Array<string> = str.split(',')\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\n}\n","import { makeMap } from './makeMap'\n\nexport { makeMap }\nexport * from './patchFlags'\nexport { isGloballyWhitelisted } from './globalsWhitelist'\n\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\n  ? Object.freeze({})\n  : {}\nexport const EMPTY_ARR: [] = []\n\nexport const NOOP = () => {}\n\n/**\n * Always return false.\n */\nexport const NO = () => false\n\nexport const isOn = (key: string) => key[0] === 'o' && key[1] === 'n'\n\nexport const extend = <T extends object, U extends object>(\n  a: T,\n  b: U\n): T & U => {\n  for (const key in b) {\n    ;(a as any)[key] = b[key]\n  }\n  return a as any\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const isArray = Array.isArray\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === 'function'\nexport const isString = (val: unknown): val is string => typeof val === 'string'\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport function isPromise<T = any>(val: unknown): val is Promise<T> {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\n}\n\nexport const objectToString = Object.prototype.toString\nexport const toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\nexport function toRawType(value: unknown): string {\n  return toTypeString(value).slice(8, -1)\n}\n\nexport const isPlainObject = (val: unknown): val is object =>\n  toTypeString(val) === '[object Object]'\n\nexport const isReservedProp = /*#__PURE__*/ makeMap(\n  'key,ref,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted'\n)\n\nconst camelizeRE = /-(\\w)/g\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\n}\n\nconst hyphenateRE = /\\B([A-Z])/g\nexport const hyphenate = (str: string): string => {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n}\n\nexport const capitalize = (str: string): string => {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\n// compare whether a value has changed, accounting for NaN.\nexport const hasChanged = (value: any, oldValue: any): boolean =>\n  value !== oldValue && (value === value || oldValue === oldValue)\n","// global immutability lock\nexport let LOCKED = true\n\nexport function lock() {\n  LOCKED = true\n}\n\nexport function unlock() {\n  LOCKED = false\n}\n","import { reactive, readonly, toRaw } from './reactive'\nimport { OperationTypes } from './operations'\nimport { track, trigger } from './effect'\nimport { LOCKED } from './lock'\nimport { isObject, hasOwn, isSymbol, hasChanged } from '@vue/shared'\nimport { isRef } from './ref'\n\nconst builtInSymbols = new Set(\n  Object.getOwnPropertyNames(Symbol)\n    .map(key => (Symbol as any)[key])\n    .filter(isSymbol)\n)\n\n/**\n * 创建proxy里面的get处理函数\n * @param isReadonly 否是是处理只读\n */\nfunction createGetter(isReadonly: boolean) {\n  /**\n   * get函数\n   */\n  return function get(target: object, key: string | symbol, receiver: object) {\n    //获取到Reflect执行的结果\n    const res = Reflect.get(target, key, receiver)\n    //防止key为Symbol的内置对象，比如 Symbol.iterator\n    if (isSymbol(key) && builtInSymbols.has(key)) {\n      return res\n    }\n    //如果是ref包装过的数据，直接调用Value触发get，获取值之后，再返回\n    if (isRef(res)) {\n      return res.value\n    }\n    //TODO:看着像跟踪，依赖收集，后面再看\n    track(target, OperationTypes.GET, key)\n    //{a:1}\n    /**\n     * 对深层对象再次包装，\n     * 判断内层是否是对象，不是就直接返回\n     * 如果是对象，判断是否是要做只读处理，\n     * 如果是只读，就调用只读\n     * 不是的话，就调用\n     */\n    return isObject(res)\n      ? isReadonly\n        ? // need to lazy access readonly and reactive here to avoid\n          // circular dependency\n          readonly(res)\n        : reactive(res)\n      : res\n  }\n\n  /**\n    c={\n      a:{\n        b{\n\n        }\n      }\n    }\n  */\n\n  /**\n  \n    obj={\n      a:{\n        b:{\n          c:1\n        }\n      }\n    }\n  */\n}\n\n/**\n * proxy中set方法的优化,包含只读数据的处理和响应式数据的处理\n * @param target\n * @param key\n * @param value\n * @param receiver\n */\nfunction set(\n  target: object,\n  key: string | symbol,\n  value: unknown,\n  receiver: object\n): boolean {\n  //获取原始的数据\n  value = toRaw(value)\n  //拿到之前的老值\n  const oldValue = (target as any)[key]\n  //判断老数据是否是已经被ref处理过的，并且新数据没有没ref处理过\n  if (isRef(oldValue) && !isRef(value)) {\n    //更新老数据，并且返回\n    // 如果 value 不是响应式数据，则需要将其赋值给 oldValue，调用set value，\n    //如果 isObject(value) ，则会经过 reactive 再包装一次，将其变成响应式数据\n    oldValue.value = value\n    return true\n  }\n  /**\n   *   key是target自己的属性\n   *\n   *   这个方法是解决 数组push时，会调用两次 set 的情况，比如 arr.push(1)\n   *   第一次set，在数组尾部添加1\n   *   第二次set，给数组添加length属性\n   *   hasOwnProperty 方法用来判断目标对象是否含有指定属性。数组本身就有length的属性，所以这里是 true\n   */\n  const hadKey = hasOwn(target, key)\n  //执行返回结果\n  const result = Reflect.set(target, key, value, receiver)\n  // don't trigger if target is something up in the prototype chain of original\n  //target 如果只读 或者 存在于 reactiveToRaw 则不进入条件，reactiveToRaw 储存着代理后的对象\n  //已经是代理之后的值了\n  if (target === toRaw(receiver)) {\n    //如果是原始数据原型链上自己的操作，就不触发\n    /* istanbul ignore else */\n    if (__DEV__) {\n      const extraInfo = { oldValue, newValue: value }\n      if (!hadKey) {\n        trigger(target, OperationTypes.ADD, key, extraInfo)\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, OperationTypes.SET, key, extraInfo)\n      }\n    } else {\n      //属性新增，触发 ADD 枚举\n      if (!hadKey) {\n        trigger(target, OperationTypes.ADD, key)\n      } else if (hasChanged(value, oldValue)) {\n        //当新值与旧值不相等时\n        // 属性修改，触发 SET 枚举\n        trigger(target, OperationTypes.SET, key)\n      }\n    }\n  }\n  return result\n}\n\n//删除属性处理\nfunction deleteProperty(target: object, key: string | symbol): boolean {\n  const hadKey = hasOwn(target, key)\n  const oldValue = (target as any)[key]\n  const result = Reflect.deleteProperty(target, key)\n  if (result && hadKey) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.DELETE, key, { oldValue })\n    } else {\n      trigger(target, OperationTypes.DELETE, key)\n    }\n  }\n  return result\n}\n//查询属性处理\nfunction has(target: object, key: string | symbol): boolean {\n  const result = Reflect.has(target, key)\n  track(target, OperationTypes.HAS, key)\n  return result\n}\n//获取key的属性处理\nfunction ownKeys(target: object): (string | number | symbol)[] {\n  track(target, OperationTypes.ITERATE)\n  return Reflect.ownKeys(target)\n}\n\n//可变数据处理handler\nexport const mutableHandlers: ProxyHandler<object> = {\n  get: createGetter(false),\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n\n//只读数据handler\nexport const readonlyHandlers: ProxyHandler<any> = {\n  //创建get\n  get: createGetter(true),\n  //创建set\n  set(\n    target: object,\n    key: string | symbol,\n    value: unknown,\n    receiver: object\n  ): boolean {\n    //判断是否已经锁住\n    if (LOCKED) {\n      if (__DEV__) {\n        console.warn(\n          `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n          target\n        )\n      }\n      return true\n    } else {\n      return set(target, key, value, receiver)\n    }\n  },\n\n  deleteProperty(target: object, key: string | symbol): boolean {\n    if (LOCKED) {\n      if (__DEV__) {\n        console.warn(\n          `Delete operation on key \"${String(\n            key\n          )}\" failed: target is readonly.`,\n          target\n        )\n      }\n      return true\n    } else {\n      return deleteProperty(target, key)\n    }\n  },\n\n  has,\n  ownKeys\n}\n","import { toRaw, reactive, readonly } from './reactive'\nimport { track, trigger } from './effect'\nimport { OperationTypes } from './operations'\nimport { LOCKED } from './lock'\nimport { isObject, capitalize, hasOwn, hasChanged } from '@vue/shared'\n\nexport type CollectionTypes = IterableCollections | WeakCollections\n\ntype IterableCollections = Map<any, any> | Set<any>\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\ntype MapTypes = Map<any, any> | WeakMap<any, any>\ntype SetTypes = Set<any> | WeakSet<any>\n\nconst toReactive = <T extends unknown>(value: T): T =>\n  isObject(value) ? reactive(value) : value\n\nconst toReadonly = <T extends unknown>(value: T): T =>\n  isObject(value) ? readonly(value) : value\n\nconst getProto = <T extends CollectionTypes>(v: T): any =>\n  Reflect.getPrototypeOf(v)\n\nfunction get(\n  target: MapTypes,\n  key: unknown,\n  wrap: typeof toReactive | typeof toReadonly\n) {\n  target = toRaw(target)\n  key = toRaw(key)\n  track(target, OperationTypes.GET, key)\n  return wrap(getProto(target).get.call(target, key))\n}\n\nfunction has(this: CollectionTypes, key: unknown): boolean {\n  const target = toRaw(this)\n  key = toRaw(key)\n  track(target, OperationTypes.HAS, key)\n  return getProto(target).has.call(target, key)\n}\n\nfunction size(target: IterableCollections) {\n  target = toRaw(target)\n  track(target, OperationTypes.ITERATE)\n  return Reflect.get(getProto(target), 'size', target)\n}\n\nfunction add(this: SetTypes, value: unknown) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const proto = getProto(target)\n  const hadKey = proto.has.call(target, value)\n  const result = proto.add.call(target, value)\n  if (!hadKey) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.ADD, value, { newValue: value })\n    } else {\n      trigger(target, OperationTypes.ADD, value)\n    }\n  }\n  return result\n}\n\nfunction set(this: MapTypes, key: unknown, value: unknown) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const proto = getProto(target)\n  const hadKey = proto.has.call(target, key)\n  const oldValue = proto.get.call(target, key)\n  const result = proto.set.call(target, key, value)\n  /* istanbul ignore else */\n  if (__DEV__) {\n    const extraInfo = { oldValue, newValue: value }\n    if (!hadKey) {\n      trigger(target, OperationTypes.ADD, key, extraInfo)\n    } else if (hasChanged(value, oldValue)) {\n      trigger(target, OperationTypes.SET, key, extraInfo)\n    }\n  } else {\n    if (!hadKey) {\n      trigger(target, OperationTypes.ADD, key)\n    } else if (hasChanged(value, oldValue)) {\n      trigger(target, OperationTypes.SET, key)\n    }\n  }\n  return result\n}\n\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\n  const target = toRaw(this)\n  const proto = getProto(target)\n  const hadKey = proto.has.call(target, key)\n  const oldValue = proto.get ? proto.get.call(target, key) : undefined\n  // forward the operation before queueing reactions\n  const result = proto.delete.call(target, key)\n  if (hadKey) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.DELETE, key, { oldValue })\n    } else {\n      trigger(target, OperationTypes.DELETE, key)\n    }\n  }\n  return result\n}\n\nfunction clear(this: IterableCollections) {\n  const target = toRaw(this)\n  const hadItems = target.size !== 0\n  const oldTarget = __DEV__\n    ? target instanceof Map\n      ? new Map(target)\n      : new Set(target)\n    : undefined\n  // forward the operation before queueing reactions\n  const result = getProto(target).clear.call(target)\n  if (hadItems) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.CLEAR, void 0, { oldTarget })\n    } else {\n      trigger(target, OperationTypes.CLEAR)\n    }\n  }\n  return result\n}\n\nfunction createForEach(isReadonly: boolean) {\n  return function forEach(\n    this: IterableCollections,\n    callback: Function,\n    thisArg?: unknown\n  ) {\n    const observed = this\n    const target = toRaw(observed)\n    const wrap = isReadonly ? toReadonly : toReactive\n    track(target, OperationTypes.ITERATE)\n    // important: create sure the callback is\n    // 1. invoked with the reactive map as `this` and 3rd arg\n    // 2. the value received should be a corresponding reactive/readonly.\n    function wrappedCallback(value: unknown, key: unknown) {\n      return callback.call(observed, wrap(value), wrap(key), observed)\n    }\n    return getProto(target).forEach.call(target, wrappedCallback, thisArg)\n  }\n}\n\nfunction createIterableMethod(method: string | symbol, isReadonly: boolean) {\n  return function(this: IterableCollections, ...args: unknown[]) {\n    const target = toRaw(this)\n    const isPair =\n      method === 'entries' ||\n      (method === Symbol.iterator && target instanceof Map)\n    const innerIterator = getProto(target)[method].apply(target, args)\n    const wrap = isReadonly ? toReadonly : toReactive\n    track(target, OperationTypes.ITERATE)\n    // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next()\n        return done\n          ? { value, done }\n          : {\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n              done\n            }\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this\n      }\n    }\n  }\n}\n\nfunction createReadonlyMethod(\n  method: Function,\n  type: OperationTypes\n): Function {\n  return function(this: CollectionTypes, ...args: unknown[]) {\n    if (LOCKED) {\n      if (__DEV__) {\n        const key = args[0] ? `on key \"${args[0]}\" ` : ``\n        console.warn(\n          `${capitalize(type)} operation ${key}failed: target is readonly.`,\n          toRaw(this)\n        )\n      }\n      return type === OperationTypes.DELETE ? false : this\n    } else {\n      return method.apply(this, args)\n    }\n  }\n}\n\nconst mutableInstrumentations: Record<string, Function> = {\n  get(this: MapTypes, key: unknown) {\n    return get(this, key, toReactive)\n  },\n  get size(this: IterableCollections) {\n    return size(this)\n  },\n  has,\n  add,\n  set,\n  delete: deleteEntry,\n  clear,\n  forEach: createForEach(false)\n}\n\nconst readonlyInstrumentations: Record<string, Function> = {\n  get(this: MapTypes, key: unknown) {\n    return get(this, key, toReadonly)\n  },\n  get size(this: IterableCollections) {\n    return size(this)\n  },\n  has,\n  add: createReadonlyMethod(add, OperationTypes.ADD),\n  set: createReadonlyMethod(set, OperationTypes.SET),\n  delete: createReadonlyMethod(deleteEntry, OperationTypes.DELETE),\n  clear: createReadonlyMethod(clear, OperationTypes.CLEAR),\n  forEach: createForEach(true)\n}\n\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\niteratorMethods.forEach(method => {\n  mutableInstrumentations[method as string] = createIterableMethod(\n    method,\n    false\n  )\n  readonlyInstrumentations[method as string] = createIterableMethod(\n    method,\n    true\n  )\n})\n\nfunction createInstrumentationGetter(\n  instrumentations: Record<string, Function>\n) {\n  return (\n    target: CollectionTypes,\n    key: string | symbol,\n    receiver: CollectionTypes\n  ) =>\n    Reflect.get(\n      hasOwn(instrumentations, key) && key in target\n        ? instrumentations\n        : target,\n      key,\n      receiver\n    )\n}\n\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: createInstrumentationGetter(mutableInstrumentations)\n}\n\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: createInstrumentationGetter(readonlyInstrumentations)\n}\n","import { isObject, toRawType } from '@vue/shared'\nimport { mutableHandlers, readonlyHandlers } from './baseHandlers'\nimport {\n  mutableCollectionHandlers,\n  readonlyCollectionHandlers\n} from './collectionHandlers'\nimport { ReactiveEffect } from './effect'\nimport { UnwrapRef, Ref } from './ref'\nimport { makeMap } from '@vue/shared'\n\n/*\nreactive: 本库的核心方法，传递一个object类型的原始数据，\n通过Proxy，返回一个代理数据。在这过程中，劫持了原始数据的任何读写操作。\n进而实现改变代理数据时，能触发依赖其的监听函数effect。\n*/\n\n// The main WeakMap that stores {target -> key -> dep} connections.\n// Conceptually, it's easier to think of a dependency as a Dep class\n// which maintains a Set of subscribers, but we simply store them as\n// raw Sets to reduce memory overhead.\n//这个WeakMap储存着（target-> key->dep）,在概念上，把依赖看着Dep 类维护了一组订阅，更好理解，\n//我们只是把它储存为原始set 可以减少内存开销\n\nexport type Dep = Set<ReactiveEffect>\nexport type KeyToDepMap = Map<any, Dep>\nexport const targetMap = new WeakMap<any, KeyToDepMap>()\n\n// WeakMaps that store {raw <-> observed} pairs.\n//原始数据到响应数据之间的映射\nconst rawToReactive = new WeakMap<any, any>()\nconst reactiveToRaw = new WeakMap<any, any>()\nconst rawToReadonly = new WeakMap<any, any>()\nconst readonlyToRaw = new WeakMap<any, any>()\n\n// WeakSets for values that are marked readonly or non-reactive during\n// observable creation.\n\nconst readonlyValues = new WeakSet<any>()\nconst nonReactiveValues = new WeakSet<any>()\n\nconst collectionTypes = new Set<Function>([Set, Map, WeakMap, WeakSet])\nconst isObservableType = /*#__PURE__*/ makeMap(\n  'Object,Array,Map,Set,WeakMap,WeakSet'\n)\n\n/**\n * 判断是否可以observable\n * @param value\n */\nconst canObserve = (value: any): boolean => {\n  return (\n    //不是Vue对象\n    !value._isVue &&\n    //不是VNode\n    !value._isVNode &&\n    //是Object、Array、Map、Set、WeakMap、WeakSet\n    isObservableType(toRawType(value)) &&\n    //没有被代理过\n    !nonReactiveValues.has(value)\n  )\n}\n\n// only unwrap nested ref\ntype UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRef<T>\n\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\nexport function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  //如果target是只读，返回这个target\n  if (readonlyToRaw.has(target)) {\n    return target\n  }\n  // target is explicitly marked as readonly by user\n  //target被用户标记成了只读，那么就让他变成只读，并返回\n  if (readonlyValues.has(target)) {\n    return readonly(target)\n  }\n\n  /*\n    { {a:1}:Proxy }\n  */\n  //创建响应式数据\n  return createReactiveObject(\n    target, //原始值\n    rawToReactive, //原始值到响应数据的映射  { {a:1}:Proxy }\n    reactiveToRaw, //响应数据到原始值的映射 { Proxy:{a:1} }\n    mutableHandlers,\n    mutableCollectionHandlers\n  )\n}\n\nexport function readonly<T extends object>(\n  target: T\n): Readonly<UnwrapNestedRefs<T>> {\n  // value is a mutable observable, retrieve its original and return\n  // a readonly version.\n  //如果值已经是响应类型的值了，那么就取出他的原始值\n  if (reactiveToRaw.has(target)) {\n    target = reactiveToRaw.get(target)\n  }\n  //创建响应对象\n  return createReactiveObject(\n    target, //原始值\n    rawToReadonly, //原始值到只读数据的映射\n    readonlyToRaw, //只读数据到原始值的映射\n    readonlyHandlers,\n    readonlyCollectionHandlers\n  )\n}\n/**\n * 创建响应类型\n * @param target\n * @param toProxy\n * @param toRaw\n * @param baseHandlers\n * @param collectionHandlers\n */\nfunction createReactiveObject(\n  target: unknown,\n  toProxy: WeakMap<any, any>,\n  toRaw: WeakMap<any, any>,\n  baseHandlers: ProxyHandler<any>,\n  collectionHandlers: ProxyHandler<any>\n) {\n  //判断是否是基本元素（数字、字符串、布尔），如果是基本元素，就直接返回\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // target already has corresponding Proxy\n  //获取已经处理过的对象（可相应的、只读的）\n  let observed = toProxy.get(target) ///原始值到响应数据的映射  { {a:1}:Proxy }\n  //如果已经有了处理过的对象（可相应的、只读的），直接返回此对象\n  if (observed !== void 0) {\n    return observed\n  }\n  // target is already a Proxy\n  //数据已经是一个处理过的对象（可相应的、只读的），返回\n  if (toRaw.has(target)) {\n    //响应数据到原始值的映射 { Proxy:{a:1} }\n    return target\n  }\n  // only a whitelist of value types can be observed.\n  //只有白名单的对象才可以被代理\n  if (!canObserve(target)) {\n    return target\n  }\n  //collectionTypes表示Set, Map, WeakMap, WeakSet的集合，判断对象是否是这几种类型，来使用不同的处理函数\n  const handlers = collectionTypes.has(target.constructor)\n    ? collectionHandlers\n    : baseHandlers\n  //数据处理\n  observed = new Proxy(target, handlers)\n  toProxy.set(target, observed) //设置原始数据到处理后的数据的弱引用\n  toRaw.set(observed, target) //设置处理后的数据到原始数据的弱引用\n  //如果之前数据没有处理过，那么就设置target到key到Dep的引用关系\n  if (!targetMap.has(target)) {\n    targetMap.set(target, new Map())\n  }\n  return observed\n}\n\nexport function isReactive(value: unknown): boolean {\n  return reactiveToRaw.has(value) || readonlyToRaw.has(value)\n}\n\nexport function isReadonly(value: unknown): boolean {\n  return readonlyToRaw.has(value)\n}\n\n/**\n * 获取原始数据\n * @param observed\n */\nexport function toRaw<T>(observed: T): T {\n  return reactiveToRaw.get(observed) || readonlyToRaw.get(observed) || observed\n}\n\n/**\n * 标记数据为只读数据\n * @param value\n */\nexport function markReadonly<T>(value: T): T {\n  readonlyValues.add(value)\n  return value\n}\n\n//标记没有被处理过的数据\nexport function markNonReactive<T>(value: T): T {\n  nonReactiveValues.add(value)\n  return value\n}\n","import { OperationTypes } from './operations'\nimport { Dep, targetMap } from './reactive'\nimport { EMPTY_OBJ, extend } from '@vue/shared'\n\nexport const effectSymbol = Symbol(__DEV__ ? 'effect' : void 0)\n/**\n * effect：接受一个函数，返回一个新的监听函数 reactiveEffect 。\n 若监听函数内部依赖了reactive数据，当这些数据变更时会触发监听函数。\n */\n/**\n * 绑定阶段：effect 函数会包装传入的 方法，\n * 将其变成一个 effect 对象，并在绑定阶段的最后执行一遍传入的 方法（初始化）。\n */\n\n/**\n * 收集阶段：effect 传入的方法内部，有响应式对象参与了计算，\n * 将触发 get 操作，会执行 track 方法，track 方法的重点是\n * 将响应式对象改变的target 与 绑定阶段的 effect 对象一一对应起来。\n * 这两个阶段是同步执行的（activeReactiveEffectStack 协调），值会存在全局的 targetMap。\n */\n\n/**\n * 触发阶段：当 响应式对象 set 时，\n * 会触发 trigger 方法，它会从 targetMap 中拿到\n * target 对应的 effects，并遍历执行。\n */\nexport interface ReactiveEffect<T = any> {\n  (): T\n  _isEffect: true\n  active: boolean\n  raw: () => T\n  deps: Array<Dep>\n  options: ReactiveEffectOptions\n}\n\nexport interface ReactiveEffectOptions {\n  lazy?: boolean\n  computed?: boolean\n  scheduler?: (run: Function) => void\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  onStop?: () => void\n}\n\nexport type DebuggerEvent = {\n  effect: ReactiveEffect\n  target: object\n  type: OperationTypes\n  key: any\n} & DebuggerEventExtraInfo\n\nexport interface DebuggerEventExtraInfo {\n  newValue?: any\n  oldValue?: any\n  oldTarget?: Map<any, any> | Set<any>\n}\n\nexport const effectStack: ReactiveEffect[] = []\n\nexport const ITERATE_KEY = Symbol('iterate')\n\nexport function isEffect(fn: any): fn is ReactiveEffect {\n  return fn != null && fn._isEffect === true\n}\n\n//() => (dummy = counter.num)\nexport function effect<T = any>(\n  fn: () => T,\n  options: ReactiveEffectOptions = EMPTY_OBJ\n): ReactiveEffect<T> {\n  if (isEffect(fn)) {\n    fn = fn.raw\n  }\n  const effect = createReactiveEffect(fn, options)\n  if (!options.lazy) {\n    //\n    //默认{}\n    effect()\n  }\n  return effect\n}\n\nexport function stop(effect: ReactiveEffect) {\n  if (effect.active) {\n    cleanup(effect)\n    if (effect.options.onStop) {\n      effect.options.onStop()\n    }\n    effect.active = false\n  }\n}\n\n//() => (dummy = counter.num)\nfunction createReactiveEffect<T = any>(\n  fn: () => T,\n  options: ReactiveEffectOptions\n): ReactiveEffect<T> {\n  const effect = function reactiveEffect(...args: unknown[]): unknown {\n    return run(effect, fn, args)\n  } as ReactiveEffect\n  effect._isEffect = true\n  effect.active = true\n  effect.raw = fn\n  effect.deps = []\n  effect.options = options\n  return effect\n}\n\nfunction run(effect: ReactiveEffect, fn: Function, args: unknown[]): unknown {\n  if (!effect.active) {\n    return fn(...args)\n  }\n  //在监听函数中，又改变了依赖数据，按正常逻辑是会不断的触发监听函数的。\n  //但通过effectStack.includes(effect)这么一个判断逻辑，自然而然就避免了递归循环。\n  if (!effectStack.includes(effect)) {\n    //effectStack中没有包含effect时，才走这一步\n    cleanup(effect) //处理监听函数中可能有逻辑判断，导致有的数据不需要获取，如果所以可以避免每次更新\n\n    /**\n    执行effect-->把effect放入到栈中-->\n    执行fn，触发get-->触发track-->\n    触发effectStack[effectStack.length-1]，收集依赖-->\n    添加dep（[effect]）到effect.deps-->执行完fn，effectStack出栈\n    */\n    try {\n      //将本effect推到effect栈中\n\n      /*[effect = function reactiveEffect(...args: unknown[]): unknown {\n        return run(effect, fn, args)\n      } ]*/\n      effectStack.push(effect)\n      return fn(...args)\n      //执行原始函数并返回\n    } finally {\n      // console.log('effectStack出栈')\n      effectStack.pop()\n    }\n  }\n}\n/**\n * 清除effect.deps的依赖，就可以更新targetMap{\n   targetMap{\n     key:{\n       set([effect]);//这其中的依赖\n     }\n   }\n }，就可以避免不必要的重复更新\n * @param effect \n */\nfunction cleanup(effect: ReactiveEffect) {\n  const { deps } = effect\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect)\n    }\n    deps.length = 0\n  }\n}\n\nlet shouldTrack = true\n\nexport function pauseTracking() {\n  shouldTrack = false\n}\n\nexport function resumeTracking() {\n  shouldTrack = true\n}\n\n//{a:1}\n\nexport function track(target: object, type: OperationTypes, key?: unknown) {\n  if (!shouldTrack || effectStack.length === 0) {\n    return\n  }\n  const effect = effectStack[effectStack.length - 1]\n  if (type === OperationTypes.ITERATE) {\n    key = ITERATE_KEY\n  }\n  /**\n   * targetMap 存储着原始数据到操作类型到具体操作的东西\n   * target->depsMap{key->dep{->effect}}\n   * {\n   *  target:{\n   *    key(对象对应的某一个key)):Set([effect])\n   *  }\n   * }\n   */\n  let depsMap = targetMap.get(target)\n  if (depsMap === void 0) {\n    targetMap.set(target, (depsMap = new Map()))\n  }\n  let dep = depsMap.get(key!)\n  if (dep === void 0) {\n    depsMap.set(key!, (dep = new Set()))\n  }\n  if (!dep.has(effect)) {\n    dep.add(effect)\n    effect.deps.push(dep)\n    if (__DEV__ && effect.options.onTrack) {\n      effect.options.onTrack({\n        effect,\n        target,\n        type,\n        key\n      })\n    }\n  }\n}\n\nexport function trigger(\n  target: object,\n  type: OperationTypes,\n  key?: unknown,\n  extraInfo?: DebuggerEventExtraInfo\n) {\n  /**\n   * targetMap 存储着原始数据到操作类型到具体操作的东西\n   * target->depsMap{key->dep{->effect}}\n   * {\n   *  target:{\n   *    key(get、set):Set([effect])\n   *  }\n   * }\n   */\n  const depsMap = targetMap.get(target)\n  if (depsMap === void 0) {\n    // never been tracked\n    return\n  }\n  const effects = new Set<ReactiveEffect>()\n  const computedRunners = new Set<ReactiveEffect>()\n  if (type === OperationTypes.CLEAR) {\n    // collection being cleared, trigger all effects for target\n    depsMap.forEach(dep => {\n      addRunners(effects, computedRunners, dep)\n    })\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      addRunners(effects, computedRunners, depsMap.get(key))\n    }\n    // also run for iteration key on ADD | DELETE\n    if (type === OperationTypes.ADD || type === OperationTypes.DELETE) {\n      //对于push操作，length已经会变得相同，不会触发两次trigger，所以新增需要特殊处理\n      const iterationKey = Array.isArray(target) ? 'length' : ITERATE_KEY\n      addRunners(effects, computedRunners, depsMap.get(iterationKey))\n    }\n  }\n  const run = (effect: ReactiveEffect) => {\n    scheduleRun(effect, target, type, key, extraInfo)\n  }\n  // Important: computed effects must be run first so that computed getters\n  // can be invalidated before any normal effects that depend on them are run.\n  computedRunners.forEach(run)\n  effects.forEach(run)\n}\n\nfunction addRunners(\n  effects: Set<ReactiveEffect>,\n  computedRunners: Set<ReactiveEffect>,\n  effectsToAdd: Set<ReactiveEffect> | undefined\n) {\n  if (effectsToAdd !== void 0) {\n    effectsToAdd.forEach(effect => {\n      if (effect.options.computed) {\n        computedRunners.add(effect)\n      } else {\n        effects.add(effect)\n      }\n    })\n  }\n}\n\nfunction scheduleRun(\n  effect: ReactiveEffect,\n  target: object,\n  type: OperationTypes,\n  key: unknown,\n  extraInfo?: DebuggerEventExtraInfo\n) {\n  if (__DEV__ && effect.options.onTrigger) {\n    const event: DebuggerEvent = {\n      effect,\n      target,\n      key,\n      type\n    }\n    effect.options.onTrigger(extraInfo ? extend(event, extraInfo) : event)\n  }\n  if (effect.options.scheduler !== void 0) {\n    effect.options.scheduler(effect)\n  } else {\n    effect()\n  }\n}\n","import { track, trigger } from './effect'\nimport { OperationTypes } from './operations'\nimport { isObject } from '@vue/shared'\nimport { reactive } from './reactive'\nimport { ComputedRef } from './computed'\nimport { CollectionTypes } from './collectionHandlers'\n\n/**\n * Ref存在的原因是对基本数据的处理\n */\nexport interface Ref<T = any> {\n  _isRef: true\n  value: UnwrapRef<T>\n}\n\nconst convert = <T extends unknown>(val: T): T =>\n  isObject(val) ? reactive(val) : val\n\nexport function ref<T extends Ref>(raw: T): T\nexport function ref<T>(raw: T): Ref<T>\nexport function ref<T = any>(): Ref<T>\nexport function ref(raw?: unknown) {\n  if (isRef(raw)) {\n    return raw\n  }\n  /**\n   * 如果是对象，则用 reactive 方法 包装 raw,不是就返回原始值\n   * const convert = (val: any): any => (isObject(val) ? reactive(val) : val)\n   */\n  raw = convert(raw)\n\n  /**\n   * 返回v，Ref类型，获取value值的时候，调用track方法，存value值时，调用 trigger方法\n   * v.value触发get，v.value=2触发set\n   */\n  const r = {\n    _isRef: true,\n    get value() {\n      //TODO:why track\n      track(r, OperationTypes.GET, '')\n      return raw\n    },\n    set value(newVal) {\n      //对数据包装\n      raw = convert(newVal)\n      //TODO:why trigger\n      trigger(r, OperationTypes.SET, '')\n    }\n  }\n  return r as Ref\n}\n\n//判断是否是ref\nexport function isRef(r: any): r is Ref {\n  return r ? r._isRef === true : false\n}\n/**\n * 把代理对象转换为ref\n * @param object\n */\nexport function toRefs<T extends object>(\n  object: T\n): { [K in keyof T]: Ref<T[K]> } {\n  const ret: any = {}\n  for (const key in object) {\n    ret[key] = toProxyRef(object, key)\n  }\n  return ret\n}\n/**\n * 转换ref数据\n * @param object\n * @param key\n */\nfunction toProxyRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K\n): Ref<T[K]> {\n  return {\n    _isRef: true,\n    get value(): any {\n      return object[key]\n    },\n    set value(newVal) {\n      object[key] = newVal\n    }\n  }\n}\n\n// Recursively unwraps nested value bindings.\nexport type UnwrapRef<T> = {\n  cRef: T extends ComputedRef<infer V> ? UnwrapRef<V> : T\n  ref: T extends Ref<infer V> ? UnwrapRef<V> : T\n  array: T extends Array<infer V> ? Array<UnwrapRef<V>> : T\n  object: { [K in keyof T]: UnwrapRef<T[K]> }\n}[T extends ComputedRef<any>\n  ? 'cRef'\n  : T extends Ref\n    ? 'ref'\n    : T extends Array<any>\n      ? 'array'\n      : T extends Function | CollectionTypes\n        ? 'ref' // bail out on types that shouldn't be unwrapped\n        : T extends object ? 'object' : 'ref']\n","import { effect, ReactiveEffect, effectStack } from './effect'\nimport { Ref, UnwrapRef } from './ref'\nimport { isFunction, NOOP } from '@vue/shared'\n/**\ncomputed: 计算数据，接受一个getter函数或者包含get/set行为的对象，返回一个响应式的数据。\n它若有变更，也会触发reactiveEffect。\n*/\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\n  readonly value: UnwrapRef<T>\n}\n\nexport interface WritableComputedRef<T> extends Ref<T> {\n  readonly effect: ReactiveEffect<T>\n}\n\nexport type ComputedGetter<T> = () => T\nexport type ComputedSetter<T> = (v: T) => void\n\nexport interface WritableComputedOptions<T> {\n  get: ComputedGetter<T>\n  set: ComputedSetter<T>\n}\n\nexport function computed<T>(getter: ComputedGetter<T>): ComputedRef<T>\nexport function computed<T>(\n  options: WritableComputedOptions<T>\n): WritableComputedRef<T>\nexport function computed<T>(\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>\n) {\n  let getter: ComputedGetter<T>\n  let setter: ComputedSetter<T>\n  //传入函数\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions\n    setter = __DEV__\n      ? () => {\n          console.warn('Write operation failed: computed value is readonly')\n        }\n      : NOOP\n  } else {\n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n\n  let dirty = true\n  let value: T\n\n  //effect 方法不会立即执行，在 get 时执行\n  const runner = effect(getter, {\n    lazy: true,\n    // mark effect as computed so that it gets priority during trigger\n    computed: true,\n    scheduler: () => {\n      //在触发set时，触发trigger-->触发scheduler\n      dirty = true\n    }\n  })\n  return {\n    _isRef: true,\n    // expose effect so computed can be stopped\n    //导出了 runner 让 computed 可以被外部暂停\n    effect: runner,\n    get value() {\n      /**\n       * computed返回ref，\n       * ref的get执行effect方法，执行完毕后dirty变成了false，\n       * 只有响应对象trigger之后，dirty才会变回来为true，\n       */\n      if (dirty) {\n        value = runner()\n        dirty = false\n      }\n      // When computed effects are accessed in a parent effect, the parent\n      // should track all the dependencies the computed property has tracked.\n      // This should also apply for chained computed properties.\n      trackChildRun(runner)\n      return value\n    },\n    set value(newValue: T) {\n      setter(newValue)\n    }\n  }\n}\n\nfunction trackChildRun(childRunner: ReactiveEffect) {\n  if (effectStack.length === 0) {\n    return\n  }\n  const parentRunner = effectStack[effectStack.length - 1]\n  for (let i = 0; i < childRunner.deps.length; i++) {\n    const dep = childRunner.deps[i]\n    if (!dep.has(parentRunner)) {\n      dep.add(parentRunner)\n      parentRunner.deps.push(dep)\n    }\n  }\n}\n"],"names":["has","set"],"mappings":"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"}