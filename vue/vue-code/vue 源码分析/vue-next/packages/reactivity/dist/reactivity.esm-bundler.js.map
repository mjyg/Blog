{"version":3,"file":"reactivity.esm-bundler.js","sources":["../../shared/src/makeMap.ts","../../shared/src/index.ts","../src/lock.ts","../src/baseHandlers.ts","../src/collectionHandlers.ts","../src/reactive.ts","../src/effect.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["// Make a map and return a function for checking if a key\n// is in that map.\n//\n// IMPORTANT: all calls of this function must be prefixed with /*#__PURE__*/\n// So that rollup can tree-shake them if necessary.\nexport function makeMap(\n  str: string,\n  expectsLowerCase?: boolean\n): (key: string) => boolean {\n  const map: Record<string, boolean> = Object.create(null)\n  const list: Array<string> = str.split(',')\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\n}\n","export * from './patchFlags'\nexport { isGloballyWhitelisted } from './globalsWhitelist'\nexport { makeMap } from './makeMap'\n\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\n  ? Object.freeze({})\n  : {}\nexport const EMPTY_ARR: [] = []\n\nexport const NOOP = () => {}\n\n/**\n * Always return false.\n */\nexport const NO = () => false\n\nexport const isOn = (key: string) => key[0] === 'o' && key[1] === 'n'\n\nexport const extend = <T extends object, U extends object>(\n  a: T,\n  b: U\n): T & U => {\n  for (const key in b) {\n    ;(a as any)[key] = b[key]\n  }\n  return a as any\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const isArray = Array.isArray\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === 'function'\nexport const isString = (val: unknown): val is string => typeof val === 'string'\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport function isPromise<T = any>(val: unknown): val is Promise<T> {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\n}\n\nexport const objectToString = Object.prototype.toString\nexport const toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\nexport const isPlainObject = (val: unknown): val is object =>\n  toTypeString(val) === '[object Object]'\n\nexport const isReservedProp = (key: string): boolean =>\n  key === 'key' || key === 'ref' || key === '$once' || key.startsWith(`onVnode`)\n\nconst camelizeRE = /-(\\w)/g\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\n}\n\nconst hyphenateRE = /\\B([A-Z])/g\nexport const hyphenate = (str: string): string => {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n}\n\nexport const capitalize = (str: string): string => {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n","// global immutability lock\nexport let LOCKED = true\n\nexport function lock() {\n  LOCKED = true\n}\n\nexport function unlock() {\n  LOCKED = false\n}\n","import { reactive, readonly, toRaw } from './reactive'\nimport { OperationTypes } from './operations'\nimport { track, trigger } from './effect'\nimport { LOCKED } from './lock'\nimport { isObject, hasOwn, isSymbol } from '@vue/shared'\nimport { isRef } from './ref'\n\nconst builtInSymbols = new Set(\n  Object.getOwnPropertyNames(Symbol)\n    .map(key => (Symbol as any)[key])\n    .filter(isSymbol)\n)\n\n/**\n * 创建proxy里面的get处理函数\n * @param isReadonly 否是是处理只读\n */\nfunction createGetter(isReadonly: boolean) {\n  /**\n   * get函数\n   */\n  return function get(target: any, key: string | symbol, receiver: any) {\n    //获取到Reflect执行的结果\n    const res = Reflect.get(target, key, receiver)\n    //防止key为Symbol的内置对象，比如 Symbol.iterator\n    if (isSymbol(key) && builtInSymbols.has(key)) {\n      return res\n    }\n    //如果是ref包装过的数据，直接调用Value触发get，获取值之后，再返回\n    if (isRef(res)) {\n      return res.value\n    }\n    //TODO:看着像跟踪，依赖收集，后面再看\n    track(target, OperationTypes.GET, key)\n\n    /**\n     * 对深层对象再次包装，\n     * 判断内层是否是对象，不是就直接返回\n     * 如果是对象，判断是否是要做只读处理，\n     * 如果是只读，就调用只读\n     * 不是的话，就调用\n     */\n    return isObject(res)\n      ? isReadonly\n        ? // need to lazy access readonly and reactive here to avoid\n          // circular dependency\n          readonly(res)\n        : reactive(res)\n      : res\n  }\n}\n\n/**\n * proxy中set方法的优化,包含只读数据的处理和响应式数据的处理\n * @param target\n * @param key\n * @param value\n * @param receiver\n */\nfunction set(\n  target: any,\n  key: string | symbol,\n  value: any,\n  receiver: any\n): boolean {\n  //获取原始的数据\n  value = toRaw(value)\n  //拿到之前的老值\n  const oldValue = target[key]\n  //判断老数据是否是已经被ref处理过的，并且新数据没有没ref处理过\n  if (isRef(oldValue) && !isRef(value)) {\n    //更新老数据，并且返回\n    // 如果 value 不是响应式数据，则需要将其赋值给 oldValue，调用set value，\n    //如果 isObject(value) ，则会经过 reactive 再包装一次，将其变成响应式数据\n    oldValue.value = value\n    return true\n  }\n  /**\n   *   key是target自己的属性\n   *\n   *   这个方法是解决 数组push时，会调用两次 set 的情况，比如 arr.push(1)\n   *   第一次set，在数组尾部添加1\n   *   第二次set，给数组添加length属性\n   *   hasOwnProperty 方法用来判断目标对象是否含有指定属性。数组本身就有length的属性，所以这里是 true\n   */\n  const hadKey = hasOwn(target, key)\n  //执行返回结果\n  const result = Reflect.set(target, key, value, receiver)\n  // don't trigger if target is something up in the prototype chain of original\n  //target 如果只读 或者 存在于 reactiveToRaw 则不进入条件，reactiveToRaw 储存着代理后的对象\n  //已经是代理之后的值了\n  if (target === toRaw(receiver)) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      const extraInfo = { oldValue, newValue: value }\n      if (!hadKey) {\n        trigger(target, OperationTypes.ADD, key, extraInfo)\n      } else if (value !== oldValue) {\n        trigger(target, OperationTypes.SET, key, extraInfo)\n      }\n    } else {\n      //属性新增，触发 ADD 枚举\n      if (!hadKey) {\n        trigger(target, OperationTypes.ADD, key)\n      } else if (value !== oldValue) {\n        // 属性修改，触发 SET 枚举\n        trigger(target, OperationTypes.SET, key)\n      }\n    }\n  }\n  return result\n}\n\n//删除属性处理\nfunction deleteProperty(target: any, key: string | symbol): boolean {\n  const hadKey = hasOwn(target, key)\n  const oldValue = target[key]\n  const result = Reflect.deleteProperty(target, key)\n  if (result && hadKey) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.DELETE, key, { oldValue })\n    } else {\n      trigger(target, OperationTypes.DELETE, key)\n    }\n  }\n  return result\n}\n//查询属性处理\nfunction has(target: any, key: string | symbol): boolean {\n  const result = Reflect.has(target, key)\n  track(target, OperationTypes.HAS, key)\n  return result\n}\n//获取key的属性处理\nfunction ownKeys(target: any): (string | number | symbol)[] {\n  track(target, OperationTypes.ITERATE)\n  return Reflect.ownKeys(target)\n}\n\n//可变数据处理handler\nexport const mutableHandlers: ProxyHandler<any> = {\n  get: createGetter(false),\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n\n//只读数据handler\nexport const readonlyHandlers: ProxyHandler<any> = {\n  //创建get\n  get: createGetter(true),\n  //创建set\n  set(target: any, key: string | symbol, value: any, receiver: any): boolean {\n    //判断是否已经锁住\n    if (LOCKED) {\n      if (__DEV__) {\n        console.warn(\n          `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n          target\n        )\n      }\n      return true\n    } else {\n      return set(target, key, value, receiver)\n    }\n  },\n\n  deleteProperty(target: any, key: string | symbol): boolean {\n    if (LOCKED) {\n      if (__DEV__) {\n        console.warn(\n          `Delete operation on key \"${String(\n            key\n          )}\" failed: target is readonly.`,\n          target\n        )\n      }\n      return true\n    } else {\n      return deleteProperty(target, key)\n    }\n  },\n\n  has,\n  ownKeys\n}\n","import { toRaw, reactive, readonly } from './reactive'\nimport { track, trigger } from './effect'\nimport { OperationTypes } from './operations'\nimport { LOCKED } from './lock'\nimport { isObject, capitalize, hasOwn } from '@vue/shared'\n\nconst toReactive = (value: any) => (isObject(value) ? reactive(value) : value)\nconst toReadonly = (value: any) => (isObject(value) ? readonly(value) : value)\n\nfunction get(target: any, key: any, wrap: (t: any) => any): any {\n  target = toRaw(target)\n  key = toRaw(key)\n  const proto: any = Reflect.getPrototypeOf(target)\n  track(target, OperationTypes.GET, key)\n  const res = proto.get.call(target, key)\n  return wrap(res)\n}\n\nfunction has(this: any, key: any): boolean {\n  const target = toRaw(this)\n  key = toRaw(key)\n  const proto: any = Reflect.getPrototypeOf(target)\n  track(target, OperationTypes.HAS, key)\n  return proto.has.call(target, key)\n}\n\nfunction size(target: any) {\n  target = toRaw(target)\n  const proto = Reflect.getPrototypeOf(target)\n  track(target, OperationTypes.ITERATE)\n  return Reflect.get(proto, 'size', target)\n}\n\nfunction add(this: any, value: any) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const proto: any = Reflect.getPrototypeOf(this)\n  const hadKey = proto.has.call(target, value)\n  const result = proto.add.call(target, value)\n  if (!hadKey) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.ADD, value, { value })\n    } else {\n      trigger(target, OperationTypes.ADD, value)\n    }\n  }\n  return result\n}\n\nfunction set(this: any, key: any, value: any) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const proto: any = Reflect.getPrototypeOf(this)\n  const hadKey = proto.has.call(target, key)\n  const oldValue = proto.get.call(target, key)\n  const result = proto.set.call(target, key, value)\n  if (value !== oldValue) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      const extraInfo = { oldValue, newValue: value }\n      if (!hadKey) {\n        trigger(target, OperationTypes.ADD, key, extraInfo)\n      } else {\n        trigger(target, OperationTypes.SET, key, extraInfo)\n      }\n    } else {\n      if (!hadKey) {\n        trigger(target, OperationTypes.ADD, key)\n      } else {\n        trigger(target, OperationTypes.SET, key)\n      }\n    }\n  }\n  return result\n}\n\nfunction deleteEntry(this: any, key: any) {\n  const target = toRaw(this)\n  const proto: any = Reflect.getPrototypeOf(this)\n  const hadKey = proto.has.call(target, key)\n  const oldValue = proto.get ? proto.get.call(target, key) : undefined\n  // forward the operation before queueing reactions\n  const result = proto.delete.call(target, key)\n  if (hadKey) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.DELETE, key, { oldValue })\n    } else {\n      trigger(target, OperationTypes.DELETE, key)\n    }\n  }\n  return result\n}\n\nfunction clear(this: any) {\n  const target = toRaw(this)\n  const proto: any = Reflect.getPrototypeOf(this)\n  const hadItems = target.size !== 0\n  const oldTarget = target instanceof Map ? new Map(target) : new Set(target)\n  // forward the operation before queueing reactions\n  const result = proto.clear.call(target)\n  if (hadItems) {\n    /* istanbul ignore else */\n    if (__DEV__) {\n      trigger(target, OperationTypes.CLEAR, void 0, { oldTarget })\n    } else {\n      trigger(target, OperationTypes.CLEAR)\n    }\n  }\n  return result\n}\n\nfunction createForEach(isReadonly: boolean) {\n  return function forEach(this: any, callback: Function, thisArg?: any) {\n    const observed = this\n    const target = toRaw(observed)\n    const proto: any = Reflect.getPrototypeOf(target)\n    const wrap = isReadonly ? toReadonly : toReactive\n    track(target, OperationTypes.ITERATE)\n    // important: create sure the callback is\n    // 1. invoked with the reactive map as `this` and 3rd arg\n    // 2. the value received should be a corresponding reactive/readonly.\n    function wrappedCallback(value: any, key: any) {\n      return callback.call(observed, wrap(value), wrap(key), observed)\n    }\n    return proto.forEach.call(target, wrappedCallback, thisArg)\n  }\n}\n\nfunction createIterableMethod(method: string | symbol, isReadonly: boolean) {\n  return function(this: any, ...args: any[]) {\n    const target = toRaw(this)\n    const proto: any = Reflect.getPrototypeOf(target)\n    const isPair =\n      method === 'entries' ||\n      (method === Symbol.iterator && target instanceof Map)\n    const innerIterator = proto[method].apply(target, args)\n    const wrap = isReadonly ? toReadonly : toReactive\n    track(target, OperationTypes.ITERATE)\n    // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next()\n        return done\n          ? { value, done }\n          : {\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n              done\n            }\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this\n      }\n    }\n  }\n}\n\nfunction createReadonlyMethod(\n  method: Function,\n  type: OperationTypes\n): Function {\n  return function(this: any, ...args: any[]) {\n    if (LOCKED) {\n      if (__DEV__) {\n        const key = args[0] ? `on key \"${args[0]}\" ` : ``\n        console.warn(\n          `${capitalize(type)} operation ${key}failed: target is readonly.`,\n          toRaw(this)\n        )\n      }\n      return type === OperationTypes.DELETE ? false : this\n    } else {\n      return method.apply(this, args)\n    }\n  }\n}\n\nconst mutableInstrumentations: any = {\n  get(key: any) {\n    return get(this, key, toReactive)\n  },\n  get size() {\n    return size(this)\n  },\n  has,\n  add,\n  set,\n  delete: deleteEntry,\n  clear,\n  forEach: createForEach(false)\n}\n\nconst readonlyInstrumentations: any = {\n  get(key: any) {\n    return get(this, key, toReadonly)\n  },\n  get size() {\n    return size(this)\n  },\n  has,\n  add: createReadonlyMethod(add, OperationTypes.ADD),\n  set: createReadonlyMethod(set, OperationTypes.SET),\n  delete: createReadonlyMethod(deleteEntry, OperationTypes.DELETE),\n  clear: createReadonlyMethod(clear, OperationTypes.CLEAR),\n  forEach: createForEach(true)\n}\n\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\niteratorMethods.forEach(method => {\n  mutableInstrumentations[method] = createIterableMethod(method, false)\n  readonlyInstrumentations[method] = createIterableMethod(method, true)\n})\n\nfunction createInstrumentationGetter(instrumentations: any) {\n  return function getInstrumented(\n    target: any,\n    key: string | symbol,\n    receiver: any\n  ) {\n    target =\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target\n    return Reflect.get(target, key, receiver)\n  }\n}\n\nexport const mutableCollectionHandlers: ProxyHandler<any> = {\n  get: createInstrumentationGetter(mutableInstrumentations)\n}\n\nexport const readonlyCollectionHandlers: ProxyHandler<any> = {\n  get: createInstrumentationGetter(readonlyInstrumentations)\n}\n","import { isObject, toTypeString } from '@vue/shared'\nimport { mutableHandlers, readonlyHandlers } from './baseHandlers'\nimport {\n  mutableCollectionHandlers,\n  readonlyCollectionHandlers\n} from './collectionHandlers'\nimport { ReactiveEffect } from './effect'\nimport { UnwrapRef, Ref } from './ref'\nimport { makeMap } from '@vue/shared'\n\n// The main WeakMap that stores {target -> key -> dep} connections.\n// Conceptually, it's easier to think of a dependency as a Dep class\n// which maintains a Set of subscribers, but we simply store them as\n// raw Sets to reduce memory overhead.\n//这个WeakMap储存着（target-> key->dep）,在概念上，把依赖看着Dep 类维护了一组订阅，更好理解，\n//我们只是把它储存为原始set 可以减少内存开销\n\nexport type Dep = Set<ReactiveEffect>\nexport type KeyToDepMap = Map<string | symbol, Dep>\nexport const targetMap = new WeakMap<any, KeyToDepMap>()\n\n// WeakMaps that store {raw <-> observed} pairs.\n//原始数据到响应数据之间的映射\nconst rawToReactive = new WeakMap<any, any>()\nconst reactiveToRaw = new WeakMap<any, any>()\nconst rawToReadonly = new WeakMap<any, any>()\nconst readonlyToRaw = new WeakMap<any, any>()\n\n// WeakSets for values that are marked readonly or non-reactive during\n// observable creation.\n\nconst readonlyValues = new WeakSet<any>()\nconst nonReactiveValues = new WeakSet<any>()\n\nconst collectionTypes = new Set<Function>([Set, Map, WeakMap, WeakSet])\nconst isObservableType = /*#__PURE__*/ makeMap(\n  ['Object', 'Array', 'Map', 'Set', 'WeakMap', 'WeakSet']\n    .map(t => `[object ${t}]`)\n    .join(',')\n)\n\n/**\n * 判断是否可以observable\n * @param value\n */\nconst canObserve = (value: any): boolean => {\n  return (\n    //不是Vue对象\n    !value._isVue &&\n    //不是VNode\n    !value._isVNode &&\n    //是Object、Array、Map、Set、WeakMap、WeakSet\n    isObservableType(toTypeString(value)) &&\n    //没有被代理过\n    !nonReactiveValues.has(value)\n  )\n}\n\n// only unwrap nested ref\ntype UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRef<T>\n\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\nexport function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  //如果target是只读，返回这个target\n  if (readonlyToRaw.has(target)) {\n    return target\n  }\n  // target is explicitly marked as readonly by user\n  //target被用户标记成了只读，那么就让他变成只读，并返回\n  if (readonlyValues.has(target)) {\n    return readonly(target)\n  }\n  //创建响应式数据\n  return createReactiveObject(\n    target, //原始值\n    rawToReactive, //原始值到响应数据的映射\n    reactiveToRaw, //响应数据到原始值的映射\n    mutableHandlers,\n    mutableCollectionHandlers\n  )\n}\n\nexport function readonly<T extends object>(\n  target: T\n): Readonly<UnwrapNestedRefs<T>> {\n  // value is a mutable observable, retrieve its original and return\n  // a readonly version.\n  //如果值已经是响应类型的值了，那么就取出他的原始值\n  if (reactiveToRaw.has(target)) {\n    target = reactiveToRaw.get(target)\n  }\n  //创建响应对象\n  return createReactiveObject(\n    target, //原始值\n    rawToReadonly, //原始值到只读数据的映射\n    readonlyToRaw, //只读数据到原始值的映射\n    readonlyHandlers,\n    readonlyCollectionHandlers\n  )\n}\n/**\n * 创建响应类型\n * @param target\n * @param toProxy\n * @param toRaw\n * @param baseHandlers\n * @param collectionHandlers\n */\nfunction createReactiveObject(\n  target: any,\n  toProxy: WeakMap<any, any>,\n  toRaw: WeakMap<any, any>,\n  baseHandlers: ProxyHandler<any>,\n  collectionHandlers: ProxyHandler<any>\n) {\n  //判断是否是基本元素（数字、字符串、布尔），如果是基本元素，就直接返回\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // target already has corresponding Proxy\n  //获取已经处理过的对象（可相应的、只读的）\n  let observed = toProxy.get(target)\n  //如果已经有了处理过的对象（可相应的、只读的），直接返回此对象\n  if (observed !== void 0) {\n    return observed\n  }\n  // target is already a Proxy\n  //数据已经是一个处理过的对象（可相应的、只读的），返回\n  if (toRaw.has(target)) {\n    return target\n  }\n  // only a whitelist of value types can be observed.\n  //只有白名单的对象才可以被代理\n  if (!canObserve(target)) {\n    return target\n  }\n  //collectionTypes表示Set, Map, WeakMap, WeakSet的集合，判断对象是否是这几种类型，来使用不同的处理函数\n  const handlers = collectionTypes.has(target.constructor)\n    ? collectionHandlers\n    : baseHandlers\n  //数据处理\n  observed = new Proxy(target, handlers)\n  toProxy.set(target, observed) //设置原始数据到处理后的数据的弱引用\n  toRaw.set(observed, target) //设置处理后的数据到原始数据的弱引用\n  //如果之前数据没有处理过，那么就设置target到key到Dep的引用关系\n  if (!targetMap.has(target)) {\n    targetMap.set(target, new Map())\n  }\n  return observed\n}\n\nexport function isReactive(value: any): boolean {\n  return reactiveToRaw.has(value) || readonlyToRaw.has(value)\n}\n\nexport function isReadonly(value: any): boolean {\n  return readonlyToRaw.has(value)\n}\n\n/**\n * 获取原始数据\n * @param observed\n */\nexport function toRaw<T>(observed: T): T {\n  return reactiveToRaw.get(observed) || readonlyToRaw.get(observed) || observed\n}\n\n/**\n * 标记数据为只读数据\n * @param value\n */\nexport function markReadonly<T>(value: T): T {\n  readonlyValues.add(value)\n  return value\n}\n\n//标记没有被处理过的数据\nexport function markNonReactive<T>(value: T): T {\n  nonReactiveValues.add(value)\n  return value\n}\n","import { OperationTypes } from './operations'\nimport { Dep, targetMap } from './reactive'\nimport { EMPTY_OBJ, extend } from '@vue/shared'\n\nexport const effectSymbol = Symbol(__DEV__ ? 'effect' : void 0)\n\nexport interface ReactiveEffect<T = any> {\n  (): T\n  [effectSymbol]: true\n  active: boolean\n  raw: () => T\n  deps: Array<Dep>\n  computed?: boolean\n  scheduler?: (run: Function) => void\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  onStop?: () => void\n}\n\nexport interface ReactiveEffectOptions {\n  lazy?: boolean\n  computed?: boolean\n  scheduler?: (run: Function) => void\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n  onStop?: () => void\n}\n\nexport interface DebuggerEvent {\n  effect: ReactiveEffect\n  target: any\n  type: OperationTypes\n  key: string | symbol | undefined\n}\n\nexport const effectStack: ReactiveEffect[] = []\n\nexport const ITERATE_KEY = Symbol('iterate')\n\nexport function isEffect(fn: any): fn is ReactiveEffect {\n  return fn != null && fn[effectSymbol] === true\n}\n\nexport function effect<T = any>(\n  fn: () => T,\n  options: ReactiveEffectOptions = EMPTY_OBJ\n): ReactiveEffect<T> {\n  if (isEffect(fn)) {\n    fn = fn.raw\n  }\n  const effect = createReactiveEffect(fn, options)\n  if (!options.lazy) {\n    effect()\n  }\n  return effect\n}\n\nexport function stop(effect: ReactiveEffect) {\n  if (effect.active) {\n    cleanup(effect)\n    if (effect.onStop) {\n      effect.onStop()\n    }\n    effect.active = false\n  }\n}\n\nfunction createReactiveEffect<T = any>(\n  fn: () => T,\n  options: ReactiveEffectOptions\n): ReactiveEffect<T> {\n  const effect = function reactiveEffect(...args: any[]): any {\n    return run(effect, fn, args)\n  } as ReactiveEffect\n  effect[effectSymbol] = true\n  effect.active = true\n  effect.raw = fn\n  effect.scheduler = options.scheduler\n  effect.onTrack = options.onTrack\n  effect.onTrigger = options.onTrigger\n  effect.onStop = options.onStop\n  effect.computed = options.computed\n  effect.deps = []\n  return effect\n}\n\nfunction run(effect: ReactiveEffect, fn: Function, args: any[]): any {\n  if (!effect.active) {\n    return fn(...args)\n  }\n  if (!effectStack.includes(effect)) {\n    cleanup(effect)\n    try {\n      effectStack.push(effect)\n      return fn(...args)\n    } finally {\n      effectStack.pop()\n    }\n  }\n}\n\nfunction cleanup(effect: ReactiveEffect) {\n  const { deps } = effect\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect)\n    }\n    deps.length = 0\n  }\n}\n\nlet shouldTrack = true\n\nexport function pauseTracking() {\n  shouldTrack = false\n}\n\nexport function resumeTracking() {\n  shouldTrack = true\n}\n\nexport function track(\n  target: any,\n  type: OperationTypes,\n  key?: string | symbol\n) {\n  if (!shouldTrack || effectStack.length === 0) {\n    return\n  }\n  const effect = effectStack[effectStack.length - 1]\n  if (type === OperationTypes.ITERATE) {\n    key = ITERATE_KEY\n  }\n  let depsMap = targetMap.get(target)\n  if (depsMap === void 0) {\n    targetMap.set(target, (depsMap = new Map()))\n  }\n  let dep = depsMap.get(key!)\n  if (dep === void 0) {\n    depsMap.set(key!, (dep = new Set()))\n  }\n  if (!dep.has(effect)) {\n    dep.add(effect)\n    effect.deps.push(dep)\n    if (__DEV__ && effect.onTrack) {\n      effect.onTrack({\n        effect,\n        target,\n        type,\n        key\n      })\n    }\n  }\n}\n\nexport function trigger(\n  target: any,\n  type: OperationTypes,\n  key?: string | symbol,\n  extraInfo?: any\n) {\n  const depsMap = targetMap.get(target)\n  if (depsMap === void 0) {\n    // never been tracked\n    return\n  }\n  const effects = new Set<ReactiveEffect>()\n  const computedRunners = new Set<ReactiveEffect>()\n  if (type === OperationTypes.CLEAR) {\n    // collection being cleared, trigger all effects for target\n    depsMap.forEach(dep => {\n      addRunners(effects, computedRunners, dep)\n    })\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      addRunners(effects, computedRunners, depsMap.get(key))\n    }\n    // also run for iteration key on ADD | DELETE\n    if (type === OperationTypes.ADD || type === OperationTypes.DELETE) {\n      const iterationKey = Array.isArray(target) ? 'length' : ITERATE_KEY\n      addRunners(effects, computedRunners, depsMap.get(iterationKey))\n    }\n  }\n  const run = (effect: ReactiveEffect) => {\n    scheduleRun(effect, target, type, key, extraInfo)\n  }\n  // Important: computed effects must be run first so that computed getters\n  // can be invalidated before any normal effects that depend on them are run.\n  computedRunners.forEach(run)\n  effects.forEach(run)\n}\n\nfunction addRunners(\n  effects: Set<ReactiveEffect>,\n  computedRunners: Set<ReactiveEffect>,\n  effectsToAdd: Set<ReactiveEffect> | undefined\n) {\n  if (effectsToAdd !== void 0) {\n    effectsToAdd.forEach(effect => {\n      if (effect.computed) {\n        computedRunners.add(effect)\n      } else {\n        effects.add(effect)\n      }\n    })\n  }\n}\n\nfunction scheduleRun(\n  effect: ReactiveEffect,\n  target: any,\n  type: OperationTypes,\n  key: string | symbol | undefined,\n  extraInfo: any\n) {\n  if (__DEV__ && effect.onTrigger) {\n    effect.onTrigger(\n      extend(\n        {\n          effect,\n          target,\n          key,\n          type\n        },\n        extraInfo\n      )\n    )\n  }\n  if (effect.scheduler !== void 0) {\n    effect.scheduler(effect)\n  } else {\n    effect()\n  }\n}\n","import { track, trigger } from './effect'\nimport { OperationTypes } from './operations'\nimport { isObject } from '@vue/shared'\nimport { reactive } from './reactive'\nimport { ComputedRef } from './computed'\n\nexport interface Ref<T = any> {\n  _isRef: true\n  value: UnwrapRef<T>\n}\n\nconst convert = (val: any): any => (isObject(val) ? reactive(val) : val)\n\nexport function ref<T extends Ref>(raw: T): T\nexport function ref<T>(raw: T): Ref<T>\nexport function ref(raw: any) {\n  if (isRef(raw)) {\n    return raw\n  }\n  /**\n   * 如果是对象，则用 reactive 方法 包装 raw\n   * const convert = (val: any): any => (isObject(val) ? reactive(val) : val)\n   */\n  raw = convert(raw)\n\n  /**\n   * 返回v，Ref类型，获取value值的时候，调用track方法，存value值时，调用 trigger方法\n   * v.value触发get，v.value=2触发set\n   */\n  const v = {\n    _isRef: true,\n    get value() {\n      //TODO:why track\n      track(v, OperationTypes.GET, '')\n      return raw\n    },\n    set value(newVal) {\n      //对数据包装\n      raw = convert(newVal)\n      //TODO:why trigger\n      trigger(v, OperationTypes.SET, '')\n    }\n  }\n  return v as Ref\n}\n\n//判断是否是ref\nexport function isRef(v: any): v is Ref {\n  return v ? v._isRef === true : false\n}\n/**\n * 转换为ref\n * @param object\n */\nexport function toRefs<T extends object>(\n  object: T\n): { [K in keyof T]: Ref<T[K]> } {\n  const ret: any = {}\n  for (const key in object) {\n    ret[key] = toProxyRef(object, key)\n  }\n  return ret\n}\n/**\n * 转换ref数据\n * @param object\n * @param key\n */\nfunction toProxyRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K\n): Ref<T[K]> {\n  return {\n    _isRef: true,\n    get value(): any {\n      return object[key]\n    },\n    set value(newVal) {\n      object[key] = newVal\n    }\n  }\n}\n\ntype BailTypes =\n  | Function\n  | Map<any, any>\n  | Set<any>\n  | WeakMap<any, any>\n  | WeakSet<any>\n\n// Recursively unwraps nested value bindings.\nexport type UnwrapRef<T> = {\n  cRef: T extends ComputedRef<infer V> ? UnwrapRef<V> : T\n  ref: T extends Ref<infer V> ? UnwrapRef<V> : T\n  array: T extends Array<infer V> ? Array<UnwrapRef<V>> : T\n  object: { [K in keyof T]: UnwrapRef<T[K]> }\n}[T extends ComputedRef<any>\n  ? 'cRef'\n  : T extends Ref\n    ? 'ref'\n    : T extends Array<any>\n      ? 'array'\n      : T extends BailTypes\n        ? 'ref' // bail out on types that shouldn't be unwrapped\n        : T extends object ? 'object' : 'ref']\n","import { effect, ReactiveEffect, effectStack } from './effect'\nimport { Ref, UnwrapRef } from './ref'\nimport { isFunction, NOOP } from '@vue/shared'\n\nexport interface ComputedRef<T> extends WritableComputedRef<T> {\n  readonly value: UnwrapRef<T>\n}\n\nexport interface WritableComputedRef<T> extends Ref<T> {\n  readonly effect: ReactiveEffect<T>\n}\n\nexport type ComputedGetter<T> = () => T\nexport type ComputedSetter<T> = (v: T) => void\n\nexport interface WritableComputedOptions<T> {\n  get: ComputedGetter<T>\n  set: ComputedSetter<T>\n}\n\nexport function computed<T>(getter: ComputedGetter<T>): ComputedRef<T>\nexport function computed<T>(\n  options: WritableComputedOptions<T>\n): WritableComputedRef<T>\nexport function computed<T>(\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>\n): any {\n  const isReadonly = isFunction(getterOrOptions)\n  const getter = isReadonly\n    ? (getterOrOptions as ComputedGetter<T>)\n    : (getterOrOptions as WritableComputedOptions<T>).get\n  const setter = isReadonly\n    ? __DEV__\n      ? () => {\n          console.warn('Write operation failed: computed value is readonly')\n        }\n      : NOOP\n    : (getterOrOptions as WritableComputedOptions<T>).set\n\n  let dirty = true\n  let value: T\n\n  const runner = effect(getter, {\n    lazy: true,\n    // mark effect as computed so that it gets priority during trigger\n    computed: true,\n    scheduler: () => {\n      dirty = true\n    }\n  })\n  return {\n    _isRef: true,\n    // expose effect so computed can be stopped\n    effect: runner,\n    get value() {\n      if (dirty) {\n        value = runner()\n        dirty = false\n      }\n      // When computed effects are accessed in a parent effect, the parent\n      // should track all the dependencies the computed property has tracked.\n      // This should also apply for chained computed properties.\n      trackChildRun(runner)\n      return value\n    },\n    set value(newValue: T) {\n      setter(newValue)\n    }\n  }\n}\n\nfunction trackChildRun(childRunner: ReactiveEffect) {\n  if (effectStack.length === 0) {\n    return\n  }\n  const parentRunner = effectStack[effectStack.length - 1]\n  for (let i = 0; i < childRunner.deps.length; i++) {\n    const dep = childRunner.deps[i]\n    if (!dep.has(parentRunner)) {\n      dep.add(parentRunner)\n      parentRunner.deps.push(dep)\n    }\n  }\n}\n"],"names":["has","set"],"mappings":"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"}