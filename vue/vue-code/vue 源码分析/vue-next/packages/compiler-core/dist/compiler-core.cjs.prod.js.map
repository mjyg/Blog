{"version":3,"file":"compiler-core.cjs.prod.js","sources":["../../shared/src/patchFlags.ts","../../shared/src/makeMap.ts","../../shared/src/globalsWhitelist.ts","../../shared/src/index.ts","../src/errors.ts","../src/ast.ts","../src/runtimeHelpers.ts","../src/utils.ts","../src/parse.ts","../src/transforms/hoistStatic.ts","../src/transform.ts","../src/codegen.ts","../src/transforms/transformExpression.ts","../src/transforms/vIf.ts","../src/transforms/vFor.ts","../src/transforms/vSlot.ts","../src/transforms/transformElement.ts","../src/transforms/transformSlotOutlet.ts","../src/transforms/vOn.ts","../src/transforms/vBind.ts","../src/transforms/transformText.ts","../src/transforms/vOnce.ts","../src/transforms/vModel.ts","../src/codeframe.ts","../src/index.ts"],"sourcesContent":["// Patch flags are optimization hints generated by the compiler.\n// when a block with dynamicChildren is encountered during diff, the algorithm\n// enters \"optimized mode\". In this mode, we know that the vdom is produced by\n// a render function generated by the compiler, so the algorithm only needs to\n// handle updates explicitly marked by these patch flags.\n\n// Patch flags can be combined using the | bitwise operator and can be checked\n// using the & operator, e.g.\n//\n//   const flag = TEXT | CLASS\n//   if (flag & TEXT) { ... }\n//\n// Check the `patchElement` function in './createRenderer.ts' to see how the\n// flags are handled during diff.\n\nexport const enum PatchFlags {\n  // Indicates an element with dynamic textContent (children fast path)\n  TEXT = 1,\n\n  // Indicates an element with dynamic class binding.\n  CLASS = 1 << 1,\n\n  // Indicates an element with dynamic style\n  // The compiler pre-compiles static string styles into static objects\n  // + detects and hoists inline static objects\n  // e.g. style=\"color: red\" and :style=\"{ color: 'red' }\" both get hoisted as\n  //   const style = { color: 'red' }\n  //   render() { return e('div', { style }) }\n  STYLE = 1 << 2,\n\n  // Indicates an element that has non-class/style dynamic props.\n  // Can also be on a component that has any dynamic props (includes\n  // class/style). when this flag is present, the vnode also has a dynamicProps\n  // array that contains the keys of the props that may change so the runtime\n  // can diff them faster (without having to worry about removed props)\n  PROPS = 1 << 3,\n\n  // Indicates an element with props with dynamic keys. When keys change, a full\n  // diff is always needed to remove the old key. This flag is mutually\n  // exclusive with CLASS, STYLE and PROPS.\n  FULL_PROPS = 1 << 4,\n\n  // Indicates an element that only needs non-props patching, e.g. ref or\n  // directives (onVnodeXXX hooks). It simply marks the vnode as \"need patch\",\n  // since every patched vnode checks for refs and onVnodeXXX hooks.\n  // This flag is never directly matched against, it simply serves as a non-zero\n  // value.\n  NEED_PATCH = 1 << 5,\n\n  // Indicates a fragment with keyed or partially keyed children\n  KEYED_FRAGMENT = 1 << 6,\n\n  // Indicates a fragment with unkeyed children.\n  UNKEYED_FRAGMENT = 1 << 7,\n\n  // Indicates a component with dynamic slots (e.g. slot that references a v-for\n  // iterated value, or dynamic slot names).\n  // Components with this flag are always force updated.\n  DYNAMIC_SLOTS = 1 << 8,\n\n  // A special flag that indicates that the diffing algorithm should bail out\n  // of optimized mode. This is only on block fragments created by renderSlot()\n  // when encountering non-compiler generated slots (i.e. manually written\n  // render functions, which should always be fully diffed)\n  BAIL = -1\n}\n\n// runtime object for public consumption\nexport const PublicPatchFlags = {\n  TEXT: PatchFlags.TEXT,\n  CLASS: PatchFlags.CLASS,\n  STYLE: PatchFlags.STYLE,\n  PROPS: PatchFlags.PROPS,\n  NEED_PATCH: PatchFlags.NEED_PATCH,\n  FULL_PROPS: PatchFlags.FULL_PROPS,\n  KEYED_FRAGMENT: PatchFlags.KEYED_FRAGMENT,\n  UNKEYED_FRAGMENT: PatchFlags.UNKEYED_FRAGMENT,\n  DYNAMIC_SLOTS: PatchFlags.DYNAMIC_SLOTS,\n  BAIL: PatchFlags.BAIL\n}\n\n// dev only flag -> name mapping\nexport const PatchFlagNames = {\n  [PatchFlags.TEXT]: `TEXT`,\n  [PatchFlags.CLASS]: `CLASS`,\n  [PatchFlags.STYLE]: `STYLE`,\n  [PatchFlags.PROPS]: `PROPS`,\n  [PatchFlags.NEED_PATCH]: `NEED_PATCH`,\n  [PatchFlags.FULL_PROPS]: `FULL_PROPS`,\n  [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`,\n  [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`,\n  [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`,\n  [PatchFlags.BAIL]: `BAIL`\n}\n","// Make a map and return a function for checking if a key\n// is in that map.\n//\n// IMPORTANT: all calls of this function must be prefixed with /*#__PURE__*/\n// So that rollup can tree-shake them if necessary.\nexport function makeMap(\n  str: string,\n  expectsLowerCase?: boolean\n): (key: string) => boolean {\n  const map: Record<string, boolean> = Object.create(null)\n  const list: Array<string> = str.split(',')\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\n}\n","import { makeMap } from './makeMap'\n\nconst GLOBALS_WHITE_LISTED =\n  'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n  'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n  'Object,Boolean,String,RegExp,Map,Set,JSON,Intl'\n\nexport const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED)\n","export * from './patchFlags'\nexport { isGloballyWhitelisted } from './globalsWhitelist'\nexport { makeMap } from './makeMap'\n\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\n  ? Object.freeze({})\n  : {}\nexport const EMPTY_ARR: [] = []\n\nexport const NOOP = () => {}\n\n/**\n * Always return false.\n */\nexport const NO = () => false\n\nexport const isOn = (key: string) => key[0] === 'o' && key[1] === 'n'\n\nexport const extend = <T extends object, U extends object>(\n  a: T,\n  b: U\n): T & U => {\n  for (const key in b) {\n    ;(a as any)[key] = b[key]\n  }\n  return a as any\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const isArray = Array.isArray\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === 'function'\nexport const isString = (val: unknown): val is string => typeof val === 'string'\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport function isPromise<T = any>(val: unknown): val is Promise<T> {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\n}\n\nexport const objectToString = Object.prototype.toString\nexport const toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\nexport const isPlainObject = (val: unknown): val is object =>\n  toTypeString(val) === '[object Object]'\n\nexport const isReservedProp = (key: string): boolean =>\n  key === 'key' || key === 'ref' || key === '$once' || key.startsWith(`onVnode`)\n\nconst camelizeRE = /-(\\w)/g\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\n}\n\nconst hyphenateRE = /\\B([A-Z])/g\nexport const hyphenate = (str: string): string => {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n}\n\nexport const capitalize = (str: string): string => {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n","import { SourceLocation } from './ast'\n\nexport interface CompilerError extends SyntaxError {\n  code: number\n  loc?: SourceLocation\n}\n\nexport interface CoreCompilerError extends CompilerError {\n  code: ErrorCodes\n}\n\nexport function defaultOnError(error: CompilerError) {\n  throw error\n}\n\nexport function createCompilerError<T extends number>(\n  code: T,\n  loc?: SourceLocation,\n  messages?: { [code: number]: string }\n): T extends ErrorCodes ? CoreCompilerError : CompilerError {\n  const msg = __DEV__ || !__BROWSER__ ? (messages || errorMessages)[code] : code\n  const locInfo = loc ? ` (${loc.start.line}:${loc.start.column})` : ``\n  const error = new SyntaxError(msg + locInfo) as CompilerError\n  error.code = code\n  error.loc = loc\n  return error as any\n}\n\nexport const enum ErrorCodes {\n  // parse errors\n  ABRUPT_CLOSING_OF_EMPTY_COMMENT,\n  ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE,\n  CDATA_IN_HTML_CONTENT,\n  CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE,\n  CONTROL_CHARACTER_REFERENCE,\n  DUPLICATE_ATTRIBUTE,\n  END_TAG_WITH_ATTRIBUTES,\n  END_TAG_WITH_TRAILING_SOLIDUS,\n  EOF_BEFORE_TAG_NAME,\n  EOF_IN_CDATA,\n  EOF_IN_COMMENT,\n  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT,\n  EOF_IN_TAG,\n  INCORRECTLY_CLOSED_COMMENT,\n  INCORRECTLY_OPENED_COMMENT,\n  INVALID_FIRST_CHARACTER_OF_TAG_NAME,\n  MISSING_ATTRIBUTE_VALUE,\n  MISSING_END_TAG_NAME,\n  MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE,\n  MISSING_WHITESPACE_BETWEEN_ATTRIBUTES,\n  NESTED_COMMENT,\n  NONCHARACTER_CHARACTER_REFERENCE,\n  NULL_CHARACTER_REFERENCE,\n  SURROGATE_CHARACTER_REFERENCE,\n  UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\n  UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\n  UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME,\n  UNEXPECTED_NULL_CHARACTER,\n  UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\n  UNEXPECTED_SOLIDUS_IN_TAG,\n  UNKNOWN_NAMED_CHARACTER_REFERENCE,\n\n  // Vue-specific parse errors\n  X_INVALID_END_TAG,\n  X_MISSING_END_TAG,\n  X_MISSING_INTERPOLATION_END,\n  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END,\n\n  // transform errors\n  X_V_IF_NO_EXPRESSION,\n  X_V_ELSE_NO_ADJACENT_IF,\n  X_V_FOR_NO_EXPRESSION,\n  X_V_FOR_MALFORMED_EXPRESSION,\n  X_V_BIND_NO_EXPRESSION,\n  X_V_ON_NO_EXPRESSION,\n  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\n  X_V_SLOT_NAMED_SLOT_ON_COMPONENT,\n  X_V_SLOT_MIXED_SLOT_USAGE,\n  X_V_SLOT_DUPLICATE_SLOT_NAMES,\n  X_V_SLOT_EXTRANEOUS_NON_SLOT_CHILDREN,\n  X_V_SLOT_MISPLACED,\n  X_V_MODEL_NO_EXPRESSION,\n  X_V_MODEL_MALFORMED_EXPRESSION,\n  X_V_MODEL_ON_SCOPE_VARIABLE,\n  X_INVALID_EXPRESSION,\n\n  // generic errors\n  X_PREFIX_ID_NOT_SUPPORTED,\n  X_MODULE_MODE_NOT_SUPPORTED,\n\n  // Special value for higher-order compilers to pick up the last code\n  // to avoid collision of error codes. This should always be kept as the last\n  // item.\n  __EXTEND_POINT__\n}\n\nexport const errorMessages: { [code: number]: string } = {\n  // parse errors\n  [ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT]: 'Illegal comment.',\n  [ErrorCodes.ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: invalid character.',\n  [ErrorCodes.CDATA_IN_HTML_CONTENT]:\n    'CDATA section is allowed only in XML context.',\n  [ErrorCodes.CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE]:\n    'Illegal numeric character reference: too big.',\n  [ErrorCodes.CONTROL_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: control character.',\n  [ErrorCodes.DUPLICATE_ATTRIBUTE]: 'Duplicate attribute.',\n  [ErrorCodes.END_TAG_WITH_ATTRIBUTES]: 'End tag cannot have attributes.',\n  [ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS]: \"Illegal '/' in tags.\",\n  [ErrorCodes.EOF_BEFORE_TAG_NAME]: 'Unexpected EOF in tag.',\n  [ErrorCodes.EOF_IN_CDATA]: 'Unexpected EOF in CDATA section.',\n  [ErrorCodes.EOF_IN_COMMENT]: 'Unexpected EOF in comment.',\n  [ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT]:\n    'Unexpected EOF in script.',\n  [ErrorCodes.EOF_IN_TAG]: 'Unexpected EOF in tag.',\n  [ErrorCodes.INCORRECTLY_CLOSED_COMMENT]: 'Incorrectly closed comment.',\n  [ErrorCodes.INCORRECTLY_OPENED_COMMENT]: 'Incorrectly opened comment.',\n  [ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME]:\n    \"Illegal tag name. Use '&lt;' to print '<'.\",\n  [ErrorCodes.MISSING_ATTRIBUTE_VALUE]: 'Attribute value was expected.',\n  [ErrorCodes.MISSING_END_TAG_NAME]: 'End tag name was expected.',\n  [ErrorCodes.MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE]:\n    'Semicolon was expected.',\n  [ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES]:\n    'Whitespace was expected.',\n  [ErrorCodes.NESTED_COMMENT]: \"Unexpected '<!--' in comment.\",\n  [ErrorCodes.NONCHARACTER_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: non character.',\n  [ErrorCodes.NULL_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: null character.',\n  [ErrorCodes.SURROGATE_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: non-pair surrogate.',\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME]:\n    'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE]:\n    'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\n  [ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME]:\n    \"Attribute name cannot start with '='.\",\n  [ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME]:\n    \"'<?' is allowed only in XML context.\",\n  [ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG]: \"Illegal '/' in tags.\",\n  [ErrorCodes.UNKNOWN_NAMED_CHARACTER_REFERENCE]: 'Unknown entity name.',\n\n  // Vue-specific parse errors\n  [ErrorCodes.X_INVALID_END_TAG]: 'Invalid end tag.',\n  [ErrorCodes.X_MISSING_END_TAG]: 'End tag was not found.',\n  [ErrorCodes.X_MISSING_INTERPOLATION_END]:\n    'Interpolation end sign was not found.',\n  [ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END]:\n    'End bracket for dynamic directive argument was not found. ' +\n    'Note that dynamic directive argument cannot contain spaces.',\n\n  // transform errors\n  [ErrorCodes.X_V_IF_NO_EXPRESSION]: `v-if/v-else-if is missing expression.`,\n  [ErrorCodes.X_V_ELSE_NO_ADJACENT_IF]: `v-else/v-else-if has no adjacent v-if.`,\n  [ErrorCodes.X_V_FOR_NO_EXPRESSION]: `v-for is missing expression.`,\n  [ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION]: `v-for has invalid expression.`,\n  [ErrorCodes.X_V_BIND_NO_EXPRESSION]: `v-bind is missing expression.`,\n  [ErrorCodes.X_V_ON_NO_EXPRESSION]: `v-on is missing expression.`,\n  [ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET]: `Unexpected custom directive on <slot> outlet.`,\n  [ErrorCodes.X_V_SLOT_NAMED_SLOT_ON_COMPONENT]:\n    `Named v-slot on component. ` +\n    `Named slots should use <template v-slot> syntax nested inside the component.`,\n  [ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE]:\n    `Mixed v-slot usage on both the component and nested <template>.` +\n    `The default slot should also use <template> syntax when there are other ` +\n    `named slots to avoid scope ambiguity.`,\n  [ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES]: `Duplicate slot names found. `,\n  [ErrorCodes.X_V_SLOT_EXTRANEOUS_NON_SLOT_CHILDREN]:\n    `Extraneous children found when component has explicit slots. ` +\n    `These children will be ignored.`,\n  [ErrorCodes.X_V_SLOT_MISPLACED]: `v-slot can only be used on components or <template> tags.`,\n  [ErrorCodes.X_V_MODEL_NO_EXPRESSION]: `v-model is missing expression.`,\n  [ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION]: `v-model value must be a valid JavaScript member expression.`,\n  [ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\n  [ErrorCodes.X_INVALID_EXPRESSION]: `Invalid JavaScript expression.`,\n\n  // generic errors\n  [ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\n  [ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED]: `ES module mode is not supported in this build of compiler.`\n}\n","import { isString } from '@vue/shared'\nimport { ForParseResult } from './transforms/vFor'\nimport {\n  CREATE_VNODE,\n  WITH_DIRECTIVES,\n  RENDER_SLOT,\n  CREATE_SLOTS,\n  RENDER_LIST,\n  OPEN_BLOCK,\n  CREATE_BLOCK,\n  FRAGMENT\n} from './runtimeHelpers'\nimport { PropsExpression } from './transforms/transformElement'\n\n// Vue template is a platform-agnostic superset of HTML (syntax only).\n// More namespaces like SVG and MathML are declared by platform specific\n// compilers.\nexport type Namespace = number\n\nexport const enum Namespaces {\n  HTML\n}\n\nexport const enum NodeTypes {\n  ROOT,\n  ELEMENT,\n  TEXT,\n  COMMENT,\n  SIMPLE_EXPRESSION,\n  INTERPOLATION,\n  ATTRIBUTE,\n  DIRECTIVE,\n  // containers\n  COMPOUND_EXPRESSION,\n  IF,\n  IF_BRANCH,\n  FOR,\n  TEXT_CALL,\n  // codegen\n  JS_CALL_EXPRESSION,\n  JS_OBJECT_EXPRESSION,\n  JS_PROPERTY,\n  JS_ARRAY_EXPRESSION,\n  JS_FUNCTION_EXPRESSION,\n  JS_SEQUENCE_EXPRESSION,\n  JS_CONDITIONAL_EXPRESSION,\n  JS_CACHE_EXPRESSION\n}\n\nexport const enum ElementTypes {\n  ELEMENT,\n  COMPONENT,\n  SLOT,\n  TEMPLATE,\n  PORTAL,\n  SUSPENSE\n}\n\nexport interface Node {\n  type: NodeTypes\n  loc: SourceLocation\n}\n\n// The node's range. The `start` is inclusive and `end` is exclusive.\n// [start, end)\nexport interface SourceLocation {\n  start: Position\n  end: Position\n  source: string\n}\n\nexport interface Position {\n  offset: number // from start of file\n  line: number\n  column: number\n}\n\nexport type ParentNode = RootNode | ElementNode | IfBranchNode | ForNode\n\nexport type ExpressionNode = SimpleExpressionNode | CompoundExpressionNode\n\nexport type TemplateChildNode =\n  | ElementNode\n  | InterpolationNode\n  | CompoundExpressionNode\n  | TextNode\n  | CommentNode\n  | IfNode\n  | ForNode\n  | TextCallNode\n\nexport interface RootNode extends Node {\n  type: NodeTypes.ROOT\n  children: TemplateChildNode[]\n  helpers: symbol[]\n  components: string[]\n  directives: string[]\n  hoists: JSChildNode[]\n  cached: number\n  codegenNode: TemplateChildNode | JSChildNode | undefined\n}\n\nexport type ElementNode =\n  | PlainElementNode\n  | ComponentNode\n  | SlotOutletNode\n  | TemplateNode\n  | PortalNode\n  | SuspenseNode\n\nexport interface BaseElementNode extends Node {\n  type: NodeTypes.ELEMENT\n  ns: Namespace\n  tag: string\n  tagType: ElementTypes\n  isSelfClosing: boolean\n  props: Array<AttributeNode | DirectiveNode>\n  children: TemplateChildNode[]\n  codegenNode: CallExpression | SimpleExpressionNode | undefined\n}\n\nexport interface PlainElementNode extends BaseElementNode {\n  tagType: ElementTypes.ELEMENT\n  codegenNode: ElementCodegenNode | undefined | SimpleExpressionNode // only when hoisted\n}\n\nexport interface ComponentNode extends BaseElementNode {\n  tagType: ElementTypes.COMPONENT\n  codegenNode: ComponentCodegenNode | undefined\n}\n\nexport interface SlotOutletNode extends BaseElementNode {\n  tagType: ElementTypes.SLOT\n  codegenNode: SlotOutletCodegenNode | undefined\n}\n\nexport interface TemplateNode extends BaseElementNode {\n  tagType: ElementTypes.TEMPLATE\n  codegenNode:\n    | ElementCodegenNode\n    | CodegenNodeWithDirective<ElementCodegenNode>\n    | undefined\n}\n\nexport interface PortalNode extends BaseElementNode {\n  tagType: ElementTypes.PORTAL\n  codegenNode: ElementCodegenNode | undefined\n}\n\nexport interface SuspenseNode extends BaseElementNode {\n  tagType: ElementTypes.SUSPENSE\n  codegenNode: ElementCodegenNode | undefined\n}\n\nexport interface TextNode extends Node {\n  type: NodeTypes.TEXT\n  content: string\n  isEmpty: boolean\n}\n\nexport interface CommentNode extends Node {\n  type: NodeTypes.COMMENT\n  content: string\n}\n\nexport interface AttributeNode extends Node {\n  type: NodeTypes.ATTRIBUTE\n  name: string\n  value: TextNode | undefined\n}\n\nexport interface DirectiveNode extends Node {\n  type: NodeTypes.DIRECTIVE\n  name: string\n  exp: ExpressionNode | undefined\n  arg: ExpressionNode | undefined\n  modifiers: string[]\n  // optional property to cache the expression parse result for v-for\n  parseResult?: ForParseResult\n}\n\nexport interface SimpleExpressionNode extends Node {\n  type: NodeTypes.SIMPLE_EXPRESSION\n  content: string\n  isStatic: boolean\n  isConstant: boolean\n  // an expression parsed as the params of a function will track\n  // the identifiers declared inside the function body.\n  identifiers?: string[]\n}\n\nexport interface InterpolationNode extends Node {\n  type: NodeTypes.INTERPOLATION\n  content: ExpressionNode\n}\n\nexport interface CompoundExpressionNode extends Node {\n  type: NodeTypes.COMPOUND_EXPRESSION\n  children: (\n    | SimpleExpressionNode\n    | InterpolationNode\n    | TextNode\n    | string\n    | symbol)[]\n  // an expression parsed as the params of a function will track\n  // the identifiers declared inside the function body.\n  identifiers?: string[]\n}\n\nexport interface IfNode extends Node {\n  type: NodeTypes.IF\n  branches: IfBranchNode[]\n  codegenNode: IfCodegenNode\n}\n\nexport interface IfBranchNode extends Node {\n  type: NodeTypes.IF_BRANCH\n  condition: ExpressionNode | undefined // else\n  children: TemplateChildNode[]\n}\n\nexport interface ForNode extends Node {\n  type: NodeTypes.FOR\n  source: ExpressionNode\n  valueAlias: ExpressionNode | undefined\n  keyAlias: ExpressionNode | undefined\n  objectIndexAlias: ExpressionNode | undefined\n  children: TemplateChildNode[]\n  codegenNode: ForCodegenNode\n}\n\nexport interface TextCallNode extends Node {\n  type: NodeTypes.TEXT_CALL\n  content: TextNode | InterpolationNode | CompoundExpressionNode\n  codegenNode: CallExpression\n}\n\n// We also include a number of JavaScript AST nodes for code generation.\n// The AST is an intentionally minimal subset just to meet the exact needs of\n// Vue render function generation.\nexport type JSChildNode =\n  | CallExpression\n  | ObjectExpression\n  | ArrayExpression\n  | ExpressionNode\n  | FunctionExpression\n  | ConditionalExpression\n  | SequenceExpression\n  | CacheExpression\n\nexport interface CallExpression extends Node {\n  type: NodeTypes.JS_CALL_EXPRESSION\n  callee: string | symbol\n  arguments: (\n    | string\n    | symbol\n    | JSChildNode\n    | TemplateChildNode\n    | TemplateChildNode[])[]\n}\n\nexport interface ObjectExpression extends Node {\n  type: NodeTypes.JS_OBJECT_EXPRESSION\n  properties: Array<Property>\n}\n\nexport interface Property extends Node {\n  type: NodeTypes.JS_PROPERTY\n  key: ExpressionNode\n  value: JSChildNode\n}\n\nexport interface ArrayExpression extends Node {\n  type: NodeTypes.JS_ARRAY_EXPRESSION\n  elements: Array<string | JSChildNode>\n}\n\nexport interface FunctionExpression extends Node {\n  type: NodeTypes.JS_FUNCTION_EXPRESSION\n  params: ExpressionNode | ExpressionNode[] | undefined\n  returns: TemplateChildNode | TemplateChildNode[] | JSChildNode\n  newline: boolean\n}\n\nexport interface SequenceExpression extends Node {\n  type: NodeTypes.JS_SEQUENCE_EXPRESSION\n  expressions: JSChildNode[]\n}\n\nexport interface ConditionalExpression extends Node {\n  type: NodeTypes.JS_CONDITIONAL_EXPRESSION\n  test: ExpressionNode\n  consequent: JSChildNode\n  alternate: JSChildNode\n}\n\nexport interface CacheExpression extends Node {\n  type: NodeTypes.JS_CACHE_EXPRESSION\n  index: number\n  value: JSChildNode\n}\n\n// Codegen Node Types ----------------------------------------------------------\n\n// createVNode(...)\nexport interface PlainElementCodegenNode extends CallExpression {\n  callee: typeof CREATE_VNODE | typeof CREATE_BLOCK\n  arguments:  // tag, props, children, patchFlag, dynamicProps\n    | [string | symbol]\n    | [string | symbol, PropsExpression]\n    | [string | symbol, 'null' | PropsExpression, TemplateChildNode[]]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | TemplateChildNode[],\n        string\n      ]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | TemplateChildNode[],\n        string,\n        string\n      ]\n}\n\nexport type ElementCodegenNode =\n  | PlainElementCodegenNode\n  | CodegenNodeWithDirective<PlainElementCodegenNode>\n\n// createVNode(...)\nexport interface PlainComponentCodegenNode extends CallExpression {\n  callee: typeof CREATE_VNODE | typeof CREATE_BLOCK\n  arguments:  // Comp, props, slots, patchFlag, dynamicProps\n    | [string | symbol]\n    | [string | symbol, PropsExpression]\n    | [string | symbol, 'null' | PropsExpression, SlotsExpression]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | SlotsExpression,\n        string\n      ]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | SlotsExpression,\n        string,\n        string\n      ]\n}\n\nexport type ComponentCodegenNode =\n  | PlainComponentCodegenNode\n  | CodegenNodeWithDirective<PlainComponentCodegenNode>\n\nexport type SlotsExpression = SlotsObjectExpression | DynamicSlotsExpression\n\n// { foo: () => [...] }\nexport interface SlotsObjectExpression extends ObjectExpression {\n  properties: SlotsObjectProperty[]\n}\n\nexport interface SlotsObjectProperty extends Property {\n  value: SlotFunctionExpression\n}\n\nexport interface SlotFunctionExpression extends FunctionExpression {\n  returns: TemplateChildNode[]\n}\n\n// createSlots({ ... }, [\n//    foo ? () => [] : undefined,\n//    renderList(list, i => () => [i])\n// ])\nexport interface DynamicSlotsExpression extends CallExpression {\n  callee: typeof CREATE_SLOTS\n  arguments: [SlotsObjectExpression, DynamicSlotEntries]\n}\n\nexport interface DynamicSlotEntries extends ArrayExpression {\n  elements: (ConditionalDynamicSlotNode | ListDynamicSlotNode)[]\n}\n\nexport interface ConditionalDynamicSlotNode extends ConditionalExpression {\n  consequent: DynamicSlotNode\n  alternate: DynamicSlotNode | SimpleExpressionNode\n}\n\nexport interface ListDynamicSlotNode extends CallExpression {\n  callee: typeof RENDER_LIST\n  arguments: [ExpressionNode, ListDynamicSlotIterator]\n}\n\nexport interface ListDynamicSlotIterator extends FunctionExpression {\n  returns: DynamicSlotNode\n}\n\nexport interface DynamicSlotNode extends ObjectExpression {\n  properties: [Property, DynamicSlotFnProperty]\n}\n\nexport interface DynamicSlotFnProperty extends Property {\n  value: SlotFunctionExpression\n}\n\n// withDirectives(createVNode(...), [\n//    [_directive_foo, someValue],\n//    [_directive_bar, someValue, \"arg\", { mod: true }]\n// ])\nexport interface CodegenNodeWithDirective<T extends CallExpression>\n  extends CallExpression {\n  callee: typeof WITH_DIRECTIVES\n  arguments: [T, DirectiveArguments]\n}\n\nexport interface DirectiveArguments extends ArrayExpression {\n  elements: DirectiveArgumentNode[]\n}\n\nexport interface DirectiveArgumentNode extends ArrayExpression {\n  elements:  // dir, exp, arg, modifiers\n    | [string]\n    | [string, ExpressionNode]\n    | [string, ExpressionNode, ExpressionNode]\n    | [string, ExpressionNode, ExpressionNode, ObjectExpression]\n}\n\n// renderSlot(...)\nexport interface SlotOutletCodegenNode extends CallExpression {\n  callee: typeof RENDER_SLOT\n  arguments:  // $slots, name, props, fallback\n    | [string, string | ExpressionNode]\n    | [string, string | ExpressionNode, PropsExpression]\n    | [\n        string,\n        string | ExpressionNode,\n        PropsExpression | '{}',\n        TemplateChildNode[]\n      ]\n}\n\nexport type BlockCodegenNode =\n  | ElementCodegenNode\n  | ComponentCodegenNode\n  | SlotOutletCodegenNode\n\nexport interface IfCodegenNode extends SequenceExpression {\n  expressions: [OpenBlockExpression, IfConditionalExpression]\n}\n\nexport interface IfConditionalExpression extends ConditionalExpression {\n  consequent: BlockCodegenNode\n  alternate: BlockCodegenNode | IfConditionalExpression\n}\n\nexport interface ForCodegenNode extends SequenceExpression {\n  expressions: [OpenBlockExpression, ForBlockCodegenNode]\n}\n\nexport interface ForBlockCodegenNode extends CallExpression {\n  callee: typeof CREATE_BLOCK\n  arguments: [typeof FRAGMENT, 'null', ForRenderListExpression, string]\n}\n\nexport interface ForRenderListExpression extends CallExpression {\n  callee: typeof RENDER_LIST\n  arguments: [ExpressionNode, ForIteratorExpression]\n}\n\nexport interface ForIteratorExpression extends FunctionExpression {\n  returns: BlockCodegenNode\n}\n\nexport interface OpenBlockExpression extends CallExpression {\n  callee: typeof OPEN_BLOCK\n  arguments: []\n}\n\n// AST Utilities ---------------------------------------------------------------\n\n// Some expressions, e.g. sequence and conditional expressions, are never\n// associated with template nodes, so their source locations are just a stub.\n// Container types like CompoundExpression also don't need a real location.\nexport const locStub: SourceLocation = {\n  source: '',\n  start: { line: 1, column: 1, offset: 0 },\n  end: { line: 1, column: 1, offset: 0 }\n}\n\nexport function createArrayExpression(\n  elements: ArrayExpression['elements'],\n  loc: SourceLocation = locStub\n): ArrayExpression {\n  return {\n    type: NodeTypes.JS_ARRAY_EXPRESSION,\n    loc,\n    elements\n  }\n}\n\nexport function createObjectExpression(\n  properties: ObjectExpression['properties'],\n  loc: SourceLocation = locStub\n): ObjectExpression {\n  return {\n    type: NodeTypes.JS_OBJECT_EXPRESSION,\n    loc,\n    properties\n  }\n}\n\nexport function createObjectProperty(\n  key: Property['key'] | string,\n  value: Property['value']\n): Property {\n  return {\n    type: NodeTypes.JS_PROPERTY,\n    loc: locStub,\n    key: isString(key) ? createSimpleExpression(key, true) : key,\n    value\n  }\n}\n\nexport function createSimpleExpression(\n  content: SimpleExpressionNode['content'],\n  isStatic: SimpleExpressionNode['isStatic'],\n  loc: SourceLocation = locStub,\n  isConstant: boolean = false\n): SimpleExpressionNode {\n  return {\n    type: NodeTypes.SIMPLE_EXPRESSION,\n    loc,\n    isConstant,\n    content,\n    isStatic\n  }\n}\n\nexport function createInterpolation(\n  content: InterpolationNode['content'] | string,\n  loc: SourceLocation\n): InterpolationNode {\n  return {\n    type: NodeTypes.INTERPOLATION,\n    loc,\n    content: isString(content)\n      ? createSimpleExpression(content, false, loc)\n      : content\n  }\n}\n\nexport function createCompoundExpression(\n  children: CompoundExpressionNode['children'],\n  loc: SourceLocation = locStub\n): CompoundExpressionNode {\n  return {\n    type: NodeTypes.COMPOUND_EXPRESSION,\n    loc,\n    children\n  }\n}\n\ntype InferCodegenNodeType<T> = T extends\n  | typeof CREATE_VNODE\n  | typeof CREATE_BLOCK\n  ? PlainElementCodegenNode | PlainComponentCodegenNode\n  : T extends typeof WITH_DIRECTIVES\n    ?\n        | CodegenNodeWithDirective<PlainElementCodegenNode>\n        | CodegenNodeWithDirective<PlainComponentCodegenNode>\n    : T extends typeof RENDER_SLOT ? SlotOutletCodegenNode : CallExpression\n\nexport function createCallExpression<T extends CallExpression['callee']>(\n  callee: T,\n  args: CallExpression['arguments'] = [],\n  loc: SourceLocation = locStub\n): InferCodegenNodeType<T> {\n  return {\n    type: NodeTypes.JS_CALL_EXPRESSION,\n    loc,\n    callee,\n    arguments: args\n  } as any\n}\n\nexport function createFunctionExpression(\n  params: FunctionExpression['params'],\n  returns: FunctionExpression['returns'],\n  newline: boolean = false,\n  loc: SourceLocation = locStub\n): FunctionExpression {\n  return {\n    type: NodeTypes.JS_FUNCTION_EXPRESSION,\n    params,\n    returns,\n    newline,\n    loc\n  }\n}\n\nexport function createSequenceExpression(\n  expressions: SequenceExpression['expressions']\n): SequenceExpression {\n  return {\n    type: NodeTypes.JS_SEQUENCE_EXPRESSION,\n    expressions,\n    loc: locStub\n  }\n}\n\nexport function createConditionalExpression(\n  test: ConditionalExpression['test'],\n  consequent: ConditionalExpression['consequent'],\n  alternate: ConditionalExpression['alternate']\n): ConditionalExpression {\n  return {\n    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n    test,\n    consequent,\n    alternate,\n    loc: locStub\n  }\n}\n\nexport function createCacheExpression(\n  index: number,\n  value: JSChildNode\n): CacheExpression {\n  return {\n    type: NodeTypes.JS_CACHE_EXPRESSION,\n    index,\n    value,\n    loc: locStub\n  }\n}\n","export const FRAGMENT = Symbol(__DEV__ ? `Fragment` : ``)\nexport const PORTAL = Symbol(__DEV__ ? `Portal` : ``)\nexport const COMMENT = Symbol(__DEV__ ? `Comment` : ``)\nexport const TEXT = Symbol(__DEV__ ? `Text` : ``)\nexport const SUSPENSE = Symbol(__DEV__ ? `Suspense` : ``)\nexport const OPEN_BLOCK = Symbol(__DEV__ ? `openBlock` : ``)\nexport const CREATE_BLOCK = Symbol(__DEV__ ? `createBlock` : ``)\nexport const CREATE_VNODE = Symbol(__DEV__ ? `createVNode` : ``)\nexport const RESOLVE_COMPONENT = Symbol(__DEV__ ? `resolveComponent` : ``)\nexport const RESOLVE_DYNAMIC_COMPONENT = Symbol(\n  __DEV__ ? `resolveDynamicComponent` : ``\n)\nexport const RESOLVE_DIRECTIVE = Symbol(__DEV__ ? `resolveDirective` : ``)\nexport const WITH_DIRECTIVES = Symbol(__DEV__ ? `withDirectives` : ``)\nexport const RENDER_LIST = Symbol(__DEV__ ? `renderList` : ``)\nexport const RENDER_SLOT = Symbol(__DEV__ ? `renderSlot` : ``)\nexport const CREATE_SLOTS = Symbol(__DEV__ ? `createSlots` : ``)\nexport const TO_STRING = Symbol(__DEV__ ? `toString` : ``)\nexport const MERGE_PROPS = Symbol(__DEV__ ? `mergeProps` : ``)\nexport const TO_HANDLERS = Symbol(__DEV__ ? `toHandlers` : ``)\nexport const CAMELIZE = Symbol(__DEV__ ? `camelize` : ``)\n\n// Name mapping for runtime helpers that need to be imported from 'vue' in\n// generated code. Make sure these are correctly exported in the runtime!\n// Using `any` here because TS doesn't allow symbols as index type.\nexport const helperNameMap: any = {\n  [FRAGMENT]: `Fragment`,\n  [PORTAL]: `Portal`,\n  [COMMENT]: `Comment`,\n  [TEXT]: `Text`,\n  [SUSPENSE]: `Suspense`,\n  [OPEN_BLOCK]: `openBlock`,\n  [CREATE_BLOCK]: `createBlock`,\n  [CREATE_VNODE]: `createVNode`,\n  [RESOLVE_COMPONENT]: `resolveComponent`,\n  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\n  [RESOLVE_DIRECTIVE]: `resolveDirective`,\n  [WITH_DIRECTIVES]: `withDirectives`,\n  [RENDER_LIST]: `renderList`,\n  [RENDER_SLOT]: `renderSlot`,\n  [CREATE_SLOTS]: `createSlots`,\n  [TO_STRING]: `toString`,\n  [MERGE_PROPS]: `mergeProps`,\n  [TO_HANDLERS]: `toHandlers`,\n  [CAMELIZE]: `camelize`\n}\n\nexport function registerRuntimeHelpers(helpers: any) {\n  Object.getOwnPropertySymbols(helpers).forEach(s => {\n    helperNameMap[s] = helpers[s]\n  })\n}\n","import {\n  SourceLocation,\n  Position,\n  ElementNode,\n  NodeTypes,\n  CallExpression,\n  SequenceExpression,\n  createSequenceExpression,\n  createCallExpression,\n  DirectiveNode,\n  ElementTypes,\n  TemplateChildNode,\n  RootNode,\n  ObjectExpression,\n  Property,\n  JSChildNode,\n  createObjectExpression,\n  SlotOutletNode,\n  TemplateNode,\n  BlockCodegenNode,\n  ElementCodegenNode,\n  SlotOutletCodegenNode,\n  ComponentCodegenNode,\n  ExpressionNode,\n  IfBranchNode\n} from './ast'\nimport { parse } from 'acorn'\nimport { walk } from 'estree-walker'\nimport { TransformContext } from './transform'\nimport { OPEN_BLOCK, MERGE_PROPS, RENDER_SLOT } from './runtimeHelpers'\nimport { isString, isFunction, isObject } from '@vue/shared'\n\n// cache node requires\n// lazy require dependencies so that they don't end up in rollup's dep graph\n// and thus can be tree-shaken in browser builds.\nlet _parse: typeof parse\nlet _walk: typeof walk\n\nexport function loadDep(name: string) {\n  if (typeof process !== 'undefined' && isFunction(require)) {\n    return require(name)\n  } else {\n    // This is only used when we are building a dev-only build of the compiler\n    // which runs in the browser but also uses Node deps.\n    return (window as any)._deps[name]\n  }\n}\n\nexport const parseJS: typeof parse = (code, options) => {\n  assert(\n    !__BROWSER__,\n    `Expression AST analysis can only be performed in non-browser builds.`\n  )\n  const parse = _parse || (_parse = loadDep('acorn').parse)\n  return parse(code, options)\n}\n\nexport const walkJS: typeof walk = (ast, walker) => {\n  assert(\n    !__BROWSER__,\n    `Expression AST analysis can only be performed in non-browser builds.`\n  )\n  const walk = _walk || (_walk = loadDep('estree-walker').walk)\n  return walk(ast, walker)\n}\n\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/\nexport const isSimpleIdentifier = (name: string): boolean =>\n  !nonIdentifierRE.test(name)\n\nconst memberExpRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\[[^\\]]+\\])*$/\nexport const isMemberExpression = (path: string): boolean =>\n  memberExpRE.test(path)\n\nexport function getInnerRange(\n  loc: SourceLocation,\n  offset: number,\n  length?: number\n): SourceLocation {\n  __DEV__ && assert(offset <= loc.source.length)\n  const source = loc.source.substr(offset, length)\n  const newLoc: SourceLocation = {\n    source,\n    start: advancePositionWithClone(loc.start, loc.source, offset),\n    end: loc.end\n  }\n\n  if (length != null) {\n    __DEV__ && assert(offset + length <= loc.source.length)\n    newLoc.end = advancePositionWithClone(\n      loc.start,\n      loc.source,\n      offset + length\n    )\n  }\n\n  return newLoc\n}\n\nexport function advancePositionWithClone(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number = source.length\n): Position {\n  return advancePositionWithMutation({ ...pos }, source, numberOfCharacters)\n}\n\n// advance by mutation without cloning (for performance reasons), since this\n// gets called a lot in the parser\nexport function advancePositionWithMutation(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number = source.length\n): Position {\n  let linesCount = 0\n  let lastNewLinePos = -1\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10 /* newline char code */) {\n      linesCount++\n      lastNewLinePos = i\n    }\n  }\n\n  pos.offset += numberOfCharacters\n  pos.line += linesCount\n  pos.column =\n    lastNewLinePos === -1\n      ? pos.column + numberOfCharacters\n      : Math.max(1, numberOfCharacters - lastNewLinePos)\n\n  return pos\n}\n\nexport function assert(condition: boolean, msg?: string) {\n  /* istanbul ignore if */\n  if (!condition) {\n    throw new Error(msg || `unexpected compiler condition`)\n  }\n}\n\nexport function findDir(\n  node: ElementNode,\n  name: string | RegExp,\n  allowEmpty: boolean = false\n): DirectiveNode | undefined {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (\n      p.type === NodeTypes.DIRECTIVE &&\n      (allowEmpty || p.exp) &&\n      (isString(name) ? p.name === name : name.test(p.name))\n    ) {\n      return p\n    }\n  }\n}\n\nexport function findProp(\n  node: ElementNode,\n  name: string,\n  dynamicOnly: boolean = false\n): ElementNode['props'][0] | undefined {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (p.type === NodeTypes.ATTRIBUTE) {\n      if (dynamicOnly) continue\n      if (p.name === name && p.value && !p.value.isEmpty) {\n        return p\n      }\n    } else if (\n      p.name === 'bind' &&\n      p.arg &&\n      p.arg.type === NodeTypes.SIMPLE_EXPRESSION &&\n      p.arg.isStatic &&\n      p.arg.content === name &&\n      p.exp\n    ) {\n      return p\n    }\n  }\n}\n\nexport function createBlockExpression(\n  blockExp: BlockCodegenNode,\n  context: TransformContext\n): SequenceExpression {\n  return createSequenceExpression([\n    createCallExpression(context.helper(OPEN_BLOCK)),\n    blockExp\n  ])\n}\n\nexport const isVSlot = (p: ElementNode['props'][0]): p is DirectiveNode =>\n  p.type === NodeTypes.DIRECTIVE && p.name === 'slot'\n\nexport const isTemplateNode = (\n  node: RootNode | TemplateChildNode\n): node is TemplateNode =>\n  node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.TEMPLATE\n\nexport const isSlotOutlet = (\n  node: RootNode | TemplateChildNode\n): node is SlotOutletNode =>\n  node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.SLOT\n\nexport function injectProp(\n  node: ElementCodegenNode | ComponentCodegenNode | SlotOutletCodegenNode,\n  prop: Property,\n  context: TransformContext\n) {\n  let propsWithInjection: ObjectExpression | CallExpression\n  const props =\n    node.callee === RENDER_SLOT ? node.arguments[2] : node.arguments[1]\n  if (props == null || isString(props)) {\n    propsWithInjection = createObjectExpression([prop])\n  } else if (props.type === NodeTypes.JS_CALL_EXPRESSION) {\n    // merged props... add ours\n    // only inject key to object literal if it's the first argument so that\n    // if doesn't override user provided keys\n    const first = props.arguments[0] as string | JSChildNode\n    if (!isString(first) && first.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n      first.properties.unshift(prop)\n    } else {\n      props.arguments.unshift(createObjectExpression([prop]))\n    }\n    propsWithInjection = props\n  } else if (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n    props.properties.unshift(prop)\n    propsWithInjection = props\n  } else {\n    // single v-bind with expression, return a merged replacement\n    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n      createObjectExpression([prop]),\n      props\n    ])\n  }\n  if (node.callee === RENDER_SLOT) {\n    node.arguments[2] = propsWithInjection\n  } else {\n    node.arguments[1] = propsWithInjection\n  }\n}\n\nexport function toValidAssetId(\n  name: string,\n  type: 'component' | 'directive'\n): string {\n  return `_${type}_${name.replace(/[^\\w]/g, '_')}`\n}\n\nexport function isEmptyExpression(node: ExpressionNode) {\n  return node.type === NodeTypes.SIMPLE_EXPRESSION && !node.content.trim()\n}\n\n// Check if a node contains expressions that reference current context scope ids\nexport function hasScopeRef(\n  node: TemplateChildNode | IfBranchNode | ExpressionNode | undefined,\n  ids: TransformContext['identifiers']\n): boolean {\n  if (!node || Object.keys(ids).length === 0) {\n    return false\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n      for (let i = 0; i < node.props.length; i++) {\n        const p = node.props[i]\n        if (\n          p.type === NodeTypes.DIRECTIVE &&\n          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))\n        ) {\n          return true\n        }\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.FOR:\n      if (hasScopeRef(node.source, ids)) {\n        return true\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.IF:\n      return node.branches.some(b => hasScopeRef(b, ids))\n    case NodeTypes.IF_BRANCH:\n      if (hasScopeRef(node.condition, ids)) {\n        return true\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.SIMPLE_EXPRESSION:\n      return (\n        !node.isStatic &&\n        isSimpleIdentifier(node.content) &&\n        !!ids[node.content]\n      )\n    case NodeTypes.COMPOUND_EXPRESSION:\n      return node.children.some(c => isObject(c) && hasScopeRef(c, ids))\n    case NodeTypes.INTERPOLATION:\n    case NodeTypes.TEXT_CALL:\n      return hasScopeRef(node.content, ids)\n    case NodeTypes.TEXT:\n    case NodeTypes.COMMENT:\n      return false\n    default:\n      if (__DEV__) {\n        const exhaustiveCheck: never = node\n        exhaustiveCheck\n      }\n      return false\n  }\n}\n","import { NO } from '@vue/shared'\nimport {\n  ErrorCodes,\n  createCompilerError,\n  defaultOnError,\n  CompilerError\n} from './errors'\nimport {\n  assert,\n  advancePositionWithMutation,\n  advancePositionWithClone\n} from './utils'\nimport {\n  Namespace,\n  Namespaces,\n  AttributeNode,\n  CommentNode,\n  DirectiveNode,\n  ElementNode,\n  ElementTypes,\n  ExpressionNode,\n  NodeTypes,\n  Position,\n  RootNode,\n  SourceLocation,\n  TextNode,\n  TemplateChildNode,\n  InterpolationNode\n} from './ast'\nimport { extend } from '@vue/shared'\n\nexport interface ParserOptions {\n  isVoidTag?: (tag: string) => boolean // e.g. img, br, hr\n  isNativeTag?: (tag: string) => boolean // e.g. loading-indicator in weex\n  isCustomElement?: (tag: string) => boolean\n  getNamespace?: (tag: string, parent: ElementNode | undefined) => Namespace\n  getTextMode?: (tag: string, ns: Namespace) => TextModes\n  delimiters?: [string, string] // ['{{', '}}']\n  ignoreSpaces?: boolean\n\n  // Map to HTML entities. E.g., `{ \"amp;\": \"&\" }`\n  // The full set is https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references\n  namedCharacterReferences?: { [name: string]: string | undefined }\n\n  onError?: (error: CompilerError) => void\n}\n\n// `isNativeTag` is optional, others are required\ntype MergedParserOptions = Omit<Required<ParserOptions>, 'isNativeTag'> &\n  Pick<ParserOptions, 'isNativeTag'>\n\nexport const defaultParserOptions: MergedParserOptions = {\n  delimiters: [`{{`, `}}`],\n  ignoreSpaces: true,\n  getNamespace: () => Namespaces.HTML,\n  getTextMode: () => TextModes.DATA,\n  isVoidTag: NO,\n  isCustomElement: NO,\n  namedCharacterReferences: {\n    'gt;': '>',\n    'lt;': '<',\n    'amp;': '&',\n    'apos;': \"'\",\n    'quot;': '\"'\n  },\n  onError: defaultOnError\n}\n\nexport const enum TextModes {\n  //          | Elements | Entities | End sign              | Inside of\n  DATA, //    | ✔       | ✔       | End tags of ancestors |\n  RCDATA, //  | ✘       | ✔       | End tag of the parent | <textarea>\n  RAWTEXT, // | ✘       | ✘       | End tag of the parent | <style>,<script>\n  CDATA,\n  ATTRIBUTE_VALUE\n}\n\ninterface ParserContext {\n  options: MergedParserOptions\n  readonly originalSource: string\n  source: string\n  offset: number\n  line: number\n  column: number\n  maxCRNameLength: number\n  inPre: boolean\n}\n\nexport function parse(content: string, options: ParserOptions = {}): RootNode {\n  const context = createParserContext(content, options)\n  const start = getCursor(context)\n\n  return {\n    type: NodeTypes.ROOT,\n    children: parseChildren(context, TextModes.DATA, []),\n    helpers: [],\n    components: [],\n    directives: [],\n    hoists: [],\n    cached: 0,\n    codegenNode: undefined,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction createParserContext(\n  content: string,\n  options: ParserOptions\n): ParserContext {\n  return {\n    options: {\n      ...defaultParserOptions,\n      ...options\n    },\n    column: 1,\n    line: 1,\n    offset: 0,\n    originalSource: content,\n    source: content,\n    maxCRNameLength: Object.keys(\n      options.namedCharacterReferences ||\n        defaultParserOptions.namedCharacterReferences\n    ).reduce((max, name) => Math.max(max, name.length), 0),\n    inPre: false\n  }\n}\n\nfunction parseChildren(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  const parent = last(ancestors)\n  const ns = parent ? parent.ns : Namespaces.HTML\n  const nodes: TemplateChildNode[] = []\n\n  while (!isEnd(context, mode, ancestors)) {\n    __DEV__ && assert(context.source.length > 0)\n    const s = context.source\n    let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined\n\n    if (!context.inPre && startsWith(s, context.options.delimiters[0])) {\n      // '{{'\n      node = parseInterpolation(context, mode)\n    } else if (mode === TextModes.DATA && s[0] === '<') {\n      // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\n      if (s.length === 1) {\n        emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)\n      } else if (s[1] === '!') {\n        // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\n        if (startsWith(s, '<!--')) {\n          node = parseComment(context)\n        } else if (startsWith(s, '<!DOCTYPE')) {\n          // Ignore DOCTYPE by a limitation.\n          node = parseBogusComment(context)\n        } else if (startsWith(s, '<![CDATA[')) {\n          if (ns !== Namespaces.HTML) {\n            node = parseCDATA(context, ancestors)\n          } else {\n            emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)\n            node = parseBogusComment(context)\n          }\n        } else {\n          emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)\n          node = parseBogusComment(context)\n        }\n      } else if (s[1] === '/') {\n        // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\n        if (s.length === 2) {\n          emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)\n        } else if (s[2] === '>') {\n          emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)\n          advanceBy(context, 3)\n          continue\n        } else if (/[a-z]/i.test(s[2])) {\n          emitError(context, ErrorCodes.X_INVALID_END_TAG)\n          parseTag(context, TagType.End, parent)\n          continue\n        } else {\n          emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 2)\n          node = parseBogusComment(context)\n        }\n      } else if (/[a-z]/i.test(s[1])) {\n        node = parseElement(context, ancestors)\n      } else if (s[1] === '?') {\n        emitError(\n          context,\n          ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\n          1\n        )\n        node = parseBogusComment(context)\n      } else {\n        emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)\n      }\n    }\n    if (!node) {\n      node = parseText(context, mode)\n    }\n\n    if (Array.isArray(node)) {\n      for (let i = 0; i < node.length; i++) {\n        pushNode(context, nodes, node[i])\n      }\n    } else {\n      pushNode(context, nodes, node)\n    }\n  }\n\n  return nodes\n}\n\nfunction pushNode(\n  context: ParserContext,\n  nodes: TemplateChildNode[],\n  node: TemplateChildNode\n): void {\n  // ignore comments in production\n  /* istanbul ignore next */\n  if (!__DEV__ && node.type === NodeTypes.COMMENT) {\n    return\n  }\n  if (\n    context.options.ignoreSpaces &&\n    node.type === NodeTypes.TEXT &&\n    node.isEmpty\n  ) {\n    return\n  }\n\n  // Merge if both this and the previous node are text and those are consecutive.\n  // This happens on \"a < b\" or something like.\n  const prev = last(nodes)\n  if (\n    prev &&\n    prev.type === NodeTypes.TEXT &&\n    node.type === NodeTypes.TEXT &&\n    prev.loc.end.offset === node.loc.start.offset\n  ) {\n    prev.content += node.content\n    prev.isEmpty = prev.content.trim().length === 0\n    prev.loc.end = node.loc.end\n    prev.loc.source += node.loc.source\n  } else {\n    nodes.push(node)\n  }\n}\n\nfunction parseCDATA(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  __DEV__ &&\n    assert(last(ancestors) == null || last(ancestors)!.ns !== Namespaces.HTML)\n  __DEV__ && assert(startsWith(context.source, '<![CDATA['))\n\n  advanceBy(context, 9)\n  const nodes = parseChildren(context, TextModes.CDATA, ancestors)\n  if (context.source.length === 0) {\n    emitError(context, ErrorCodes.EOF_IN_CDATA)\n  } else {\n    __DEV__ && assert(startsWith(context.source, ']]>'))\n    advanceBy(context, 3)\n  }\n\n  return nodes\n}\n\nfunction parseComment(context: ParserContext): CommentNode {\n  __DEV__ && assert(startsWith(context.source, '<!--'))\n\n  const start = getCursor(context)\n  let content: string\n\n  // Regular comment.\n  const match = /--(\\!)?>/.exec(context.source)\n  if (!match) {\n    content = context.source.slice(4)\n    advanceBy(context, context.source.length)\n    emitError(context, ErrorCodes.EOF_IN_COMMENT)\n  } else {\n    if (match.index <= 3) {\n      emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)\n    }\n    if (match[1]) {\n      emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)\n    }\n    content = context.source.slice(4, match.index)\n\n    // Advancing with reporting nested comments.\n    const s = context.source.slice(0, match.index)\n    let prevIndex = 1,\n      nestedIndex = 0\n    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\n      advanceBy(context, nestedIndex - prevIndex + 1)\n      if (nestedIndex + 4 < s.length) {\n        emitError(context, ErrorCodes.NESTED_COMMENT)\n      }\n      prevIndex = nestedIndex + 1\n    }\n    advanceBy(context, match.index + match[0].length - prevIndex + 1)\n  }\n\n  return {\n    type: NodeTypes.COMMENT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseBogusComment(context: ParserContext): CommentNode | undefined {\n  __DEV__ && assert(/^<(?:[\\!\\?]|\\/[^a-z>])/i.test(context.source))\n\n  const start = getCursor(context)\n  const contentStart = context.source[1] === '?' ? 1 : 2\n  let content: string\n\n  const closeIndex = context.source.indexOf('>')\n  if (closeIndex === -1) {\n    content = context.source.slice(contentStart)\n    advanceBy(context, context.source.length)\n  } else {\n    content = context.source.slice(contentStart, closeIndex)\n    advanceBy(context, closeIndex + 1)\n  }\n\n  return {\n    type: NodeTypes.COMMENT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseElement(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): ElementNode | undefined {\n  __DEV__ && assert(/^<[a-z]/i.test(context.source))\n\n  // Start tag.\n  const wasInPre = context.inPre\n  const parent = last(ancestors)\n  const element = parseTag(context, TagType.Start, parent)\n  const isPreBoundary = context.inPre && !wasInPre\n\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n    return element\n  }\n\n  // Children.\n  ancestors.push(element)\n  const mode = context.options.getTextMode(element.tag, element.ns)\n  const children = parseChildren(context, mode, ancestors)\n  ancestors.pop()\n\n  element.children = children\n\n  // End tag.\n  if (startsWithEndTagOpen(context.source, element.tag)) {\n    parseTag(context, TagType.End, parent)\n  } else {\n    emitError(context, ErrorCodes.X_MISSING_END_TAG)\n    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\n      const first = children[0]\n      if (first && startsWith(first.loc.source, '<!--')) {\n        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)\n      }\n    }\n  }\n\n  element.loc = getSelection(context, element.loc.start)\n\n  if (isPreBoundary) {\n    context.inPre = false\n  }\n  return element\n}\n\nconst enum TagType {\n  Start,\n  End\n}\n\n/**\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\n */\nfunction parseTag(\n  context: ParserContext,\n  type: TagType,\n  parent: ElementNode | undefined\n): ElementNode {\n  __DEV__ && assert(/^<\\/?[a-z]/i.test(context.source))\n  __DEV__ &&\n    assert(\n      type === (startsWith(context.source, '</') ? TagType.End : TagType.Start)\n    )\n\n  // Tag open.\n  const start = getCursor(context)\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source)!\n  const tag = match[1]\n  const ns = context.options.getNamespace(tag, parent)\n\n  advanceBy(context, match[0].length)\n  advanceSpaces(context)\n\n  // save current state in case we need to re-parse attributes with v-pre\n  const cursor = getCursor(context)\n  const currentSource = context.source\n\n  // Attributes.\n  let props = parseAttributes(context, type)\n\n  // check v-pre\n  if (\n    !context.inPre &&\n    props.some(p => p.type === NodeTypes.DIRECTIVE && p.name === 'pre')\n  ) {\n    context.inPre = true\n    // reset context\n    extend(context, cursor)\n    context.source = currentSource\n    // re-parse attrs and filter out v-pre itself\n    props = parseAttributes(context, type).filter(p => p.name !== 'v-pre')\n  }\n\n  // Tag close.\n  let isSelfClosing = false\n  if (context.source.length === 0) {\n    emitError(context, ErrorCodes.EOF_IN_TAG)\n  } else {\n    isSelfClosing = startsWith(context.source, '/>')\n    if (type === TagType.End && isSelfClosing) {\n      emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)\n    }\n    advanceBy(context, isSelfClosing ? 2 : 1)\n  }\n\n  let tagType = ElementTypes.ELEMENT\n  if (!context.inPre && !context.options.isCustomElement(tag)) {\n    if (context.options.isNativeTag) {\n      if (!context.options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT\n    } else {\n      if (/^[A-Z]/.test(tag)) tagType = ElementTypes.COMPONENT\n    }\n\n    if (tag === 'slot') tagType = ElementTypes.SLOT\n    else if (tag === 'template') tagType = ElementTypes.TEMPLATE\n    else if (tag === 'portal' || tag === 'Portal') tagType = ElementTypes.PORTAL\n    else if (tag === 'suspense' || tag === 'Suspense')\n      tagType = ElementTypes.SUSPENSE\n  }\n\n  return {\n    type: NodeTypes.ELEMENT,\n    ns,\n    tag,\n    tagType,\n    props,\n    isSelfClosing,\n    children: [],\n    loc: getSelection(context, start),\n    codegenNode: undefined // to be created during transform phase\n  }\n}\n\nfunction parseAttributes(\n  context: ParserContext,\n  type: TagType\n): (AttributeNode | DirectiveNode)[] {\n  const props = []\n  const attributeNames = new Set<string>()\n  while (\n    context.source.length > 0 &&\n    !startsWith(context.source, '>') &&\n    !startsWith(context.source, '/>')\n  ) {\n    if (startsWith(context.source, '/')) {\n      emitError(context, ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG)\n      advanceBy(context, 1)\n      advanceSpaces(context)\n      continue\n    }\n    if (type === TagType.End) {\n      emitError(context, ErrorCodes.END_TAG_WITH_ATTRIBUTES)\n    }\n\n    const attr = parseAttribute(context, attributeNames)\n    if (type === TagType.Start) {\n      props.push(attr)\n    }\n\n    if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\n      emitError(context, ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES)\n    }\n    advanceSpaces(context)\n  }\n  return props\n}\n\nfunction parseAttribute(\n  context: ParserContext,\n  nameSet: Set<string>\n): AttributeNode | DirectiveNode {\n  __DEV__ && assert(/^[^\\t\\r\\n\\f />]/.test(context.source))\n\n  // Name.\n  const start = getCursor(context)\n  const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source)!\n  const name = match[0]\n\n  if (nameSet.has(name)) {\n    emitError(context, ErrorCodes.DUPLICATE_ATTRIBUTE)\n  }\n  nameSet.add(name)\n\n  if (name[0] === '=') {\n    emitError(context, ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME)\n  }\n  {\n    const pattern = /[\"'<]/g\n    let m: RegExpExecArray | null\n    while ((m = pattern.exec(name)) !== null) {\n      emitError(\n        context,\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\n        m.index\n      )\n    }\n  }\n\n  advanceBy(context, name.length)\n\n  // Value\n  let value:\n    | {\n        content: string\n        isQuoted: boolean\n        loc: SourceLocation\n      }\n    | undefined = undefined\n\n  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\n    advanceSpaces(context)\n    advanceBy(context, 1)\n    advanceSpaces(context)\n    value = parseAttributeValue(context)\n    if (!value) {\n      emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE)\n    }\n  }\n  const loc = getSelection(context, start)\n\n  if (!context.inPre && /^(v-|:|@|#)/.test(name)) {\n    const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec(\n      name\n    )!\n\n    let arg: ExpressionNode | undefined\n\n    if (match[2]) {\n      const startOffset = name.split(match[2], 2)!.shift()!.length\n      const loc = getSelection(\n        context,\n        getNewPosition(context, start, startOffset),\n        getNewPosition(context, start, startOffset + match[2].length)\n      )\n      let content = match[2]\n      let isStatic = true\n\n      if (content.startsWith('[')) {\n        isStatic = false\n\n        if (!content.endsWith(']')) {\n          emitError(\n            context,\n            ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END\n          )\n        }\n\n        content = content.substr(1, content.length - 2)\n      }\n\n      arg = {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content,\n        isStatic,\n        isConstant: isStatic,\n        loc\n      }\n    }\n\n    if (value && value.isQuoted) {\n      const valueLoc = value.loc\n      valueLoc.start.offset++\n      valueLoc.start.column++\n      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)\n      valueLoc.source = valueLoc.source.slice(1, -1)\n    }\n\n    return {\n      type: NodeTypes.DIRECTIVE,\n      name:\n        match[1] ||\n        (startsWith(name, ':')\n          ? 'bind'\n          : startsWith(name, '@')\n            ? 'on'\n            : 'slot'),\n      exp: value && {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: value.content,\n        isStatic: false,\n        // Treat as non-constant by default. This can be potentially set to\n        // true by `transformExpression` to make it eligible for hoisting.\n        isConstant: false,\n        loc: value.loc\n      },\n      arg,\n      modifiers: match[3] ? match[3].substr(1).split('.') : [],\n      loc\n    }\n  }\n\n  return {\n    type: NodeTypes.ATTRIBUTE,\n    name,\n    value: value && {\n      type: NodeTypes.TEXT,\n      content: value.content,\n      isEmpty: value.content.trim().length === 0,\n      loc: value.loc\n    },\n    loc\n  }\n}\n\nfunction parseAttributeValue(\n  context: ParserContext\n):\n  | {\n      content: string\n      isQuoted: boolean\n      loc: SourceLocation\n    }\n  | undefined {\n  const start = getCursor(context)\n  let content: string\n\n  const quote = context.source[0]\n  const isQuoted = quote === `\"` || quote === `'`\n  if (isQuoted) {\n    // Quoted value.\n    advanceBy(context, 1)\n\n    const endIndex = context.source.indexOf(quote)\n    if (endIndex === -1) {\n      content = parseTextData(\n        context,\n        context.source.length,\n        TextModes.ATTRIBUTE_VALUE\n      )\n    } else {\n      content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)\n      advanceBy(context, 1)\n    }\n  } else {\n    // Unquoted\n    const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source)\n    if (!match) {\n      return undefined\n    }\n    let unexpectedChars = /[\"'<=`]/g\n    let m: RegExpExecArray | null\n    while ((m = unexpectedChars.exec(match[0])) !== null) {\n      emitError(\n        context,\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\n        m.index\n      )\n    }\n    content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)\n  }\n\n  return { content, isQuoted, loc: getSelection(context, start) }\n}\n\nfunction parseInterpolation(\n  context: ParserContext,\n  mode: TextModes\n): InterpolationNode | undefined {\n  const [open, close] = context.options.delimiters\n  __DEV__ && assert(startsWith(context.source, open))\n\n  const closeIndex = context.source.indexOf(close, open.length)\n  if (closeIndex === -1) {\n    emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)\n    return undefined\n  }\n\n  const start = getCursor(context)\n  advanceBy(context, open.length)\n  const innerStart = getCursor(context)\n  const innerEnd = getCursor(context)\n  const rawContentLength = closeIndex - open.length\n  const rawContent = context.source.slice(0, rawContentLength)\n  const preTrimContent = parseTextData(context, rawContentLength, mode)\n  const content = preTrimContent.trim()\n  const startOffset = preTrimContent.indexOf(content)\n  if (startOffset > 0) {\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\n  }\n  const endOffset =\n    rawContentLength - (preTrimContent.length - content.length - startOffset)\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\n  advanceBy(context, close.length)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      isStatic: false,\n      // Set `isConstant` to false by default and will decide in transformExpression\n      isConstant: false,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseText(context: ParserContext, mode: TextModes): TextNode {\n  __DEV__ && assert(context.source.length > 0)\n\n  const [open] = context.options.delimiters\n  const endIndex = Math.min(\n    ...[\n      context.source.indexOf('<', 1),\n      context.source.indexOf(open, 1),\n      mode === TextModes.CDATA ? context.source.indexOf(']]>') : -1,\n      context.source.length\n    ].filter(n => n !== -1)\n  )\n  __DEV__ && assert(endIndex > 0)\n\n  const start = getCursor(context)\n  const content = parseTextData(context, endIndex, mode)\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n    loc: getSelection(context, start),\n    isEmpty: !content.trim()\n  }\n}\n\n/**\n * Get text data with a given length from the current location.\n * This translates HTML entities in the text data.\n */\nfunction parseTextData(\n  context: ParserContext,\n  length: number,\n  mode: TextModes\n): string {\n  if (mode === TextModes.RAWTEXT || mode === TextModes.CDATA) {\n    const text = context.source.slice(0, length)\n    advanceBy(context, length)\n    return text\n  }\n\n  // DATA or RCDATA. Entity decoding required.\n  const end = context.offset + length\n  let text: string = ''\n\n  while (context.offset < end) {\n    const head = /&(?:#x?)?/i.exec(context.source)\n    if (!head || context.offset + head.index >= end) {\n      const remaining = end - context.offset\n      text += context.source.slice(0, remaining)\n      advanceBy(context, remaining)\n      break\n    }\n\n    // Advance to the \"&\".\n    text += context.source.slice(0, head.index)\n    advanceBy(context, head.index)\n\n    if (head[0] === '&') {\n      // Named character reference.\n      let name = '',\n        value: string | undefined = undefined\n      if (/[0-9a-z]/i.test(context.source[1])) {\n        for (\n          let length = context.maxCRNameLength;\n          !value && length > 0;\n          --length\n        ) {\n          name = context.source.substr(1, length)\n          value = context.options.namedCharacterReferences[name]\n        }\n        if (value) {\n          const semi = name.endsWith(';')\n          if (\n            mode === TextModes.ATTRIBUTE_VALUE &&\n            !semi &&\n            /[=a-z0-9]/i.test(context.source[1 + name.length] || '')\n          ) {\n            text += '&'\n            text += name\n            advanceBy(context, 1 + name.length)\n          } else {\n            text += value\n            advanceBy(context, 1 + name.length)\n            if (!semi) {\n              emitError(\n                context,\n                ErrorCodes.MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE\n              )\n            }\n          }\n        } else {\n          emitError(context, ErrorCodes.UNKNOWN_NAMED_CHARACTER_REFERENCE)\n          text += '&'\n          text += name\n          advanceBy(context, 1 + name.length)\n        }\n      } else {\n        text += '&'\n        advanceBy(context, 1)\n      }\n    } else {\n      // Numeric character reference.\n      const hex = head[0] === '&#x'\n      const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/\n      const body = pattern.exec(context.source)\n      if (!body) {\n        text += head[0]\n        emitError(\n          context,\n          ErrorCodes.ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE\n        )\n        advanceBy(context, head[0].length)\n      } else {\n        // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\n        let cp = Number.parseInt(body[1], hex ? 16 : 10)\n        if (cp === 0) {\n          emitError(context, ErrorCodes.NULL_CHARACTER_REFERENCE)\n          cp = 0xfffd\n        } else if (cp > 0x10ffff) {\n          emitError(\n            context,\n            ErrorCodes.CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE\n          )\n          cp = 0xfffd\n        } else if (cp >= 0xd800 && cp <= 0xdfff) {\n          emitError(context, ErrorCodes.SURROGATE_CHARACTER_REFERENCE)\n          cp = 0xfffd\n        } else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) {\n          emitError(context, ErrorCodes.NONCHARACTER_CHARACTER_REFERENCE)\n        } else if (\n          (cp >= 0x01 && cp <= 0x08) ||\n          cp === 0x0b ||\n          (cp >= 0x0d && cp <= 0x1f) ||\n          (cp >= 0x7f && cp <= 0x9f)\n        ) {\n          emitError(context, ErrorCodes.CONTROL_CHARACTER_REFERENCE)\n          cp = CCR_REPLACEMENTS[cp] || cp\n        }\n        text += String.fromCodePoint(cp)\n        advanceBy(context, body[0].length)\n        if (!body![0].endsWith(';')) {\n          emitError(\n            context,\n            ErrorCodes.MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE\n          )\n        }\n      }\n    }\n  }\n  return text\n}\n\nfunction getCursor(context: ParserContext): Position {\n  const { column, line, offset } = context\n  return { column, line, offset }\n}\n\nfunction getSelection(\n  context: ParserContext,\n  start: Position,\n  end?: Position\n): SourceLocation {\n  end = end || getCursor(context)\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset)\n  }\n}\n\nfunction last<T>(xs: T[]): T | undefined {\n  return xs[xs.length - 1]\n}\n\nfunction startsWith(source: string, searchString: string): boolean {\n  return source.startsWith(searchString)\n}\n\nfunction advanceBy(context: ParserContext, numberOfCharacters: number): void {\n  const { source } = context\n  __DEV__ && assert(numberOfCharacters <= source.length)\n  advancePositionWithMutation(context, source, numberOfCharacters)\n  context.source = source.slice(numberOfCharacters)\n}\n\nfunction advanceSpaces(context: ParserContext): void {\n  const match = /^[\\t\\r\\n\\f ]+/.exec(context.source)\n  if (match) {\n    advanceBy(context, match[0].length)\n  }\n}\n\nfunction getNewPosition(\n  context: ParserContext,\n  start: Position,\n  numberOfCharacters: number\n): Position {\n  return advancePositionWithClone(\n    start,\n    context.originalSource.slice(start.offset, numberOfCharacters),\n    numberOfCharacters\n  )\n}\n\nfunction emitError(\n  context: ParserContext,\n  code: ErrorCodes,\n  offset?: number\n): void {\n  const loc = getCursor(context)\n  if (offset) {\n    loc.offset += offset\n    loc.column += offset\n  }\n  context.options.onError(\n    createCompilerError(code, {\n      start: loc,\n      end: loc,\n      source: ''\n    })\n  )\n}\n\nfunction isEnd(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): boolean {\n  const s = context.source\n\n  switch (mode) {\n    case TextModes.DATA:\n      if (startsWith(s, '</')) {\n        //TODO: probably bad performance\n        for (let i = ancestors.length - 1; i >= 0; --i) {\n          if (startsWithEndTagOpen(s, ancestors[i].tag)) {\n            return true\n          }\n        }\n      }\n      break\n\n    case TextModes.RCDATA:\n    case TextModes.RAWTEXT: {\n      const parent = last(ancestors)\n      if (parent && startsWithEndTagOpen(s, parent.tag)) {\n        return true\n      }\n      break\n    }\n\n    case TextModes.CDATA:\n      if (startsWith(s, ']]>')) {\n        return true\n      }\n      break\n  }\n\n  return !s\n}\n\nfunction startsWithEndTagOpen(source: string, tag: string): boolean {\n  return (\n    startsWith(source, '</') &&\n    source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&\n    /[\\t\\n\\f />]/.test(source[2 + tag.length] || '>')\n  )\n}\n\n// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\nconst CCR_REPLACEMENTS: { [key: number]: number | undefined } = {\n  0x80: 0x20ac,\n  0x82: 0x201a,\n  0x83: 0x0192,\n  0x84: 0x201e,\n  0x85: 0x2026,\n  0x86: 0x2020,\n  0x87: 0x2021,\n  0x88: 0x02c6,\n  0x89: 0x2030,\n  0x8a: 0x0160,\n  0x8b: 0x2039,\n  0x8c: 0x0152,\n  0x8e: 0x017d,\n  0x91: 0x2018,\n  0x92: 0x2019,\n  0x93: 0x201c,\n  0x94: 0x201d,\n  0x95: 0x2022,\n  0x96: 0x2013,\n  0x97: 0x2014,\n  0x98: 0x02dc,\n  0x99: 0x2122,\n  0x9a: 0x0161,\n  0x9b: 0x203a,\n  0x9c: 0x0153,\n  0x9e: 0x017e,\n  0x9f: 0x0178\n}\n","import {\n  RootNode,\n  NodeTypes,\n  TemplateChildNode,\n  SimpleExpressionNode,\n  ElementTypes,\n  ElementCodegenNode,\n  PlainElementNode,\n  ComponentNode,\n  TemplateNode,\n  ElementNode,\n  PlainElementCodegenNode\n} from '../ast'\nimport { TransformContext } from '../transform'\nimport { WITH_DIRECTIVES } from '../runtimeHelpers'\nimport { PatchFlags, isString, isSymbol } from '@vue/shared'\nimport { isSlotOutlet, findProp } from '../utils'\n\nexport function hoistStatic(root: RootNode, context: TransformContext) {\n  walk(\n    root.children,\n    context,\n    new Map(),\n    isSingleElementRoot(root, root.children[0])\n  )\n}\n\nexport function isSingleElementRoot(\n  root: RootNode,\n  child: TemplateChildNode\n): child is PlainElementNode | ComponentNode | TemplateNode {\n  const { children } = root\n  return (\n    children.length === 1 &&\n    child.type === NodeTypes.ELEMENT &&\n    !isSlotOutlet(child)\n  )\n}\n\nfunction walk(\n  children: TemplateChildNode[],\n  context: TransformContext,\n  resultCache: Map<TemplateChildNode, boolean>,\n  doNotHoistNode: boolean = false\n) {\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    // only plain elements are eligible for hoisting.\n    if (\n      child.type === NodeTypes.ELEMENT &&\n      child.tagType === ElementTypes.ELEMENT\n    ) {\n      if (!doNotHoistNode && isStaticNode(child, resultCache)) {\n        // whole tree is static\n        child.codegenNode = context.hoist(child.codegenNode!)\n        continue\n      } else {\n        // node may contain dynamic children, but its props may be eligible for\n        // hoisting.\n        const flag = getPatchFlag(child)\n        if (\n          (!flag ||\n            flag === PatchFlags.NEED_PATCH ||\n            flag === PatchFlags.TEXT) &&\n          !hasDynamicKeyOrRef(child) &&\n          !hasCachedProps(child)\n        ) {\n          const props = getNodeProps(child)\n          if (props && props !== `null`) {\n            getVNodeCall(child).arguments[1] = context.hoist(props)\n          }\n        }\n      }\n    }\n    if (child.type === NodeTypes.ELEMENT) {\n      walk(child.children, context, resultCache)\n    } else if (child.type === NodeTypes.FOR) {\n      // Do not hoist v-for single child because it has to be a block\n      walk(child.children, context, resultCache, child.children.length === 1)\n    } else if (child.type === NodeTypes.IF) {\n      for (let i = 0; i < child.branches.length; i++) {\n        const branchChildren = child.branches[i].children\n        // Do not hoist v-if single child because it has to be a block\n        walk(branchChildren, context, resultCache, branchChildren.length === 1)\n      }\n    }\n  }\n}\n\nexport function isStaticNode(\n  node: TemplateChildNode | SimpleExpressionNode,\n  resultCache: Map<TemplateChildNode, boolean> = new Map()\n): boolean {\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n      if (node.tagType !== ElementTypes.ELEMENT) {\n        return false\n      }\n      const cached = resultCache.get(node)\n      if (cached !== undefined) {\n        return cached\n      }\n      const flag = getPatchFlag(node)\n      if (!flag && !hasDynamicKeyOrRef(node) && !hasCachedProps(node)) {\n        // element self is static. check its children.\n        for (let i = 0; i < node.children.length; i++) {\n          if (!isStaticNode(node.children[i], resultCache)) {\n            resultCache.set(node, false)\n            return false\n          }\n        }\n        resultCache.set(node, true)\n        return true\n      } else {\n        resultCache.set(node, false)\n        return false\n      }\n    case NodeTypes.TEXT:\n    case NodeTypes.COMMENT:\n      return true\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n      return false\n    case NodeTypes.INTERPOLATION:\n    case NodeTypes.TEXT_CALL:\n      return isStaticNode(node.content, resultCache)\n    case NodeTypes.SIMPLE_EXPRESSION:\n      return node.isConstant\n    case NodeTypes.COMPOUND_EXPRESSION:\n      return node.children.every(child => {\n        return (\n          isString(child) || isSymbol(child) || isStaticNode(child, resultCache)\n        )\n      })\n    default:\n      if (__DEV__) {\n        const exhaustiveCheck: never = node\n        exhaustiveCheck\n      }\n      return false\n  }\n}\n\nfunction hasDynamicKeyOrRef(node: ElementNode): boolean {\n  return !!(findProp(node, 'key', true) || findProp(node, 'ref', true))\n}\n\nfunction hasCachedProps(node: PlainElementNode): boolean {\n  if (__BROWSER__) {\n    return false\n  }\n  const props = getNodeProps(node)\n  if (\n    props &&\n    props !== 'null' &&\n    props.type === NodeTypes.JS_OBJECT_EXPRESSION\n  ) {\n    const { properties } = props\n    for (let i = 0; i < properties.length; i++) {\n      if (properties[i].value.type === NodeTypes.JS_CACHE_EXPRESSION) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction getVNodeCall(node: PlainElementNode) {\n  let codegenNode = node.codegenNode as ElementCodegenNode\n  if (codegenNode.callee === WITH_DIRECTIVES) {\n    codegenNode = codegenNode.arguments[0]\n  }\n  return codegenNode\n}\n\nfunction getVNodeArgAt(\n  node: PlainElementNode,\n  index: number\n): PlainElementCodegenNode['arguments'][number] {\n  return getVNodeCall(node).arguments[index]\n}\n\nfunction getPatchFlag(node: PlainElementNode): number | undefined {\n  const flag = getVNodeArgAt(node, 3) as string\n  return flag ? parseInt(flag, 10) : undefined\n}\n\nfunction getNodeProps(node: PlainElementNode) {\n  return getVNodeArgAt(node, 1) as PlainElementCodegenNode['arguments'][1]\n}\n","import {\n  RootNode,\n  NodeTypes,\n  ParentNode,\n  TemplateChildNode,\n  ElementNode,\n  DirectiveNode,\n  Property,\n  ExpressionNode,\n  createSimpleExpression,\n  JSChildNode,\n  SimpleExpressionNode,\n  ElementTypes,\n  ElementCodegenNode,\n  ComponentCodegenNode,\n  createCallExpression,\n  CacheExpression,\n  createCacheExpression\n} from './ast'\nimport { isString, isArray } from '@vue/shared'\nimport { CompilerError, defaultOnError } from './errors'\nimport {\n  TO_STRING,\n  COMMENT,\n  CREATE_VNODE,\n  FRAGMENT,\n  helperNameMap,\n  WITH_DIRECTIVES,\n  CREATE_BLOCK\n} from './runtimeHelpers'\nimport { isVSlot, createBlockExpression } from './utils'\nimport { hoistStatic, isSingleElementRoot } from './transforms/hoistStatic'\n\n// There are two types of transforms:\n//\n// - NodeTransform:\n//   Transforms that operate directly on a ChildNode. NodeTransforms may mutate,\n//   replace or remove the node being processed.\nexport type NodeTransform = (\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) => void | (() => void) | (() => void)[]\n\n// - DirectiveTransform:\n//   Transforms that handles a single directive attribute on an element.\n//   It translates the raw directive into actual props for the VNode.\nexport type DirectiveTransform = (\n  dir: DirectiveNode,\n  node: ElementNode,\n  context: TransformContext,\n  // a platform specific compiler can import the base transform and augment\n  // it by passing in this optional argument.\n  augmentor?: (ret: DirectiveTransformResult) => DirectiveTransformResult\n) => DirectiveTransformResult\n\nexport interface DirectiveTransformResult {\n  props: Property[]\n  needRuntime: boolean | symbol\n}\n\n// A structural directive transform is a technically a NodeTransform;\n// Only v-if and v-for fall into this category.\nexport type StructuralDirectiveTransform = (\n  node: ElementNode,\n  dir: DirectiveNode,\n  context: TransformContext\n) => void | (() => void)\n\nexport interface TransformOptions {\n  nodeTransforms?: NodeTransform[]\n  directiveTransforms?: { [name: string]: DirectiveTransform }\n  prefixIdentifiers?: boolean\n  hoistStatic?: boolean\n  cacheHandlers?: boolean\n  onError?: (error: CompilerError) => void\n}\n\nexport interface TransformContext extends Required<TransformOptions> {\n  root: RootNode\n  helpers: Set<symbol>\n  components: Set<string>\n  directives: Set<string>\n  hoists: JSChildNode[]\n  cached: number\n  identifiers: { [name: string]: number | undefined }\n  scopes: {\n    vFor: number\n    vSlot: number\n    vPre: number\n    vOnce: number\n  }\n  parent: ParentNode | null\n  childIndex: number\n  currentNode: RootNode | TemplateChildNode | null\n  helper<T extends symbol>(name: T): T\n  helperString(name: symbol): string\n  replaceNode(node: TemplateChildNode): void\n  removeNode(node?: TemplateChildNode): void\n  onNodeRemoved(): void\n  addIdentifiers(exp: ExpressionNode | string): void\n  removeIdentifiers(exp: ExpressionNode | string): void\n  hoist(exp: JSChildNode): SimpleExpressionNode\n  cache<T extends JSChildNode>(exp: T): CacheExpression | T\n}\n\nfunction createTransformContext(\n  root: RootNode,\n  {\n    prefixIdentifiers = false,\n    hoistStatic = false,\n    cacheHandlers = false,\n    nodeTransforms = [],\n    directiveTransforms = {},\n    onError = defaultOnError\n  }: TransformOptions\n): TransformContext {\n  const context: TransformContext = {\n    root,\n    helpers: new Set(),\n    components: new Set(),\n    directives: new Set(),\n    hoists: [],\n    cached: 0,\n    identifiers: {},\n    scopes: {\n      vFor: 0,\n      vSlot: 0,\n      vPre: 0,\n      vOnce: 0\n    },\n    prefixIdentifiers,\n    hoistStatic,\n    cacheHandlers,\n    nodeTransforms,\n    directiveTransforms,\n    onError,\n    parent: null,\n    currentNode: root,\n    childIndex: 0,\n    helper(name) {\n      context.helpers.add(name)\n      return name\n    },\n    helperString(name) {\n      return (\n        (context.prefixIdentifiers ? `` : `_`) +\n        helperNameMap[context.helper(name)]\n      )\n    },\n    replaceNode(node) {\n      /* istanbul ignore if */\n      if (__DEV__) {\n        if (!context.currentNode) {\n          throw new Error(`Node being replaced is already removed.`)\n        }\n        if (!context.parent) {\n          throw new Error(`Cannot replace root node.`)\n        }\n      }\n      context.parent!.children[context.childIndex] = context.currentNode = node\n    },\n    removeNode(node) {\n      if (__DEV__ && !context.parent) {\n        throw new Error(`Cannot remove root node.`)\n      }\n      const list = context.parent!.children\n      const removalIndex = node\n        ? list.indexOf(node)\n        : context.currentNode\n          ? context.childIndex\n          : -1\n      /* istanbul ignore if */\n      if (__DEV__ && removalIndex < 0) {\n        throw new Error(`node being removed is not a child of current parent`)\n      }\n      if (!node || node === context.currentNode) {\n        // current node removed\n        context.currentNode = null\n        context.onNodeRemoved()\n      } else {\n        // sibling node removed\n        if (context.childIndex > removalIndex) {\n          context.childIndex--\n          context.onNodeRemoved()\n        }\n      }\n      context.parent!.children.splice(removalIndex, 1)\n    },\n    onNodeRemoved: () => {},\n    addIdentifiers(exp) {\n      // identifier tracking only happens in non-browser builds.\n      if (!__BROWSER__) {\n        if (isString(exp)) {\n          addId(exp)\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(addId)\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          addId(exp.content)\n        }\n      }\n    },\n    removeIdentifiers(exp) {\n      if (!__BROWSER__) {\n        if (isString(exp)) {\n          removeId(exp)\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(removeId)\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          removeId(exp.content)\n        }\n      }\n    },\n    hoist(exp) {\n      context.hoists.push(exp)\n      return createSimpleExpression(\n        `_hoisted_${context.hoists.length}`,\n        false,\n        exp.loc\n      )\n    },\n    cache(exp) {\n      return cacheHandlers ? createCacheExpression(++context.cached, exp) : exp\n    }\n  }\n\n  function addId(id: string) {\n    const { identifiers } = context\n    if (identifiers[id] === undefined) {\n      identifiers[id] = 0\n    }\n    identifiers[id]!++\n  }\n\n  function removeId(id: string) {\n    context.identifiers[id]!--\n  }\n\n  return context\n}\n\nexport function transform(root: RootNode, options: TransformOptions) {\n  const context = createTransformContext(root, options)\n  traverseNode(root, context)\n  if (options.hoistStatic) {\n    hoistStatic(root, context)\n  }\n  finalizeRoot(root, context)\n}\n\nfunction finalizeRoot(root: RootNode, context: TransformContext) {\n  const { helper } = context\n  const { children } = root\n  const child = children[0]\n  if (children.length === 1) {\n    // if the single child is an element, turn it into a block.\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\n      // single element root is never hoisted so codegenNode will never be\n      // SimpleExpressionNode\n      const codegenNode = child.codegenNode as\n        | ElementCodegenNode\n        | ComponentCodegenNode\n      if (codegenNode.callee === WITH_DIRECTIVES) {\n        codegenNode.arguments[0].callee = helper(CREATE_BLOCK)\n      } else {\n        codegenNode.callee = helper(CREATE_BLOCK)\n      }\n      root.codegenNode = createBlockExpression(codegenNode, context)\n    } else {\n      // - single <slot/>, IfNode, ForNode: already blocks.\n      // - single text node: always patched.\n      // root codegen falls through via genNode()\n      root.codegenNode = child\n    }\n  } else if (children.length > 1) {\n    // root has multiple nodes - return a fragment block.\n    root.codegenNode = createBlockExpression(\n      createCallExpression(helper(CREATE_BLOCK), [\n        helper(FRAGMENT),\n        `null`,\n        root.children\n      ]),\n      context\n    )\n  } else {\n    // no children = noop. codegen will return null.\n  }\n  // finalize meta information\n  root.helpers = [...context.helpers]\n  root.components = [...context.components]\n  root.directives = [...context.directives]\n  root.hoists = context.hoists\n  root.cached = context.cached\n}\n\nexport function traverseChildren(\n  parent: ParentNode,\n  context: TransformContext\n) {\n  let i = 0\n  const nodeRemoved = () => {\n    i--\n  }\n  for (; i < parent.children.length; i++) {\n    const child = parent.children[i]\n    if (isString(child)) continue\n    context.currentNode = child\n    context.parent = parent\n    context.childIndex = i\n    context.onNodeRemoved = nodeRemoved\n    traverseNode(child, context)\n  }\n}\n\nexport function traverseNode(\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) {\n  // apply transform plugins\n  const { nodeTransforms } = context\n  const exitFns = []\n  for (let i = 0; i < nodeTransforms.length; i++) {\n    const onExit = nodeTransforms[i](node, context)\n    if (onExit) {\n      if (isArray(onExit)) {\n        exitFns.push(...onExit)\n      } else {\n        exitFns.push(onExit)\n      }\n    }\n    if (!context.currentNode) {\n      // node was removed\n      return\n    } else {\n      // node may have been replaced\n      node = context.currentNode\n    }\n  }\n\n  switch (node.type) {\n    case NodeTypes.COMMENT:\n      // inject import for the Comment symbol, which is needed for creating\n      // comment nodes with `createVNode`\n      context.helper(CREATE_VNODE)\n      context.helper(COMMENT)\n      break\n    case NodeTypes.INTERPOLATION:\n      // no need to traverse, but we need to inject toString helper\n      context.helper(TO_STRING)\n      break\n\n    // for container types, further traverse downwards\n    case NodeTypes.IF:\n      for (let i = 0; i < node.branches.length; i++) {\n        traverseChildren(node.branches[i], context)\n      }\n      break\n    case NodeTypes.FOR:\n    case NodeTypes.ELEMENT:\n    case NodeTypes.ROOT:\n      traverseChildren(node, context)\n      break\n  }\n\n  // exit transforms\n  let i = exitFns.length\n  while (i--) {\n    exitFns[i]()\n  }\n}\n\nexport function createStructuralDirectiveTransform(\n  name: string | RegExp,\n  fn: StructuralDirectiveTransform\n): NodeTransform {\n  const matches = isString(name)\n    ? (n: string) => n === name\n    : (n: string) => name.test(n)\n\n  return (node, context) => {\n    if (node.type === NodeTypes.ELEMENT) {\n      const { props } = node\n      // structural directive transforms are not concerned with slots\n      // as they are handled separately in vSlot.ts\n      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {\n        return\n      }\n      const exitFns = []\n      for (let i = 0; i < props.length; i++) {\n        const prop = props[i]\n        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {\n          // structural directives are removed to avoid infinite recursion\n          // also we remove them *before* applying so that it can further\n          // traverse itself in case it moves the node around\n          props.splice(i, 1)\n          i--\n          const onExit = fn(node, prop, context)\n          if (onExit) exitFns.push(onExit)\n        }\n      }\n      return exitFns\n    }\n  }\n}\n","import {\n  RootNode,\n  TemplateChildNode,\n  TextNode,\n  CommentNode,\n  ExpressionNode,\n  NodeTypes,\n  JSChildNode,\n  CallExpression,\n  ArrayExpression,\n  ObjectExpression,\n  SourceLocation,\n  Position,\n  InterpolationNode,\n  CompoundExpressionNode,\n  SimpleExpressionNode,\n  FunctionExpression,\n  SequenceExpression,\n  ConditionalExpression,\n  CacheExpression\n} from './ast'\nimport { SourceMapGenerator, RawSourceMap } from 'source-map'\nimport {\n  advancePositionWithMutation,\n  assert,\n  isSimpleIdentifier,\n  loadDep,\n  toValidAssetId\n} from './utils'\nimport { isString, isArray, isSymbol } from '@vue/shared'\nimport {\n  TO_STRING,\n  CREATE_VNODE,\n  COMMENT,\n  helperNameMap,\n  RESOLVE_COMPONENT,\n  RESOLVE_DIRECTIVE\n} from './runtimeHelpers'\n\ntype CodegenNode = TemplateChildNode | JSChildNode\n\nexport interface CodegenOptions {\n  // - Module mode will generate ES module import statements for helpers\n  //   and export the render function as the default export.\n  // - Function mode will generate a single `const { helpers... } = Vue`\n  //   statement and return the render function. It is meant to be used with\n  //   `new Function(code)()` to generate a render function at runtime.\n  // Default: 'function'\n  mode?: 'module' | 'function'\n  // Prefix suitable identifiers with _ctx.\n  // If this option is false, the generated code will be wrapped in a\n  // `with (this) { ... }` block.\n  // Default: false\n  prefixIdentifiers?: boolean\n  // Generate source map?\n  // Default: false\n  sourceMap?: boolean\n  // Filename for source map generation.\n  // Default: `template.vue.html`\n  filename?: string\n}\n\nexport interface CodegenResult {\n  code: string\n  ast: RootNode\n  map?: RawSourceMap\n}\n\nexport interface CodegenContext extends Required<CodegenOptions> {\n  source: string\n  code: string\n  line: number\n  column: number\n  offset: number\n  indentLevel: number\n  map?: SourceMapGenerator\n  helper(key: symbol): string\n  push(code: string, node?: CodegenNode, openOnly?: boolean): void\n  resetMapping(loc: SourceLocation): void\n  indent(): void\n  deindent(withoutNewLine?: boolean): void\n  newline(): void\n}\n\nfunction createCodegenContext(\n  ast: RootNode,\n  {\n    mode = 'function',\n    prefixIdentifiers = mode === 'module',\n    sourceMap = false,\n    filename = `template.vue.html`\n  }: CodegenOptions\n): CodegenContext {\n  const context: CodegenContext = {\n    mode,\n    prefixIdentifiers,\n    sourceMap,\n    filename,\n    source: ast.loc.source,\n    code: ``,\n    column: 1,\n    line: 1,\n    offset: 0,\n    indentLevel: 0,\n\n    // lazy require source-map implementation, only in non-browser builds!\n    map:\n      __BROWSER__ || !sourceMap\n        ? undefined\n        : new (loadDep('source-map')).SourceMapGenerator(),\n\n    helper(key) {\n      const name = helperNameMap[key]\n      return prefixIdentifiers ? name : `_${name}`\n    },\n    push(code, node, openOnly) {\n      context.code += code\n      if (!__BROWSER__ && context.map) {\n        if (node) {\n          let name\n          if (node.type === NodeTypes.SIMPLE_EXPRESSION && !node.isStatic) {\n            const content = node.content.replace(/^_ctx\\./, '')\n            if (content !== node.content && isSimpleIdentifier(content)) {\n              name = content\n            }\n          }\n          addMapping(node.loc.start, name)\n        }\n        advancePositionWithMutation(context, code)\n        if (node && !openOnly) {\n          addMapping(node.loc.end)\n        }\n      }\n    },\n    resetMapping(loc: SourceLocation) {\n      if (!__BROWSER__ && context.map) {\n        addMapping(loc.start)\n      }\n    },\n    indent() {\n      newline(++context.indentLevel)\n    },\n    deindent(withoutNewLine = false) {\n      if (withoutNewLine) {\n        --context.indentLevel\n      } else {\n        newline(--context.indentLevel)\n      }\n    },\n    newline() {\n      newline(context.indentLevel)\n    }\n  }\n\n  function newline(n: number) {\n    context.push('\\n' + `  `.repeat(n))\n  }\n\n  function addMapping(loc: Position, name?: string) {\n    context.map!.addMapping({\n      name,\n      source: context.filename,\n      original: {\n        line: loc.line,\n        column: loc.column - 1 // source-map column is 0 based\n      },\n      generated: {\n        line: context.line,\n        column: context.column - 1\n      }\n    })\n  }\n\n  if (!__BROWSER__ && context.map) {\n    context.map.setSourceContent(filename, context.source)\n  }\n  return context\n}\n\nexport function generate(\n  ast: RootNode,\n  options: CodegenOptions = {}\n): CodegenResult {\n  const context = createCodegenContext(ast, options)\n  const {\n    mode,\n    push,\n    helper,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline\n  } = context\n  const hasHelpers = ast.helpers.length > 0\n  const useWithBlock = !prefixIdentifiers && mode !== 'module'\n\n  // preambles\n  if (mode === 'function') {\n    // Generate const declaration for helpers\n    // In prefix mode, we place the const declaration at top so it's done\n    // only once; But if we not prefixing, we place the declaration inside the\n    // with block so it doesn't incur the `in` check cost for every helper access.\n    if (hasHelpers) {\n      if (prefixIdentifiers) {\n        push(`const { ${ast.helpers.map(helper).join(', ')} } = Vue\\n`)\n      } else {\n        // \"with\" mode.\n        // save Vue in a separate variable to avoid collision\n        push(`const _Vue = Vue\\n`)\n        // in \"with\" mode, helpers are declared inside the with block to avoid\n        // has check cost, but hoists are lifted out of the function - we need\n        // to provide the helper here.\n        if (ast.hoists.length) {\n          push(`const _${helperNameMap[CREATE_VNODE]} = Vue.createVNode\\n`)\n          if (ast.helpers.includes(COMMENT)) {\n            push(`const _${helperNameMap[COMMENT]} = Vue.Comment\\n`)\n          }\n        }\n      }\n    }\n    genHoists(ast.hoists, context)\n    newline()\n    push(`return `)\n  } else {\n    // generate import statements for helpers\n    if (hasHelpers) {\n      push(`import { ${ast.helpers.map(helper).join(', ')} } from \"vue\"\\n`)\n    }\n    genHoists(ast.hoists, context)\n    newline()\n    push(`export default `)\n  }\n\n  // enter render function\n  push(`function render() {`)\n  indent()\n\n  if (useWithBlock) {\n    push(`with (this) {`)\n    indent()\n    // function mode const declarations should be inside with block\n    // also they should be renamed to avoid collision with user properties\n    if (hasHelpers) {\n      push(\n        `const { ${ast.helpers\n          .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)\n          .join(', ')} } = _Vue`\n      )\n      newline()\n      newline()\n    }\n  } else {\n    push(`const _ctx = this`)\n    if (ast.cached > 0) {\n      newline()\n      push(`const _cache = _ctx.$cache`)\n    }\n    newline()\n  }\n\n  // generate asset resolution statements\n  if (ast.components.length) {\n    genAssets(ast.components, 'component', context)\n  }\n  if (ast.directives.length) {\n    genAssets(ast.directives, 'directive', context)\n  }\n  if (ast.components.length || ast.directives.length) {\n    newline()\n  }\n\n  // generate the VNode tree expression\n  push(`return `)\n  if (ast.codegenNode) {\n    genNode(ast.codegenNode, context)\n  } else {\n    push(`null`)\n  }\n\n  if (useWithBlock) {\n    deindent()\n    push(`}`)\n  }\n\n  deindent()\n  push(`}`)\n  return {\n    ast,\n    code: context.code,\n    map: context.map ? context.map.toJSON() : undefined\n  }\n}\n\nfunction genAssets(\n  assets: string[],\n  type: 'component' | 'directive',\n  context: CodegenContext\n) {\n  const resolver = context.helper(\n    type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE\n  )\n  for (let i = 0; i < assets.length; i++) {\n    const id = assets[i]\n    context.push(\n      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`\n    )\n    context.newline()\n  }\n}\n\nfunction genHoists(hoists: JSChildNode[], context: CodegenContext) {\n  if (!hoists.length) {\n    return\n  }\n  context.newline()\n  hoists.forEach((exp, i) => {\n    context.push(`const _hoisted_${i + 1} = `)\n    genNode(exp, context)\n    context.newline()\n  })\n}\n\nfunction isText(n: string | CodegenNode) {\n  return (\n    isString(n) ||\n    n.type === NodeTypes.SIMPLE_EXPRESSION ||\n    n.type === NodeTypes.TEXT ||\n    n.type === NodeTypes.INTERPOLATION ||\n    n.type === NodeTypes.COMPOUND_EXPRESSION\n  )\n}\n\nfunction genNodeListAsArray(\n  nodes: (string | CodegenNode | TemplateChildNode[])[],\n  context: CodegenContext\n) {\n  const multilines =\n    nodes.length > 3 ||\n    ((!__BROWSER__ || __DEV__) && nodes.some(n => isArray(n) || !isText(n)))\n  context.push(`[`)\n  multilines && context.indent()\n  genNodeList(nodes, context, multilines)\n  multilines && context.deindent()\n  context.push(`]`)\n}\n\nfunction genNodeList(\n  nodes: (string | symbol | CodegenNode | TemplateChildNode[])[],\n  context: CodegenContext,\n  multilines: boolean = false\n) {\n  const { push, newline } = context\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]\n    if (isString(node)) {\n      push(node)\n    } else if (isArray(node)) {\n      genNodeListAsArray(node, context)\n    } else {\n      genNode(node, context)\n    }\n    if (i < nodes.length - 1) {\n      if (multilines) {\n        push(',')\n        newline()\n      } else {\n        push(', ')\n      }\n    }\n  }\n}\n\nfunction genNode(node: CodegenNode | symbol | string, context: CodegenContext) {\n  if (isString(node)) {\n    context.push(node)\n    return\n  }\n  if (isSymbol(node)) {\n    context.push(context.helper(node))\n    return\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n      __DEV__ &&\n        assert(\n          node.codegenNode != null,\n          `Codegen node is missing for element/if/for node. ` +\n            `Apply appropriate transforms first.`\n        )\n      genNode(node.codegenNode!, context)\n      break\n    case NodeTypes.TEXT:\n      genText(node, context)\n      break\n    case NodeTypes.SIMPLE_EXPRESSION:\n      genExpression(node, context)\n      break\n    case NodeTypes.INTERPOLATION:\n      genInterpolation(node, context)\n      break\n    case NodeTypes.TEXT_CALL:\n      genNode(node.codegenNode, context)\n      break\n    case NodeTypes.COMPOUND_EXPRESSION:\n      genCompoundExpression(node, context)\n      break\n    case NodeTypes.COMMENT:\n      genComment(node, context)\n      break\n    case NodeTypes.JS_CALL_EXPRESSION:\n      genCallExpression(node, context)\n      break\n    case NodeTypes.JS_OBJECT_EXPRESSION:\n      genObjectExpression(node, context)\n      break\n    case NodeTypes.JS_ARRAY_EXPRESSION:\n      genArrayExpression(node, context)\n      break\n    case NodeTypes.JS_FUNCTION_EXPRESSION:\n      genFunctionExpression(node, context)\n      break\n    case NodeTypes.JS_SEQUENCE_EXPRESSION:\n      genSequenceExpression(node, context)\n      break\n    case NodeTypes.JS_CONDITIONAL_EXPRESSION:\n      genConditionalExpression(node, context)\n      break\n    case NodeTypes.JS_CACHE_EXPRESSION:\n      genCacheExpression(node, context)\n      break\n    /* istanbul ignore next */\n    default:\n      if (__DEV__) {\n        assert(false, `unhandled codegen node type: ${(node as any).type}`)\n        // make sure we exhaust all possible types\n        const exhaustiveCheck: never = node\n        return exhaustiveCheck\n      }\n  }\n}\n\nfunction genText(\n  node: TextNode | SimpleExpressionNode,\n  context: CodegenContext\n) {\n  context.push(JSON.stringify(node.content), node)\n}\n\nfunction genExpression(node: SimpleExpressionNode, context: CodegenContext) {\n  const { content, isStatic } = node\n  context.push(isStatic ? JSON.stringify(content) : content, node)\n}\n\nfunction genInterpolation(node: InterpolationNode, context: CodegenContext) {\n  const { push, helper } = context\n  push(`${helper(TO_STRING)}(`)\n  genNode(node.content, context)\n  push(`)`)\n}\n\nfunction genCompoundExpression(\n  node: CompoundExpressionNode,\n  context: CodegenContext\n) {\n  for (let i = 0; i < node.children!.length; i++) {\n    const child = node.children![i]\n    if (isString(child)) {\n      context.push(child)\n    } else {\n      genNode(child, context)\n    }\n  }\n}\n\nfunction genExpressionAsPropertyKey(\n  node: ExpressionNode,\n  context: CodegenContext\n) {\n  const { push } = context\n  if (node.type === NodeTypes.COMPOUND_EXPRESSION) {\n    push(`[`)\n    genCompoundExpression(node, context)\n    push(`]`)\n  } else if (node.isStatic) {\n    // only quote keys if necessary\n    const text = isSimpleIdentifier(node.content)\n      ? node.content\n      : JSON.stringify(node.content)\n    push(text, node)\n  } else {\n    push(`[${node.content}]`, node)\n  }\n}\n\nfunction genComment(node: CommentNode, context: CodegenContext) {\n  if (__DEV__) {\n    const { push, helper } = context\n    push(\n      `${helper(CREATE_VNODE)}(${helper(COMMENT)}, null, ${JSON.stringify(\n        node.content\n      )})`,\n      node\n    )\n  }\n}\n\n// JavaScript\nfunction genCallExpression(node: CallExpression, context: CodegenContext) {\n  const callee = isString(node.callee)\n    ? node.callee\n    : context.helper(node.callee)\n  context.push(callee + `(`, node, true)\n  genNodeList(node.arguments, context)\n  context.push(`)`)\n}\n\nfunction genObjectExpression(node: ObjectExpression, context: CodegenContext) {\n  const { push, indent, deindent, newline, resetMapping } = context\n  const { properties } = node\n  if (!properties.length) {\n    push(`{}`, node)\n    return\n  }\n  const multilines =\n    properties.length > 1 ||\n    ((!__BROWSER__ || __DEV__) &&\n      properties.some(p => p.value.type !== NodeTypes.SIMPLE_EXPRESSION))\n  push(multilines ? `{` : `{ `)\n  multilines && indent()\n  for (let i = 0; i < properties.length; i++) {\n    const { key, value, loc } = properties[i]\n    resetMapping(loc) // reset source mapping for every property.\n    // key\n    genExpressionAsPropertyKey(key, context)\n    push(`: `)\n    // value\n    genNode(value, context)\n    if (i < properties.length - 1) {\n      // will only reach this if it's multilines\n      push(`,`)\n      newline()\n    }\n  }\n  multilines && deindent()\n  const lastChar = context.code[context.code.length - 1]\n  push(multilines || /[\\])}]/.test(lastChar) ? `}` : ` }`)\n}\n\nfunction genArrayExpression(node: ArrayExpression, context: CodegenContext) {\n  genNodeListAsArray(node.elements, context)\n}\n\nfunction genFunctionExpression(\n  node: FunctionExpression,\n  context: CodegenContext\n) {\n  const { push, indent, deindent } = context\n  const { params, returns, newline } = node\n  push(`(`, node)\n  if (isArray(params)) {\n    genNodeList(params, context)\n  } else if (params) {\n    genNode(params, context)\n  }\n  push(`) => `)\n  if (newline) {\n    push(`{`)\n    indent()\n    push(`return `)\n  }\n  if (isArray(returns)) {\n    genNodeListAsArray(returns, context)\n  } else {\n    genNode(returns, context)\n  }\n  if (newline) {\n    deindent()\n    push(`}`)\n  }\n}\n\nfunction genConditionalExpression(\n  node: ConditionalExpression,\n  context: CodegenContext\n) {\n  const { test, consequent, alternate } = node\n  const { push, indent, deindent, newline } = context\n  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {\n    const needsParens = !isSimpleIdentifier(test.content)\n    needsParens && push(`(`)\n    genExpression(test, context)\n    needsParens && push(`)`)\n  } else {\n    push(`(`)\n    genCompoundExpression(test, context)\n    push(`)`)\n  }\n  indent()\n  context.indentLevel++\n  push(`? `)\n  genNode(consequent, context)\n  context.indentLevel--\n  newline()\n  push(`: `)\n  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\n  if (!isNested) {\n    context.indentLevel++\n  }\n  genNode(alternate, context)\n  if (!isNested) {\n    context.indentLevel--\n  }\n  deindent(true /* without newline */)\n}\n\nfunction genSequenceExpression(\n  node: SequenceExpression,\n  context: CodegenContext\n) {\n  context.push(`(`)\n  genNodeList(node.expressions, context)\n  context.push(`)`)\n}\n\nfunction genCacheExpression(node: CacheExpression, context: CodegenContext) {\n  context.push(`_cache[${node.index}] || (_cache[${node.index}] = `)\n  genNode(node.value, context)\n  context.push(`)`)\n}\n","// - Parse expressions in templates into compound expressions so that each\n//   identifier gets more accurate source-map locations.\n//\n// - Prefix identifiers with `_ctx.` so that they are accessed from the render\n//   context\n//\n// - This transform is only applied in non-browser builds because it relies on\n//   an additional JavaScript parser. In the browser, there is no source-map\n//   support and the code is wrapped in `with (this) { ... }`.\nimport { NodeTransform, TransformContext } from '../transform'\nimport {\n  NodeTypes,\n  createSimpleExpression,\n  ExpressionNode,\n  SimpleExpressionNode,\n  CompoundExpressionNode,\n  createCompoundExpression\n} from '../ast'\nimport { Node, Function, Identifier, Property } from 'estree'\nimport {\n  advancePositionWithClone,\n  isSimpleIdentifier,\n  parseJS,\n  walkJS\n} from '../utils'\nimport { isGloballyWhitelisted, makeMap } from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\n\nconst isLiteralWhitelisted = /*#__PURE__*/ makeMap('true,false,null,this')\n\nexport const transformExpression: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.INTERPOLATION) {\n    node.content = processExpression(\n      node.content as SimpleExpressionNode,\n      context\n    )\n  } else if (node.type === NodeTypes.ELEMENT) {\n    // handle directives on element\n    for (let i = 0; i < node.props.length; i++) {\n      const dir = node.props[i]\n      // do not process for v-on & v-for since they are special handled\n      if (dir.type === NodeTypes.DIRECTIVE && dir.name !== 'for') {\n        const exp = dir.exp as SimpleExpressionNode | undefined\n        const arg = dir.arg as SimpleExpressionNode | undefined\n        // do not process exp if this is v-on:arg - we need special handling\n        // for wrapping inline statements.\n        if (exp && !(dir.name === 'on' && arg)) {\n          dir.exp = processExpression(\n            exp,\n            context,\n            // slot args must be processed as function params\n            dir.name === 'slot'\n          )\n        }\n        if (arg && !arg.isStatic) {\n          dir.arg = processExpression(arg, context)\n        }\n      }\n    }\n  }\n}\n\ninterface PrefixMeta {\n  prefix?: string\n  isConstant: boolean\n  start: number\n  end: number\n  scopeIds?: Set<string>\n}\n\n// Important: since this function uses Node.js only dependencies, it should\n// always be used with a leading !__BROWSER__ check so that it can be\n// tree-shaken from the browser build.\nexport function processExpression(\n  node: SimpleExpressionNode,\n  context: TransformContext,\n  // some expressions like v-slot props & v-for aliases should be parsed as\n  // function params\n  asParams: boolean = false\n): ExpressionNode {\n  if (!context.prefixIdentifiers || !node.content.trim()) {\n    return node\n  }\n\n  // fast path if expression is a simple identifier.\n  const rawExp = node.content\n  if (isSimpleIdentifier(rawExp)) {\n    if (\n      !asParams &&\n      !context.identifiers[rawExp] &&\n      !isGloballyWhitelisted(rawExp) &&\n      !isLiteralWhitelisted(rawExp)\n    ) {\n      node.content = `_ctx.${rawExp}`\n    } else if (!context.identifiers[rawExp]) {\n      // mark node constant for hoisting unless it's referring a scope variable\n      node.isConstant = true\n    }\n    return node\n  }\n\n  let ast: any\n  // if the expression is supposed to be used in a function params position\n  // we need to parse it differently.\n  const source = `(${rawExp})${asParams ? `=>{}` : ``}`\n  try {\n    ast = parseJS(source, { ranges: true })\n  } catch (e) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_INVALID_EXPRESSION, node.loc)\n    )\n    return node\n  }\n\n  const ids: (Identifier & PrefixMeta)[] = []\n  const knownIds = Object.create(context.identifiers)\n\n  // walk the AST and look for identifiers that need to be prefixed with `_ctx.`.\n  walkJS(ast, {\n    enter(node: Node & PrefixMeta, parent) {\n      if (node.type === 'Identifier') {\n        if (!ids.includes(node)) {\n          const needPrefix = shouldPrefix(node, parent)\n          if (!knownIds[node.name] && needPrefix) {\n            if (isPropertyShorthand(node, parent)) {\n              // property shorthand like { foo }, we need to add the key since we\n              // rewrite the value\n              node.prefix = `${node.name}: `\n            }\n            node.name = `_ctx.${node.name}`\n            node.isConstant = false\n            ids.push(node)\n          } else if (!isStaticPropertyKey(node, parent)) {\n            // The identifier is considered constant unless it's pointing to a\n            // scope variable (a v-for alias, or a v-slot prop)\n            node.isConstant = !(needPrefix && knownIds[node.name])\n            // also generate sub-expressions for other identifiers for better\n            // source map support. (except for property keys which are static)\n            ids.push(node)\n          }\n        }\n      } else if (isFunction(node)) {\n        // walk function expressions and add its arguments to known identifiers\n        // so that we don't prefix them\n        node.params.forEach(p =>\n          walkJS(p, {\n            enter(child, parent) {\n              if (\n                child.type === 'Identifier' &&\n                // do not record as scope variable if is a destructured key\n                !isStaticPropertyKey(child, parent) &&\n                // do not record if this is a default value\n                // assignment of a destructured variable\n                !(\n                  parent &&\n                  parent.type === 'AssignmentPattern' &&\n                  parent.right === child\n                )\n              ) {\n                const { name } = child\n                if (node.scopeIds && node.scopeIds.has(name)) {\n                  return\n                }\n                if (name in knownIds) {\n                  knownIds[name]++\n                } else {\n                  knownIds[name] = 1\n                }\n                ;(node.scopeIds || (node.scopeIds = new Set())).add(name)\n              }\n            }\n          })\n        )\n      }\n    },\n    leave(node: Node & PrefixMeta) {\n      if (node !== ast.body[0].expression && node.scopeIds) {\n        node.scopeIds.forEach((id: string) => {\n          knownIds[id]--\n          if (knownIds[id] === 0) {\n            delete knownIds[id]\n          }\n        })\n      }\n    }\n  })\n\n  // We break up the compound expression into an array of strings and sub\n  // expressions (for identifiers that have been prefixed). In codegen, if\n  // an ExpressionNode has the `.children` property, it will be used instead of\n  // `.content`.\n  const children: CompoundExpressionNode['children'] = []\n  ids.sort((a, b) => a.start - b.start)\n  ids.forEach((id, i) => {\n    // range is offset by -1 due to the wrapping parens when parsed\n    const start = id.start - 1\n    const end = id.end - 1\n    const last = ids[i - 1]\n    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)\n    if (leadingText.length || id.prefix) {\n      children.push(leadingText + (id.prefix || ``))\n    }\n    const source = rawExp.slice(start, end)\n    children.push(\n      createSimpleExpression(\n        id.name,\n        false,\n        {\n          source,\n          start: advancePositionWithClone(node.loc.start, source, start),\n          end: advancePositionWithClone(node.loc.start, source, end)\n        },\n        id.isConstant /* isConstant */\n      )\n    )\n    if (i === ids.length - 1 && end < rawExp.length) {\n      children.push(rawExp.slice(end))\n    }\n  })\n\n  let ret\n  if (children.length) {\n    ret = createCompoundExpression(children, node.loc)\n  } else {\n    ret = node\n    ret.isConstant = true\n  }\n  ret.identifiers = Object.keys(knownIds)\n  return ret\n}\n\nconst isFunction = (node: Node): node is Function =>\n  /Function(Expression|Declaration)$/.test(node.type)\n\nconst isPropertyKey = (node: Node, parent: Node) =>\n  parent &&\n  parent.type === 'Property' &&\n  parent.key === node &&\n  !parent.computed\n\nconst isPropertyShorthand = (node: Node, parent: Node) =>\n  isPropertyKey(node, parent) && (parent as Property).value === node\n\nconst isStaticPropertyKey = (node: Node, parent: Node) =>\n  isPropertyKey(node, parent) && (parent as Property).value !== node\n\nfunction shouldPrefix(identifier: Identifier, parent: Node) {\n  if (\n    !(\n      isFunction(parent) &&\n      // not id of a FunctionDeclaration\n      ((parent as any).id === identifier ||\n        // not a params of a function\n        parent.params.includes(identifier))\n    ) &&\n    // not a key of Property\n    !isStaticPropertyKey(identifier, parent) &&\n    // not a property of a MemberExpression\n    !(\n      parent.type === 'MemberExpression' &&\n      parent.property === identifier &&\n      !parent.computed\n    ) &&\n    // not in an Array destructure pattern\n    !(parent.type === 'ArrayPattern') &&\n    // skip whitelisted globals\n    !isGloballyWhitelisted(identifier.name) &&\n    // special case for webpack compilation\n    identifier.name !== `require` &&\n    // is a special keyword but parsed as identifier\n    identifier.name !== `arguments`\n  ) {\n    return true\n  }\n}\n","import {\n  createStructuralDirectiveTransform,\n  traverseChildren,\n  TransformContext\n} from '../transform'\nimport {\n  NodeTypes,\n  ElementTypes,\n  ElementNode,\n  DirectiveNode,\n  IfBranchNode,\n  SimpleExpressionNode,\n  createSequenceExpression,\n  createCallExpression,\n  createConditionalExpression,\n  ConditionalExpression,\n  CallExpression,\n  createSimpleExpression,\n  createObjectProperty,\n  createObjectExpression,\n  IfCodegenNode,\n  IfConditionalExpression,\n  BlockCodegenNode,\n  SlotOutletCodegenNode,\n  ElementCodegenNode,\n  ComponentCodegenNode\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { processExpression } from './transformExpression'\nimport {\n  OPEN_BLOCK,\n  CREATE_BLOCK,\n  COMMENT,\n  FRAGMENT,\n  WITH_DIRECTIVES,\n  CREATE_VNODE\n} from '../runtimeHelpers'\nimport { injectProp } from '../utils'\n\nexport const transformIf = createStructuralDirectiveTransform(\n  /^(if|else|else-if)$/,\n  (node, dir, context) => {\n    if (\n      dir.name !== 'else' &&\n      (!dir.exp || !(dir.exp as SimpleExpressionNode).content.trim())\n    ) {\n      const loc = dir.exp ? dir.exp.loc : node.loc\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_IF_NO_EXPRESSION, dir.loc)\n      )\n      dir.exp = createSimpleExpression(`true`, false, loc)\n    }\n\n    if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {\n      // dir.exp can only be simple expression because vIf transform is applied\n      // before expression transform.\n      dir.exp = processExpression(dir.exp as SimpleExpressionNode, context)\n    }\n\n    if (dir.name === 'if') {\n      const branch = createIfBranch(node, dir)\n      const codegenNode = createSequenceExpression([\n        createCallExpression(context.helper(OPEN_BLOCK))\n      ]) as IfCodegenNode\n\n      context.replaceNode({\n        type: NodeTypes.IF,\n        loc: node.loc,\n        branches: [branch],\n        codegenNode\n      })\n\n      // Exit callback. Complete the codegenNode when all children have been\n      // transformed.\n      return () => {\n        codegenNode.expressions.push(createCodegenNodeForBranch(\n          branch,\n          0,\n          context\n        ) as IfConditionalExpression)\n      }\n    } else {\n      // locate the adjacent v-if\n      const siblings = context.parent!.children\n      const comments = []\n      let i = siblings.indexOf(node)\n      while (i-- >= -1) {\n        const sibling = siblings[i]\n        if (__DEV__ && sibling && sibling.type === NodeTypes.COMMENT) {\n          context.removeNode(sibling)\n          comments.unshift(sibling)\n          continue\n        }\n        if (sibling && sibling.type === NodeTypes.IF) {\n          // move the node to the if node's branches\n          context.removeNode()\n          const branch = createIfBranch(node, dir)\n          if (__DEV__ && comments.length) {\n            branch.children = [...comments, ...branch.children]\n          }\n          sibling.branches.push(branch)\n          // since the branch was removed, it will not be traversed.\n          // make sure to traverse here.\n          traverseChildren(branch, context)\n          // make sure to reset currentNode after traversal to indicate this\n          // node has been removed.\n          context.currentNode = null\n          // attach this branch's codegen node to the v-if root.\n          let parentCondition = sibling.codegenNode\n            .expressions[1] as ConditionalExpression\n          while (true) {\n            if (\n              parentCondition.alternate.type ===\n              NodeTypes.JS_CONDITIONAL_EXPRESSION\n            ) {\n              parentCondition = parentCondition.alternate\n            } else {\n              parentCondition.alternate = createCodegenNodeForBranch(\n                branch,\n                sibling.branches.length - 1,\n                context\n              )\n              break\n            }\n          }\n        } else {\n          context.onError(\n            createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc)\n          )\n        }\n        break\n      }\n    }\n  }\n)\n\nfunction createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode {\n  return {\n    type: NodeTypes.IF_BRANCH,\n    loc: node.loc,\n    condition: dir.name === 'else' ? undefined : dir.exp,\n    children: node.tagType === ElementTypes.TEMPLATE ? node.children : [node]\n  }\n}\n\nfunction createCodegenNodeForBranch(\n  branch: IfBranchNode,\n  index: number,\n  context: TransformContext\n): IfConditionalExpression | BlockCodegenNode {\n  if (branch.condition) {\n    return createConditionalExpression(\n      branch.condition,\n      createChildrenCodegenNode(branch, index, context),\n      createCallExpression(context.helper(CREATE_BLOCK), [\n        context.helper(COMMENT)\n      ])\n    ) as IfConditionalExpression\n  } else {\n    return createChildrenCodegenNode(branch, index, context) as BlockCodegenNode\n  }\n}\n\nfunction createChildrenCodegenNode(\n  branch: IfBranchNode,\n  index: number,\n  context: TransformContext\n): CallExpression {\n  const { helper } = context\n  const keyProperty = createObjectProperty(\n    `key`,\n    createSimpleExpression(index + '', false)\n  )\n  const { children } = branch\n  const child = children[0]\n  const needFragmentWrapper =\n    children.length !== 1 || child.type !== NodeTypes.ELEMENT\n  if (needFragmentWrapper) {\n    const blockArgs: CallExpression['arguments'] = [\n      helper(FRAGMENT),\n      createObjectExpression([keyProperty]),\n      children\n    ]\n    if (children.length === 1 && child.type === NodeTypes.FOR) {\n      // optimize away nested fragments when child is a ForNode\n      const forBlockArgs = child.codegenNode.expressions[1].arguments\n      // directly use the for block's children and patchFlag\n      blockArgs[2] = forBlockArgs[2]\n      blockArgs[3] = forBlockArgs[3]\n    }\n    return createCallExpression(helper(CREATE_BLOCK), blockArgs)\n  } else {\n    const childCodegen = (child as ElementNode).codegenNode as\n      | ElementCodegenNode\n      | ComponentCodegenNode\n      | SlotOutletCodegenNode\n    let vnodeCall = childCodegen\n    // Element with custom directives. Locate the actual createVNode() call.\n    if (vnodeCall.callee === WITH_DIRECTIVES) {\n      vnodeCall = vnodeCall.arguments[0]\n    }\n    // Change createVNode to createBlock.\n    if (vnodeCall.callee === CREATE_VNODE) {\n      vnodeCall.callee = helper(CREATE_BLOCK)\n    }\n    // inject branch key\n    injectProp(vnodeCall, keyProperty, context)\n    return childCodegen\n  }\n}\n","import {\n  createStructuralDirectiveTransform,\n  TransformContext\n} from '../transform'\nimport {\n  NodeTypes,\n  ExpressionNode,\n  createSimpleExpression,\n  SourceLocation,\n  SimpleExpressionNode,\n  createSequenceExpression,\n  createCallExpression,\n  createFunctionExpression,\n  ElementTypes,\n  createObjectExpression,\n  createObjectProperty,\n  ForCodegenNode,\n  ElementCodegenNode\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  getInnerRange,\n  findProp,\n  createBlockExpression,\n  isTemplateNode,\n  isSlotOutlet,\n  injectProp\n} from '../utils'\nimport {\n  RENDER_LIST,\n  OPEN_BLOCK,\n  CREATE_BLOCK,\n  FRAGMENT,\n  WITH_DIRECTIVES\n} from '../runtimeHelpers'\nimport { processExpression } from './transformExpression'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\n\nexport const transformFor = createStructuralDirectiveTransform(\n  'for',\n  (node, dir, context) => {\n    if (!dir.exp) {\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_FOR_NO_EXPRESSION, dir.loc)\n      )\n      return\n    }\n\n    const parseResult = parseForExpression(\n      // can only be simple expression because vFor transform is applied\n      // before expression transform.\n      dir.exp as SimpleExpressionNode,\n      context\n    )\n\n    if (!parseResult) {\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, dir.loc)\n      )\n      return\n    }\n\n    const { helper, addIdentifiers, removeIdentifiers, scopes } = context\n    const { source, value, key, index } = parseResult\n\n    // create the loop render function expression now, and add the\n    // iterator on exit after all children have been traversed\n    const renderExp = createCallExpression(helper(RENDER_LIST), [source])\n    const keyProp = findProp(node, `key`)\n    const fragmentFlag = keyProp\n      ? PatchFlags.KEYED_FRAGMENT\n      : PatchFlags.UNKEYED_FRAGMENT\n    const codegenNode = createSequenceExpression([\n      // fragment blocks disable tracking since they always diff their children\n      createCallExpression(helper(OPEN_BLOCK), [`false`]),\n      createCallExpression(helper(CREATE_BLOCK), [\n        helper(FRAGMENT),\n        `null`,\n        renderExp,\n        fragmentFlag + (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``)\n      ])\n    ]) as ForCodegenNode\n\n    context.replaceNode({\n      type: NodeTypes.FOR,\n      loc: dir.loc,\n      source,\n      valueAlias: value,\n      keyAlias: key,\n      objectIndexAlias: index,\n      children: node.tagType === ElementTypes.TEMPLATE ? node.children : [node],\n      codegenNode\n    })\n\n    // bookkeeping\n    scopes.vFor++\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      // scope management\n      // inject identifiers to context\n      value && addIdentifiers(value)\n      key && addIdentifiers(key)\n      index && addIdentifiers(index)\n    }\n\n    return () => {\n      scopes.vFor--\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        value && removeIdentifiers(value)\n        key && removeIdentifiers(key)\n        index && removeIdentifiers(index)\n      }\n\n      // finish the codegen now that all children have been traversed\n      let childBlock\n      const isTemplate = isTemplateNode(node)\n      const slotOutlet = isSlotOutlet(node)\n        ? node\n        : isTemplate &&\n          node.children.length === 1 &&\n          isSlotOutlet(node.children[0])\n          ? node.children[0]\n          : null\n      const keyProperty = keyProp\n        ? createObjectProperty(\n            `key`,\n            keyProp.type === NodeTypes.ATTRIBUTE\n              ? createSimpleExpression(keyProp.value!.content, true)\n              : keyProp.exp!\n          )\n        : null\n      if (slotOutlet) {\n        // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\n        childBlock = slotOutlet.codegenNode!\n        if (isTemplate && keyProperty) {\n          // <template v-for=\"...\" :key=\"...\"><slot/></template>\n          // we need to inject the key to the renderSlot() call.\n          // the props for renderSlot is passed as the 3rd argument.\n          injectProp(childBlock, keyProperty, context)\n        }\n      } else if (isTemplate) {\n        // <template v-for=\"...\">\n        // should generate a fragment block for each loop\n        childBlock = createBlockExpression(\n          createCallExpression(helper(CREATE_BLOCK), [\n            helper(FRAGMENT),\n            keyProperty ? createObjectExpression([keyProperty]) : `null`,\n            node.children\n          ]),\n          context\n        )\n      } else {\n        // Normal element v-for. Directly use the child's codegenNode\n        // arguments, but replace createVNode() with createBlock()\n        let codegenNode = node.codegenNode as ElementCodegenNode\n        if (codegenNode.callee === WITH_DIRECTIVES) {\n          codegenNode.arguments[0].callee = helper(CREATE_BLOCK)\n        } else {\n          codegenNode.callee = helper(CREATE_BLOCK)\n        }\n        childBlock = createBlockExpression(codegenNode, context)\n      }\n\n      renderExp.arguments.push(\n        createFunctionExpression(\n          createForLoopParams(parseResult),\n          childBlock,\n          true /* force newline */\n        )\n      )\n    }\n  }\n)\n\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\n// This regex doesn't cover the case if key or index aliases have destructuring,\n// but those do not make sense in the first place, so this works in practice.\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\nconst stripParensRE = /^\\(|\\)$/g\n\nexport interface ForParseResult {\n  source: ExpressionNode\n  value: ExpressionNode | undefined\n  key: ExpressionNode | undefined\n  index: ExpressionNode | undefined\n}\n\nexport function parseForExpression(\n  input: SimpleExpressionNode,\n  context: TransformContext\n): ForParseResult | undefined {\n  const loc = input.loc\n  const exp = input.content\n  const inMatch = exp.match(forAliasRE)\n  if (!inMatch) return\n\n  const [, LHS, RHS] = inMatch\n\n  const result: ForParseResult = {\n    source: createAliasExpression(\n      loc,\n      RHS.trim(),\n      exp.indexOf(RHS, LHS.length)\n    ),\n    value: undefined,\n    key: undefined,\n    index: undefined\n  }\n  if (!__BROWSER__ && context.prefixIdentifiers) {\n    result.source = processExpression(\n      result.source as SimpleExpressionNode,\n      context\n    )\n  }\n\n  let valueContent = LHS.trim()\n    .replace(stripParensRE, '')\n    .trim()\n  const trimmedOffset = LHS.indexOf(valueContent)\n\n  const iteratorMatch = valueContent.match(forIteratorRE)\n  if (iteratorMatch) {\n    valueContent = valueContent.replace(forIteratorRE, '').trim()\n\n    const keyContent = iteratorMatch[1].trim()\n    let keyOffset: number | undefined\n    if (keyContent) {\n      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)\n      result.key = createAliasExpression(loc, keyContent, keyOffset)\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        result.key = processExpression(result.key, context, true)\n      }\n    }\n\n    if (iteratorMatch[2]) {\n      const indexContent = iteratorMatch[2].trim()\n\n      if (indexContent) {\n        result.index = createAliasExpression(\n          loc,\n          indexContent,\n          exp.indexOf(\n            indexContent,\n            result.key\n              ? keyOffset! + keyContent.length\n              : trimmedOffset + valueContent.length\n          )\n        )\n        if (!__BROWSER__ && context.prefixIdentifiers) {\n          result.index = processExpression(result.index, context, true)\n        }\n      }\n    }\n  }\n\n  if (valueContent) {\n    result.value = createAliasExpression(loc, valueContent, trimmedOffset)\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      result.value = processExpression(result.value, context, true)\n    }\n  }\n\n  return result\n}\n\nfunction createAliasExpression(\n  range: SourceLocation,\n  content: string,\n  offset: number\n): SimpleExpressionNode {\n  return createSimpleExpression(\n    content,\n    false,\n    getInnerRange(range, offset, content.length)\n  )\n}\n\nexport function createForLoopParams({\n  value,\n  key,\n  index\n}: ForParseResult): ExpressionNode[] {\n  const params: ExpressionNode[] = []\n  if (value) {\n    params.push(value)\n  }\n  if (key) {\n    if (!value) {\n      params.push(createSimpleExpression(`_`, false))\n    }\n    params.push(key)\n  }\n  if (index) {\n    if (!key) {\n      if (!value) {\n        params.push(createSimpleExpression(`_`, false))\n      }\n      params.push(createSimpleExpression(`__`, false))\n    }\n    params.push(index)\n  }\n  return params\n}\n","import {\n  ElementNode,\n  ObjectExpression,\n  createObjectExpression,\n  NodeTypes,\n  createObjectProperty,\n  createSimpleExpression,\n  createFunctionExpression,\n  DirectiveNode,\n  ElementTypes,\n  ExpressionNode,\n  Property,\n  TemplateChildNode,\n  SourceLocation,\n  createConditionalExpression,\n  ConditionalExpression,\n  JSChildNode,\n  SimpleExpressionNode,\n  FunctionExpression,\n  CallExpression,\n  createCallExpression,\n  createArrayExpression\n} from '../ast'\nimport { TransformContext, NodeTransform } from '../transform'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { findDir, isTemplateNode, assert, isVSlot, hasScopeRef } from '../utils'\nimport { CREATE_SLOTS, RENDER_LIST } from '../runtimeHelpers'\nimport { parseForExpression, createForLoopParams } from './vFor'\n\nconst isStaticExp = (p: JSChildNode): p is SimpleExpressionNode =>\n  p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStatic\n\nconst defaultFallback = createSimpleExpression(`undefined`, false)\n\n// A NodeTransform that:\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\n//    by transformExpression. This is only applied in non-browser builds with\n//    { prefixIdentifiers: true }.\n// 2. Track v-slot depths so that we know a slot is inside another slot.\n//    Note the exit callback is executed before buildSlots() on the same node,\n//    so only nested slots see positive numbers.\nexport const trackSlotScopes: NodeTransform = (node, context) => {\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    (node.tagType === ElementTypes.COMPONENT ||\n      node.tagType === ElementTypes.TEMPLATE)\n  ) {\n    // We are only checking non-empty v-slot here\n    // since we only care about slots that introduce scope variables.\n    const vSlot = findDir(node, 'slot')\n    if (vSlot) {\n      const slotProps = vSlot.exp\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        slotProps && context.addIdentifiers(slotProps)\n      }\n      context.scopes.vSlot++\n      return () => {\n        if (!__BROWSER__ && context.prefixIdentifiers) {\n          slotProps && context.removeIdentifiers(slotProps)\n        }\n        context.scopes.vSlot--\n      }\n    }\n  }\n}\n\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\nexport const trackVForSlotScopes: NodeTransform = (node, context) => {\n  let vFor\n  if (\n    isTemplateNode(node) &&\n    node.props.some(isVSlot) &&\n    (vFor = findDir(node, 'for'))\n  ) {\n    const result = (vFor.parseResult = parseForExpression(\n      vFor.exp as SimpleExpressionNode,\n      context\n    ))\n    if (result) {\n      const { value, key, index } = result\n      const { addIdentifiers, removeIdentifiers } = context\n      value && addIdentifiers(value)\n      key && addIdentifiers(key)\n      index && addIdentifiers(index)\n\n      return () => {\n        value && removeIdentifiers(value)\n        key && removeIdentifiers(key)\n        index && removeIdentifiers(index)\n      }\n    }\n  }\n}\n\n// Instead of being a DirectiveTransform, v-slot processing is called during\n// transformElement to build the slots object for a component.\nexport function buildSlots(\n  node: ElementNode,\n  context: TransformContext\n): {\n  slots: ObjectExpression | CallExpression\n  hasDynamicSlots: boolean\n} {\n  const { children, loc } = node\n  const slotsProperties: Property[] = []\n  const dynamicSlots: (ConditionalExpression | CallExpression)[] = []\n\n  // If the slot is inside a v-for or another v-slot, force it to be dynamic\n  // since it likely uses a scope variable.\n  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0\n  // with `prefixIdentifiers: true`, this can be further optimized to make\n  // it dynamic only when the slot actually uses the scope variables.\n  if (!__BROWSER__ && context.prefixIdentifiers) {\n    hasDynamicSlots = hasScopeRef(node, context.identifiers)\n  }\n\n  // 1. Check for default slot with slotProps on component itself.\n  //    <Comp v-slot=\"{ prop }\"/>\n  const explicitDefaultSlot = findDir(node, 'slot', true)\n  if (explicitDefaultSlot) {\n    const { arg, exp, loc } = explicitDefaultSlot\n    if (arg) {\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_SLOT_NAMED_SLOT_ON_COMPONENT, loc)\n      )\n    }\n    slotsProperties.push(buildDefaultSlot(exp, children, loc))\n  }\n\n  // 2. Iterate through children and check for template slots\n  //    <template v-slot:foo=\"{ prop }\">\n  let hasTemplateSlots = false\n  let extraneousChild: TemplateChildNode | undefined = undefined\n  const seenSlotNames = new Set<string>()\n  for (let i = 0; i < children.length; i++) {\n    const slotElement = children[i]\n    let slotDir\n\n    if (\n      !isTemplateNode(slotElement) ||\n      !(slotDir = findDir(slotElement, 'slot', true))\n    ) {\n      // not a <template v-slot>, skip.\n      if (slotElement.type !== NodeTypes.COMMENT && !extraneousChild) {\n        extraneousChild = slotElement\n      }\n      continue\n    }\n\n    if (explicitDefaultSlot) {\n      // already has on-component default slot - this is incorrect usage.\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE, slotDir.loc)\n      )\n      break\n    }\n\n    hasTemplateSlots = true\n    const { children: slotChildren, loc: slotLoc } = slotElement\n    const {\n      arg: slotName = createSimpleExpression(`default`, true),\n      exp: slotProps,\n      loc: dirLoc\n    } = slotDir\n\n    // check if name is dynamic.\n    let staticSlotName: string | undefined\n    if (isStaticExp(slotName)) {\n      staticSlotName = slotName ? slotName.content : `default`\n    } else {\n      hasDynamicSlots = true\n    }\n\n    const slotFunction = createFunctionExpression(\n      slotProps,\n      slotChildren,\n      false,\n      slotChildren.length ? slotChildren[0].loc : slotLoc\n    )\n\n    // check if this slot is conditional (v-if/v-for)\n    let vIf: DirectiveNode | undefined\n    let vElse: DirectiveNode | undefined\n    let vFor: DirectiveNode | undefined\n    if ((vIf = findDir(slotElement, 'if'))) {\n      hasDynamicSlots = true\n      dynamicSlots.push(\n        createConditionalExpression(\n          vIf.exp!,\n          buildDynamicSlot(slotName, slotFunction),\n          defaultFallback\n        )\n      )\n    } else if (\n      (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))\n    ) {\n      // find adjacent v-if\n      let j = i\n      let prev\n      while (j--) {\n        prev = children[j]\n        if (prev.type !== NodeTypes.COMMENT) {\n          break\n        }\n      }\n      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\n        // remove node\n        children.splice(i, 1)\n        i--\n        __DEV__ && assert(dynamicSlots.length > 0)\n        // attach this slot to previous conditional\n        let conditional = dynamicSlots[\n          dynamicSlots.length - 1\n        ] as ConditionalExpression\n        while (\n          conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\n        ) {\n          conditional = conditional.alternate\n        }\n        conditional.alternate = vElse.exp\n          ? createConditionalExpression(\n              vElse.exp,\n              buildDynamicSlot(slotName, slotFunction),\n              defaultFallback\n            )\n          : buildDynamicSlot(slotName, slotFunction)\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, vElse.loc)\n        )\n      }\n    } else if ((vFor = findDir(slotElement, 'for'))) {\n      hasDynamicSlots = true\n      const parseResult =\n        vFor.parseResult ||\n        parseForExpression(vFor.exp as SimpleExpressionNode, context)\n      if (parseResult) {\n        // Render the dynamic slots as an array and add it to the createSlot()\n        // args. The runtime knows how to handle it appropriately.\n        dynamicSlots.push(\n          createCallExpression(context.helper(RENDER_LIST), [\n            parseResult.source,\n            createFunctionExpression(\n              createForLoopParams(parseResult),\n              buildDynamicSlot(slotName, slotFunction),\n              true\n            )\n          ])\n        )\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, vFor.loc)\n        )\n      }\n    } else {\n      // check duplicate static names\n      if (staticSlotName) {\n        if (seenSlotNames.has(staticSlotName)) {\n          context.onError(\n            createCompilerError(\n              ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES,\n              dirLoc\n            )\n          )\n          continue\n        }\n        seenSlotNames.add(staticSlotName)\n      }\n      slotsProperties.push(createObjectProperty(slotName, slotFunction))\n    }\n  }\n\n  if (hasTemplateSlots && extraneousChild) {\n    context.onError(\n      createCompilerError(\n        ErrorCodes.X_V_SLOT_EXTRANEOUS_NON_SLOT_CHILDREN,\n        extraneousChild.loc\n      )\n    )\n  }\n\n  if (!explicitDefaultSlot && !hasTemplateSlots) {\n    // implicit default slot.\n    slotsProperties.push(buildDefaultSlot(undefined, children, loc))\n  }\n\n  let slots: ObjectExpression | CallExpression = createObjectExpression(\n    slotsProperties.concat(\n      createObjectProperty(`_compiled`, createSimpleExpression(`true`, false))\n    ),\n    loc\n  )\n  if (dynamicSlots.length) {\n    slots = createCallExpression(context.helper(CREATE_SLOTS), [\n      slots,\n      createArrayExpression(dynamicSlots)\n    ])\n  }\n\n  return {\n    slots,\n    hasDynamicSlots\n  }\n}\n\nfunction buildDefaultSlot(\n  slotProps: ExpressionNode | undefined,\n  children: TemplateChildNode[],\n  loc: SourceLocation\n): Property {\n  return createObjectProperty(\n    `default`,\n    createFunctionExpression(\n      slotProps,\n      children,\n      false,\n      children.length ? children[0].loc : loc\n    )\n  )\n}\n\nfunction buildDynamicSlot(\n  name: ExpressionNode,\n  fn: FunctionExpression\n): ObjectExpression {\n  return createObjectExpression([\n    createObjectProperty(`name`, name),\n    createObjectProperty(`fn`, fn)\n  ])\n}\n","import { NodeTransform, TransformContext } from '../transform'\nimport {\n  NodeTypes,\n  ElementTypes,\n  CallExpression,\n  ObjectExpression,\n  ElementNode,\n  DirectiveNode,\n  ExpressionNode,\n  ArrayExpression,\n  createCallExpression,\n  createArrayExpression,\n  createObjectProperty,\n  createSimpleExpression,\n  createObjectExpression,\n  Property\n} from '../ast'\nimport { PatchFlags, PatchFlagNames, isSymbol } from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  CREATE_VNODE,\n  WITH_DIRECTIVES,\n  RESOLVE_DIRECTIVE,\n  RESOLVE_COMPONENT,\n  RESOLVE_DYNAMIC_COMPONENT,\n  MERGE_PROPS,\n  TO_HANDLERS,\n  PORTAL,\n  SUSPENSE\n} from '../runtimeHelpers'\nimport { getInnerRange, isVSlot, toValidAssetId, findProp } from '../utils'\nimport { buildSlots } from './vSlot'\nimport { isStaticNode } from './hoistStatic'\n\n// some directive transforms (e.g. v-model) may return a symbol for runtime\n// import, which should be used instead of a resolveDirective call.\nconst directiveImportMap = new WeakMap<DirectiveNode, symbol>()\n\n// generate a JavaScript AST for this element's codegen\nexport const transformElement: NodeTransform = (node, context) => {\n  if (\n    node.type !== NodeTypes.ELEMENT ||\n    // handled by transformSlotOutlet\n    node.tagType === ElementTypes.SLOT ||\n    // <template v-if/v-for> should have already been replaced\n    // <templte v-slot> is handled by buildSlots\n    (node.tagType === ElementTypes.TEMPLATE && node.props.some(isVSlot))\n  ) {\n    return\n  }\n  // perform the work on exit, after all child expressions have been\n  // processed and merged.\n  return () => {\n    const isComponent = node.tagType === ElementTypes.COMPONENT\n    let hasProps = node.props.length > 0\n    let patchFlag: number = 0\n    let runtimeDirectives: DirectiveNode[] | undefined\n    let dynamicPropNames: string[] | undefined\n    let dynamicComponent: string | CallExpression | undefined\n\n    // handle dynamic component\n    const isProp = findProp(node, 'is')\n    if (node.tag === 'component') {\n      if (isProp) {\n        // static <component is=\"foo\" />\n        if (isProp.type === NodeTypes.ATTRIBUTE) {\n          const tag = isProp.value && isProp.value.content\n          if (tag) {\n            context.helper(RESOLVE_COMPONENT)\n            context.components.add(tag)\n            dynamicComponent = toValidAssetId(tag, `component`)\n          }\n        }\n        // dynamic <component :is=\"asdf\" />\n        else if (isProp.exp) {\n          dynamicComponent = createCallExpression(\n            context.helper(RESOLVE_DYNAMIC_COMPONENT),\n            [isProp.exp]\n          )\n        }\n      }\n    }\n\n    if (isComponent && !dynamicComponent) {\n      context.helper(RESOLVE_COMPONENT)\n      context.components.add(node.tag)\n    }\n\n    const args: CallExpression['arguments'] = [\n      dynamicComponent\n        ? dynamicComponent\n        : isComponent\n          ? toValidAssetId(node.tag, `component`)\n          : node.tagType === ElementTypes.PORTAL\n            ? context.helper(PORTAL)\n            : node.tagType === ElementTypes.SUSPENSE\n              ? context.helper(SUSPENSE)\n              : `\"${node.tag}\"`\n    ]\n    // props\n    if (hasProps) {\n      const propsBuildResult = buildProps(\n        node,\n        context,\n        // skip reserved \"is\" prop <component is>\n        node.props.filter(p => p !== isProp)\n      )\n      patchFlag = propsBuildResult.patchFlag\n      dynamicPropNames = propsBuildResult.dynamicPropNames\n      runtimeDirectives = propsBuildResult.directives\n      if (!propsBuildResult.props) {\n        hasProps = false\n      } else {\n        args.push(propsBuildResult.props)\n      }\n    }\n    // children\n    const hasChildren = node.children.length > 0\n    if (hasChildren) {\n      if (!hasProps) {\n        args.push(`null`)\n      }\n      if (isComponent) {\n        const { slots, hasDynamicSlots } = buildSlots(node, context)\n        args.push(slots)\n        if (hasDynamicSlots) {\n          patchFlag |= PatchFlags.DYNAMIC_SLOTS\n        }\n      } else if (node.children.length === 1) {\n        const child = node.children[0]\n        const type = child.type\n        // check for dynamic text children\n        const hasDynamicTextChild =\n          type === NodeTypes.INTERPOLATION ||\n          type === NodeTypes.COMPOUND_EXPRESSION\n        if (hasDynamicTextChild && !isStaticNode(child)) {\n          patchFlag |= PatchFlags.TEXT\n        }\n        // pass directly if the only child is a text node\n        // (plain / interpolation / expression)\n        if (hasDynamicTextChild || type === NodeTypes.TEXT) {\n          args.push(child)\n        } else {\n          args.push(node.children)\n        }\n      } else {\n        args.push(node.children)\n      }\n    }\n    // patchFlag & dynamicPropNames\n    if (patchFlag !== 0) {\n      if (!hasChildren) {\n        if (!hasProps) {\n          args.push(`null`)\n        }\n        args.push(`null`)\n      }\n      if (__DEV__) {\n        const flagNames = Object.keys(PatchFlagNames)\n          .map(Number)\n          .filter(n => n > 0 && patchFlag & n)\n          .map(n => PatchFlagNames[n])\n          .join(`, `)\n        args.push(patchFlag + ` /* ${flagNames} */`)\n      } else {\n        args.push(patchFlag + '')\n      }\n      if (dynamicPropNames && dynamicPropNames.length) {\n        args.push(\n          `[${dynamicPropNames.map(n => JSON.stringify(n)).join(`, `)}]`\n        )\n      }\n    }\n\n    const { loc } = node\n    const vnode = createCallExpression(context.helper(CREATE_VNODE), args, loc)\n\n    if (runtimeDirectives && runtimeDirectives.length) {\n      node.codegenNode = createCallExpression(\n        context.helper(WITH_DIRECTIVES),\n        [\n          vnode,\n          createArrayExpression(\n            runtimeDirectives.map(dir => buildDirectiveArgs(dir, context)),\n            loc\n          )\n        ],\n        loc\n      )\n    } else {\n      node.codegenNode = vnode\n    }\n  }\n}\n\nexport type PropsExpression = ObjectExpression | CallExpression | ExpressionNode\n\nexport function buildProps(\n  node: ElementNode,\n  context: TransformContext,\n  props: ElementNode['props'] = node.props\n): {\n  props: PropsExpression | undefined\n  directives: DirectiveNode[]\n  patchFlag: number\n  dynamicPropNames: string[]\n} {\n  const elementLoc = node.loc\n  const isComponent = node.tagType === ElementTypes.COMPONENT\n  let properties: ObjectExpression['properties'] = []\n  const mergeArgs: PropsExpression[] = []\n  const runtimeDirectives: DirectiveNode[] = []\n\n  // patchFlag analysis\n  let patchFlag = 0\n  let hasRef = false\n  let hasClassBinding = false\n  let hasStyleBinding = false\n  let hasDynamicKeys = false\n  const dynamicPropNames: string[] = []\n\n  const analyzePatchFlag = ({ key, value }: Property) => {\n    if (key.type === NodeTypes.SIMPLE_EXPRESSION && key.isStatic) {\n      if (\n        value.type === NodeTypes.JS_CACHE_EXPRESSION ||\n        ((value.type === NodeTypes.SIMPLE_EXPRESSION ||\n          value.type === NodeTypes.COMPOUND_EXPRESSION) &&\n          isStaticNode(value))\n      ) {\n        return\n      }\n      const name = key.content\n      if (name === 'ref') {\n        hasRef = true\n      } else if (name === 'class') {\n        hasClassBinding = true\n      } else if (name === 'style') {\n        hasStyleBinding = true\n      } else if (name !== 'key') {\n        dynamicPropNames.push(name)\n      }\n    } else {\n      hasDynamicKeys = true\n    }\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    // static attribute\n    const prop = props[i]\n    if (prop.type === NodeTypes.ATTRIBUTE) {\n      const { loc, name, value } = prop\n      if (name === 'ref') {\n        hasRef = true\n      }\n      properties.push(\n        createObjectProperty(\n          createSimpleExpression(\n            name,\n            true,\n            getInnerRange(loc, 0, name.length)\n          ),\n          createSimpleExpression(\n            value ? value.content : '',\n            true,\n            value ? value.loc : loc\n          )\n        )\n      )\n    } else {\n      // directives\n      const { name, arg, exp, loc } = prop\n\n      // skip v-slot - it is handled by its dedicated transform.\n      if (name === 'slot') {\n        if (!isComponent) {\n          context.onError(\n            createCompilerError(ErrorCodes.X_V_SLOT_MISPLACED, loc)\n          )\n        }\n        continue\n      }\n\n      // special case for v-bind and v-on with no argument\n      const isBind = name === 'bind'\n      const isOn = name === 'on'\n      if (!arg && (isBind || isOn)) {\n        hasDynamicKeys = true\n        if (exp) {\n          if (properties.length) {\n            mergeArgs.push(\n              createObjectExpression(dedupeProperties(properties), elementLoc)\n            )\n            properties = []\n          }\n          if (isBind) {\n            mergeArgs.push(exp)\n          } else {\n            // v-on=\"obj\" -> toHandlers(obj)\n            mergeArgs.push({\n              type: NodeTypes.JS_CALL_EXPRESSION,\n              loc,\n              callee: context.helper(TO_HANDLERS),\n              arguments: [exp]\n            })\n          }\n        } else {\n          context.onError(\n            createCompilerError(\n              isBind\n                ? ErrorCodes.X_V_BIND_NO_EXPRESSION\n                : ErrorCodes.X_V_ON_NO_EXPRESSION,\n              loc\n            )\n          )\n        }\n        continue\n      }\n\n      const directiveTransform = context.directiveTransforms[name]\n      if (directiveTransform) {\n        // has built-in directive transform.\n        const { props, needRuntime } = directiveTransform(prop, node, context)\n        props.forEach(analyzePatchFlag)\n        properties.push(...props)\n        if (needRuntime) {\n          runtimeDirectives.push(prop)\n          if (isSymbol(needRuntime)) {\n            directiveImportMap.set(prop, needRuntime)\n          }\n        }\n      } else {\n        // no built-in transform, this is a user custom directive.\n        runtimeDirectives.push(prop)\n      }\n    }\n  }\n\n  let propsExpression: PropsExpression | undefined = undefined\n\n  // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\n  if (mergeArgs.length) {\n    if (properties.length) {\n      mergeArgs.push(\n        createObjectExpression(dedupeProperties(properties), elementLoc)\n      )\n    }\n    if (mergeArgs.length > 1) {\n      propsExpression = createCallExpression(\n        context.helper(MERGE_PROPS),\n        mergeArgs,\n        elementLoc\n      )\n    } else {\n      // single v-bind with nothing else - no need for a mergeProps call\n      propsExpression = mergeArgs[0]\n    }\n  } else if (properties.length) {\n    propsExpression = createObjectExpression(\n      dedupeProperties(properties),\n      elementLoc\n    )\n  }\n\n  // patchFlag analysis\n  if (hasDynamicKeys) {\n    patchFlag |= PatchFlags.FULL_PROPS\n  } else {\n    if (hasClassBinding) {\n      patchFlag |= PatchFlags.CLASS\n    }\n    if (hasStyleBinding) {\n      patchFlag |= PatchFlags.STYLE\n    }\n    if (dynamicPropNames.length) {\n      patchFlag |= PatchFlags.PROPS\n    }\n  }\n  if (patchFlag === 0 && (hasRef || runtimeDirectives.length > 0)) {\n    patchFlag |= PatchFlags.NEED_PATCH\n  }\n\n  return {\n    props: propsExpression,\n    directives: runtimeDirectives,\n    patchFlag,\n    dynamicPropNames\n  }\n}\n\n// Dedupe props in an object literal.\n// Literal duplicated attributes would have been warned during the parse phase,\n// however, it's possible to encounter duplicated `onXXX` handlers with different\n// modifiers. We also need to merge static and dynamic class / style attributes.\n// - onXXX handlers / style: merge into array\n// - class: merge into single expression with concatenation\nfunction dedupeProperties(properties: Property[]): Property[] {\n  const knownProps: Record<string, Property> = {}\n  const deduped: Property[] = []\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i]\n    // dynamic keys are always allowed\n    if (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {\n      deduped.push(prop)\n      continue\n    }\n    const name = prop.key.content\n    const existing = knownProps[name]\n    if (existing) {\n      if (\n        name === 'style' ||\n        name === 'class' ||\n        name.startsWith('on') ||\n        name.startsWith('vnode')\n      ) {\n        mergeAsArray(existing, prop)\n      }\n      // unexpected duplicate, should have emitted error during parse\n    } else {\n      knownProps[name] = prop\n      deduped.push(prop)\n    }\n  }\n  return deduped\n}\n\nfunction mergeAsArray(existing: Property, incoming: Property) {\n  if (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {\n    existing.value.elements.push(incoming.value)\n  } else {\n    existing.value = createArrayExpression(\n      [existing.value, incoming.value],\n      existing.loc\n    )\n  }\n}\n\nfunction buildDirectiveArgs(\n  dir: DirectiveNode,\n  context: TransformContext\n): ArrayExpression {\n  const dirArgs: ArrayExpression['elements'] = []\n  const runtime = directiveImportMap.get(dir)\n  if (runtime) {\n    context.helper(runtime)\n    dirArgs.push(context.helperString(runtime))\n  } else {\n    // inject statement for resolving directive\n    context.helper(RESOLVE_DIRECTIVE)\n    context.directives.add(dir.name)\n    dirArgs.push(toValidAssetId(dir.name, `directive`))\n  }\n  const { loc } = dir\n  if (dir.exp) dirArgs.push(dir.exp)\n  if (dir.arg) {\n    if (!dir.exp) {\n      dirArgs.push(`void 0`)\n    }\n    dirArgs.push(dir.arg)\n  }\n  if (Object.keys(dir.modifiers).length) {\n    if (!dir.arg) {\n      if (!dir.exp) {\n        dirArgs.push(`void 0`)\n      }\n      dirArgs.push(`void 0`)\n    }\n    dirArgs.push(\n      createObjectExpression(\n        dir.modifiers.map(modifier =>\n          createObjectProperty(\n            modifier,\n            createSimpleExpression(`true`, false, loc)\n          )\n        ),\n        loc\n      )\n    )\n  }\n  return createArrayExpression(dirArgs, dir.loc)\n}\n","import { NodeTransform } from '../transform'\nimport {\n  NodeTypes,\n  CallExpression,\n  createCallExpression,\n  ExpressionNode\n} from '../ast'\nimport { isSlotOutlet } from '../utils'\nimport { buildProps } from './transformElement'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { RENDER_SLOT } from '../runtimeHelpers'\n\nexport const transformSlotOutlet: NodeTransform = (node, context) => {\n  if (isSlotOutlet(node)) {\n    const { props, children, loc } = node\n    const $slots = context.prefixIdentifiers ? `_ctx.$slots` : `$slots`\n    let slotName: string | ExpressionNode = `\"default\"`\n\n    // check for <slot name=\"xxx\" OR :name=\"xxx\" />\n    let nameIndex: number = -1\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i]\n      if (prop.type === NodeTypes.ATTRIBUTE) {\n        if (prop.name === `name` && prop.value) {\n          // static name=\"xxx\"\n          slotName = JSON.stringify(prop.value.content)\n          nameIndex = i\n          break\n        }\n      } else if (prop.name === `bind`) {\n        const { arg, exp } = prop\n        if (\n          arg &&\n          exp &&\n          arg.type === NodeTypes.SIMPLE_EXPRESSION &&\n          arg.isStatic &&\n          arg.content === `name`\n        ) {\n          // dynamic :name=\"xxx\"\n          slotName = exp\n          nameIndex = i\n          break\n        }\n      }\n    }\n\n    const slotArgs: CallExpression['arguments'] = [$slots, slotName]\n    const propsWithoutName =\n      nameIndex > -1\n        ? props.slice(0, nameIndex).concat(props.slice(nameIndex + 1))\n        : props\n    let hasProps = propsWithoutName.length > 0\n    if (hasProps) {\n      const { props: propsExpression, directives } = buildProps(\n        node,\n        context,\n        propsWithoutName\n      )\n      if (directives.length) {\n        context.onError(\n          createCompilerError(\n            ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\n            directives[0].loc\n          )\n        )\n      }\n      if (propsExpression) {\n        slotArgs.push(propsExpression)\n      } else {\n        hasProps = false\n      }\n    }\n\n    if (children.length) {\n      if (!hasProps) {\n        slotArgs.push(`{}`)\n      }\n      slotArgs.push(children)\n    }\n\n    node.codegenNode = createCallExpression(\n      context.helper(RENDER_SLOT),\n      slotArgs,\n      loc\n    )\n  }\n}\n","import { DirectiveTransform, DirectiveTransformResult } from '../transform'\nimport {\n  DirectiveNode,\n  createObjectProperty,\n  createSimpleExpression,\n  ExpressionNode,\n  NodeTypes,\n  createCompoundExpression,\n  SimpleExpressionNode\n} from '../ast'\nimport { capitalize } from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { processExpression } from './transformExpression'\nimport { isMemberExpression, hasScopeRef } from '../utils'\n\nconst fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/\n\nexport interface VOnDirectiveNode extends DirectiveNode {\n  // v-on without arg is handled directly in ./element.ts due to it affecting\n  // codegen for the entire props object. This transform here is only for v-on\n  // *with* args.\n  arg: ExpressionNode\n  // exp is guaranteed to be a simple expression here because v-on w/ arg is\n  // skipped by transformExpression as a special case.\n  exp: SimpleExpressionNode | undefined\n}\n\nexport const transformOn: DirectiveTransform = (\n  dir: VOnDirectiveNode,\n  node,\n  context,\n  augmentor\n) => {\n  const { loc, modifiers, arg } = dir\n  if (!dir.exp && !modifiers.length) {\n    context.onError(createCompilerError(ErrorCodes.X_V_ON_NO_EXPRESSION, loc))\n  }\n  let eventName: ExpressionNode\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n    if (arg.isStatic) {\n      eventName = createSimpleExpression(\n        `on${capitalize(arg.content)}`,\n        true,\n        arg.loc\n      )\n    } else {\n      eventName = createCompoundExpression([`\"on\" + (`, arg, `)`])\n    }\n  } else {\n    // already a compound expression.\n    eventName = arg\n    eventName.children.unshift(`\"on\" + (`)\n    eventName.children.push(`)`)\n  }\n\n  // handler processing\n  let exp: ExpressionNode | undefined = dir.exp\n  let isCacheable: boolean = !exp\n  if (exp) {\n    const isMemberExp = isMemberExpression(exp.content)\n    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))\n\n    // process the expression since it's been skipped\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      context.addIdentifiers(`$event`)\n      exp = processExpression(exp, context)\n      context.removeIdentifiers(`$event`)\n      // with scope analysis, the function is hoistable if it has no reference\n      // to scope variables.\n      isCacheable =\n        context.cacheHandlers && !hasScopeRef(exp, context.identifiers)\n      // If the expression is optimizable and is a member expression pointing\n      // to a function, turn it into invocation (and wrap in an arrow function\n      // below) so that it always accesses the latest value when called - thus\n      // avoiding the need to be patched.\n      if (isCacheable && isMemberExp) {\n        if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          exp.content += `($event)`\n        } else {\n          exp.children.push(`($event)`)\n        }\n      }\n    }\n\n    if (isInlineStatement || (isCacheable && isMemberExp)) {\n      // wrap inline statement in a function expression\n      exp = createCompoundExpression([\n        `$event => (`,\n        ...(exp.type === NodeTypes.SIMPLE_EXPRESSION ? [exp] : exp.children),\n        `)`\n      ])\n    }\n  }\n\n  let ret: DirectiveTransformResult = {\n    props: [\n      createObjectProperty(\n        eventName,\n        exp || createSimpleExpression(`() => {}`, false, loc)\n      )\n    ],\n    needRuntime: false\n  }\n\n  // apply extended compiler augmentor\n  if (augmentor) {\n    ret = augmentor(ret)\n  }\n\n  if (isCacheable) {\n    // cache handlers so that it's always the same handler being passed down.\n    // this avoids unnecessary re-renders when users use inline hanlders on\n    // components.\n    ret.props[0].value = context.cache(ret.props[0].value)\n  }\n\n  return ret\n}\n","import { DirectiveTransform } from '../transform'\nimport { createObjectProperty, createSimpleExpression, NodeTypes } from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { camelize } from '@vue/shared'\nimport { CAMELIZE } from '../runtimeHelpers'\n\n// v-bind without arg is handled directly in ./element.ts due to it affecting\n// codegen for the entire props object. This transform here is only for v-bind\n// *with* args.\nexport const transformBind: DirectiveTransform = (dir, node, context) => {\n  const { exp, modifiers, loc } = dir\n  const arg = dir.arg!\n  if (!exp) {\n    context.onError(createCompilerError(ErrorCodes.X_V_BIND_NO_EXPRESSION, loc))\n  }\n  // .prop is no longer necessary due to new patch behavior\n  // .sync is replaced by v-model:arg\n  if (modifiers.includes('camel')) {\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n      if (arg.isStatic) {\n        arg.content = camelize(arg.content)\n      } else {\n        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`\n      }\n    } else {\n      arg.children.unshift(`${context.helperString(CAMELIZE)}(`)\n      arg.children.push(`)`)\n    }\n  }\n  return {\n    props: [\n      createObjectProperty(arg!, exp || createSimpleExpression('', true, loc))\n    ],\n    needRuntime: false\n  }\n}\n","import { NodeTransform } from '../transform'\nimport {\n  NodeTypes,\n  TemplateChildNode,\n  TextNode,\n  InterpolationNode,\n  CompoundExpressionNode,\n  createCallExpression\n} from '../ast'\nimport { TEXT, CREATE_VNODE } from '../runtimeHelpers'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\n\nconst isText = (\n  node: TemplateChildNode\n): node is TextNode | InterpolationNode =>\n  node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT\n\n// Merge adjacent text nodes and expressions into a single expression\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\nexport const transformText: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.ROOT || node.type === NodeTypes.ELEMENT) {\n    // perform the transform on node exit so that all expressions have already\n    // been processed.\n    return () => {\n      const children = node.children\n      let currentContainer: CompoundExpressionNode | undefined = undefined\n      let hasText = false\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n        if (isText(child)) {\n          hasText = true\n          for (let j = i + 1; j < children.length; j++) {\n            const next = children[j]\n            if (isText(next)) {\n              if (!currentContainer) {\n                currentContainer = children[i] = {\n                  type: NodeTypes.COMPOUND_EXPRESSION,\n                  loc: child.loc,\n                  children: [child]\n                }\n              }\n              // merge adjacent text node into current\n              currentContainer.children.push(` + `, next)\n              children.splice(j, 1)\n              j--\n            } else {\n              currentContainer = undefined\n              break\n            }\n          }\n        }\n      }\n\n      if (hasText && children.length > 1) {\n        // when an element has mixed text/element children, convert text nodes\n        // into createVNode(Text) calls.\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i]\n          if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {\n            const callArgs = [context.helper(TEXT), `null`, child]\n            if (child.type !== NodeTypes.TEXT) {\n              callArgs.push(\n                `${PatchFlags.TEXT} /* ${PatchFlagNames[PatchFlags.TEXT]} */`\n              )\n            }\n            children[i] = {\n              type: NodeTypes.TEXT_CALL,\n              content: child,\n              loc: child.loc,\n              codegenNode: createCallExpression(\n                context.helper(CREATE_VNODE),\n                callArgs\n              )\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import {\n  DirectiveTransform,\n  createObjectProperty,\n  createSimpleExpression\n} from '@vue/compiler-core'\n\nexport const transformOnce: DirectiveTransform = dir => {\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`$once`, true, dir.loc),\n        createSimpleExpression('true', false)\n      )\n    ],\n    needRuntime: false\n  }\n}\n","import { DirectiveTransform } from '../transform'\nimport {\n  createSimpleExpression,\n  createObjectProperty,\n  createCompoundExpression,\n  NodeTypes,\n  Property,\n  ElementTypes\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { isMemberExpression, isSimpleIdentifier, hasScopeRef } from '../utils'\n\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\n  const { exp, arg } = dir\n  if (!exp) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_NO_EXPRESSION, dir.loc)\n    )\n    return createTransformProps()\n  }\n\n  const expString =\n    exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : exp.loc.source\n  if (!isMemberExpression(expString)) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION, exp.loc)\n    )\n    return createTransformProps()\n  }\n\n  if (\n    !__BROWSER__ &&\n    context.prefixIdentifiers &&\n    isSimpleIdentifier(expString) &&\n    context.identifiers[expString]\n  ) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE, exp.loc)\n    )\n    return createTransformProps()\n  }\n\n  const propName = arg ? arg : createSimpleExpression('modelValue', true)\n  const eventName = arg\n    ? arg.type === NodeTypes.SIMPLE_EXPRESSION && arg.isStatic\n      ? createSimpleExpression('onUpdate:' + arg.content, true)\n      : createCompoundExpression([\n          createSimpleExpression('onUpdate:', true),\n          '+',\n          ...(arg.type === NodeTypes.SIMPLE_EXPRESSION ? [arg] : arg.children)\n        ])\n    : createSimpleExpression('onUpdate:modelValue', true)\n\n  const props = [\n    // modelValue: foo\n    createObjectProperty(propName, dir.exp!),\n    // \"onUpdate:modelValue\": $event => (foo = $event)\n    createObjectProperty(\n      eventName,\n      createCompoundExpression([\n        `$event => (`,\n        ...(exp.type === NodeTypes.SIMPLE_EXPRESSION ? [exp] : exp.children),\n        ` = $event)`\n      ])\n    )\n  ]\n\n  // cache v-model handler if applicable (when it doesn't refer any scope vars)\n  if (\n    !__BROWSER__ &&\n    context.prefixIdentifiers &&\n    !hasScopeRef(exp, context.identifiers)\n  ) {\n    props[1].value = context.cache(props[1].value)\n  }\n\n  // modelModifiers: { foo: true, \"bar-baz\": true }\n  if (dir.modifiers.length && node.tagType === ElementTypes.COMPONENT) {\n    const modifiers = dir.modifiers\n      .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\n      .join(`, `)\n    props.push(\n      createObjectProperty(\n        `modelModifiers`,\n        createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, true)\n      )\n    )\n  }\n\n  return createTransformProps(props)\n}\n\nfunction createTransformProps(props: Property[] = []) {\n  return { props, needRuntime: false }\n}\n","const range: number = 2\n\nexport function generateCodeFrame(\n  source: string,\n  start: number = 0,\n  end: number = source.length\n): string {\n  const lines = source.split(/\\r?\\n/)\n  let count = 0\n  const res = []\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue\n        res.push(\n          `${j + 1}${' '.repeat(3 - String(j + 1).length)}|  ${lines[j]}`\n        )\n        const lineLength = lines[j].length\n        if (j === i) {\n          // push underline\n          const pad = start - (count - lineLength) + 1\n          const length = end > count ? lineLength - pad : end - start\n          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length))\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.min(end - count, lineLength)\n            res.push(`   |  ` + '^'.repeat(length))\n          }\n          count += lineLength + 1\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n","import { parse, ParserOptions } from './parse'\nimport { transform, TransformOptions } from './transform'\nimport { generate, CodegenOptions, CodegenResult } from './codegen'\nimport { RootNode } from './ast'\nimport { isString } from '@vue/shared'\nimport { transformIf } from './transforms/vIf'\nimport { transformFor } from './transforms/vFor'\nimport { transformExpression } from './transforms/transformExpression'\nimport { transformSlotOutlet } from './transforms/transformSlotOutlet'\nimport { transformElement } from './transforms/transformElement'\nimport { transformOn } from './transforms/vOn'\nimport { transformBind } from './transforms/vBind'\nimport { defaultOnError, createCompilerError, ErrorCodes } from './errors'\nimport { trackSlotScopes, trackVForSlotScopes } from './transforms/vSlot'\nimport { transformText } from './transforms/transformText'\nimport { transformOnce } from './transforms/vOnce'\nimport { transformModel } from './transforms/vModel'\n\nexport type CompilerOptions = ParserOptions & TransformOptions & CodegenOptions\n\n// we name it `baseCompile` so that higher order compilers like @vue/compiler-dom\n// can export `compile` while re-exporting everything else.\nexport function baseCompile(\n  template: string | RootNode,\n  options: CompilerOptions = {}\n): CodegenResult {\n  /* istanbul ignore if */\n  if (__BROWSER__) {\n    const onError = options.onError || defaultOnError\n    if (options.prefixIdentifiers === true) {\n      onError(createCompilerError(ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED))\n    } else if (options.mode === 'module') {\n      onError(createCompilerError(ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED))\n    }\n  }\n\n  const ast = isString(template) ? parse(template, options) : template\n\n  const prefixIdentifiers =\n    !__BROWSER__ &&\n    (options.prefixIdentifiers === true || options.mode === 'module')\n\n  transform(ast, {\n    ...options,\n    prefixIdentifiers,\n    nodeTransforms: [\n      transformIf,\n      transformFor,\n      ...(prefixIdentifiers\n        ? [\n            // order is important\n            trackVForSlotScopes,\n            transformExpression\n          ]\n        : []),\n      transformSlotOutlet,\n      transformElement,\n      trackSlotScopes,\n      transformText,\n      ...(options.nodeTransforms || []) // user transforms\n    ],\n    directiveTransforms: {\n      on: transformOn,\n      bind: transformBind,\n      once: transformOnce,\n      model: transformModel,\n      ...(options.directiveTransforms || {}) // user transforms\n    }\n  })\n\n  return generate(ast, {\n    ...options,\n    prefixIdentifiers\n  })\n}\n\n// Also expose lower level APIs & types\nexport { parse, ParserOptions, TextModes } from './parse'\nexport {\n  transform,\n  createStructuralDirectiveTransform,\n  TransformOptions,\n  TransformContext,\n  NodeTransform,\n  StructuralDirectiveTransform,\n  DirectiveTransform\n} from './transform'\nexport {\n  generate,\n  CodegenOptions,\n  CodegenContext,\n  CodegenResult\n} from './codegen'\nexport {\n  ErrorCodes,\n  CoreCompilerError,\n  CompilerError,\n  createCompilerError\n} from './errors'\nexport * from './ast'\nexport * from './utils'\nexport * from './codeframe'\nexport { registerRuntimeHelpers } from './runtimeHelpers'\n\n// expose transforms so higher-order compilers can import and extend them\nexport { transformModel } from './transforms/vModel'\nexport { transformOn } from './transforms/vOn'\n"],"names":["isFunction","isText","createObjectProperty","createSimpleExpression"],"mappings":"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"}