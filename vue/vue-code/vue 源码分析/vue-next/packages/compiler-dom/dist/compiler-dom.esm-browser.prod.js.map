{"version":3,"file":"compiler-dom.esm-browser.prod.js","sources":["../../shared/src/patchFlags.ts","../../shared/src/makeMap.ts","../../shared/src/index.ts","../../compiler-core/src/errors.ts","../../compiler-core/src/ast.ts","../../compiler-core/src/runtimeHelpers.ts","../../compiler-core/src/utils.ts","../../compiler-core/src/parse.ts","../../compiler-core/src/transforms/hoistStatic.ts","../../compiler-core/src/transform.ts","../../compiler-core/src/codegen.ts","../../compiler-core/src/transforms/vIf.ts","../../compiler-core/src/transforms/vFor.ts","../../compiler-core/src/transforms/vSlot.ts","../../compiler-core/src/transforms/transformElement.ts","../../compiler-core/src/transforms/transformSlotOutlet.ts","../../compiler-core/src/transforms/vOn.ts","../../compiler-core/src/transforms/vBind.ts","../../compiler-core/src/transforms/transformText.ts","../../compiler-core/src/transforms/vOnce.ts","../../compiler-core/src/transforms/vModel.ts","../../compiler-core/src/codeframe.ts","../../compiler-core/src/index.ts","../src/tagConfig.ts","../src/parserOptionsMinimal.ts","../src/transforms/transformStyle.ts","../src/transforms/vCloak.ts","../src/errors.ts","../src/transforms/vHtml.ts","../src/transforms/vText.ts","../src/runtimeHelpers.ts","../src/transforms/vModel.ts","../src/transforms/vOn.ts","../src/index.ts"],"sourcesContent":["// Patch flags are optimization hints generated by the compiler.\n// when a block with dynamicChildren is encountered during diff, the algorithm\n// enters \"optimized mode\". In this mode, we know that the vdom is produced by\n// a render function generated by the compiler, so the algorithm only needs to\n// handle updates explicitly marked by these patch flags.\n\n// Patch flags can be combined using the | bitwise operator and can be checked\n// using the & operator, e.g.\n//\n//   const flag = TEXT | CLASS\n//   if (flag & TEXT) { ... }\n//\n// Check the `patchElement` function in './createRenderer.ts' to see how the\n// flags are handled during diff.\n\nexport const enum PatchFlags {\n  // Indicates an element with dynamic textContent (children fast path)\n  TEXT = 1,\n\n  // Indicates an element with dynamic class binding.\n  CLASS = 1 << 1,\n\n  // Indicates an element with dynamic style\n  // The compiler pre-compiles static string styles into static objects\n  // + detects and hoists inline static objects\n  // e.g. style=\"color: red\" and :style=\"{ color: 'red' }\" both get hoisted as\n  //   const style = { color: 'red' }\n  //   render() { return e('div', { style }) }\n  STYLE = 1 << 2,\n\n  // Indicates an element that has non-class/style dynamic props.\n  // Can also be on a component that has any dynamic props (includes\n  // class/style). when this flag is present, the vnode also has a dynamicProps\n  // array that contains the keys of the props that may change so the runtime\n  // can diff them faster (without having to worry about removed props)\n  PROPS = 1 << 3,\n\n  // Indicates an element with props with dynamic keys. When keys change, a full\n  // diff is always needed to remove the old key. This flag is mutually\n  // exclusive with CLASS, STYLE and PROPS.\n  FULL_PROPS = 1 << 4,\n\n  // Indicates an element that only needs non-props patching, e.g. ref or\n  // directives (onVnodeXXX hooks). It simply marks the vnode as \"need patch\",\n  // since every patched vnode checks for refs and onVnodeXXX hooks.\n  // This flag is never directly matched against, it simply serves as a non-zero\n  // value.\n  NEED_PATCH = 1 << 5,\n\n  // Indicates a fragment with keyed or partially keyed children\n  KEYED_FRAGMENT = 1 << 6,\n\n  // Indicates a fragment with unkeyed children.\n  UNKEYED_FRAGMENT = 1 << 7,\n\n  // Indicates a component with dynamic slots (e.g. slot that references a v-for\n  // iterated value, or dynamic slot names).\n  // Components with this flag are always force updated.\n  DYNAMIC_SLOTS = 1 << 8,\n\n  // A special flag that indicates that the diffing algorithm should bail out\n  // of optimized mode. This is only on block fragments created by renderSlot()\n  // when encountering non-compiler generated slots (i.e. manually written\n  // render functions, which should always be fully diffed)\n  BAIL = -1\n}\n\n// runtime object for public consumption\nexport const PublicPatchFlags = {\n  TEXT: PatchFlags.TEXT,\n  CLASS: PatchFlags.CLASS,\n  STYLE: PatchFlags.STYLE,\n  PROPS: PatchFlags.PROPS,\n  NEED_PATCH: PatchFlags.NEED_PATCH,\n  FULL_PROPS: PatchFlags.FULL_PROPS,\n  KEYED_FRAGMENT: PatchFlags.KEYED_FRAGMENT,\n  UNKEYED_FRAGMENT: PatchFlags.UNKEYED_FRAGMENT,\n  DYNAMIC_SLOTS: PatchFlags.DYNAMIC_SLOTS,\n  BAIL: PatchFlags.BAIL\n}\n\n// dev only flag -> name mapping\nexport const PatchFlagNames = {\n  [PatchFlags.TEXT]: `TEXT`,\n  [PatchFlags.CLASS]: `CLASS`,\n  [PatchFlags.STYLE]: `STYLE`,\n  [PatchFlags.PROPS]: `PROPS`,\n  [PatchFlags.NEED_PATCH]: `NEED_PATCH`,\n  [PatchFlags.FULL_PROPS]: `FULL_PROPS`,\n  [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`,\n  [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`,\n  [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`,\n  [PatchFlags.BAIL]: `BAIL`\n}\n","// Make a map and return a function for checking if a key\n// is in that map.\n//\n// IMPORTANT: all calls of this function must be prefixed with /*#__PURE__*/\n// So that rollup can tree-shake them if necessary.\nexport function makeMap(\n  str: string,\n  expectsLowerCase?: boolean\n): (key: string) => boolean {\n  const map: Record<string, boolean> = Object.create(null)\n  const list: Array<string> = str.split(',')\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\n}\n","export * from './patchFlags'\nexport { isGloballyWhitelisted } from './globalsWhitelist'\nexport { makeMap } from './makeMap'\n\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\n  ? Object.freeze({})\n  : {}\nexport const EMPTY_ARR: [] = []\n\nexport const NOOP = () => {}\n\n/**\n * Always return false.\n */\nexport const NO = () => false\n\nexport const isOn = (key: string) => key[0] === 'o' && key[1] === 'n'\n\nexport const extend = <T extends object, U extends object>(\n  a: T,\n  b: U\n): T & U => {\n  for (const key in b) {\n    ;(a as any)[key] = b[key]\n  }\n  return a as any\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const isArray = Array.isArray\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === 'function'\nexport const isString = (val: unknown): val is string => typeof val === 'string'\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport function isPromise<T = any>(val: unknown): val is Promise<T> {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\n}\n\nexport const objectToString = Object.prototype.toString\nexport const toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\nexport const isPlainObject = (val: unknown): val is object =>\n  toTypeString(val) === '[object Object]'\n\nexport const isReservedProp = (key: string): boolean =>\n  key === 'key' || key === 'ref' || key === '$once' || key.startsWith(`onVnode`)\n\nconst camelizeRE = /-(\\w)/g\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\n}\n\nconst hyphenateRE = /\\B([A-Z])/g\nexport const hyphenate = (str: string): string => {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n}\n\nexport const capitalize = (str: string): string => {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n","import { SourceLocation } from './ast'\n\nexport interface CompilerError extends SyntaxError {\n  code: number\n  loc?: SourceLocation\n}\n\nexport interface CoreCompilerError extends CompilerError {\n  code: ErrorCodes\n}\n\nexport function defaultOnError(error: CompilerError) {\n  throw error\n}\n\nexport function createCompilerError<T extends number>(\n  code: T,\n  loc?: SourceLocation,\n  messages?: { [code: number]: string }\n): T extends ErrorCodes ? CoreCompilerError : CompilerError {\n  const msg = __DEV__ || !__BROWSER__ ? (messages || errorMessages)[code] : code\n  const locInfo = loc ? ` (${loc.start.line}:${loc.start.column})` : ``\n  const error = new SyntaxError(msg + locInfo) as CompilerError\n  error.code = code\n  error.loc = loc\n  return error as any\n}\n\nexport const enum ErrorCodes {\n  // parse errors\n  ABRUPT_CLOSING_OF_EMPTY_COMMENT,\n  ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE,\n  CDATA_IN_HTML_CONTENT,\n  CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE,\n  CONTROL_CHARACTER_REFERENCE,\n  DUPLICATE_ATTRIBUTE,\n  END_TAG_WITH_ATTRIBUTES,\n  END_TAG_WITH_TRAILING_SOLIDUS,\n  EOF_BEFORE_TAG_NAME,\n  EOF_IN_CDATA,\n  EOF_IN_COMMENT,\n  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT,\n  EOF_IN_TAG,\n  INCORRECTLY_CLOSED_COMMENT,\n  INCORRECTLY_OPENED_COMMENT,\n  INVALID_FIRST_CHARACTER_OF_TAG_NAME,\n  MISSING_ATTRIBUTE_VALUE,\n  MISSING_END_TAG_NAME,\n  MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE,\n  MISSING_WHITESPACE_BETWEEN_ATTRIBUTES,\n  NESTED_COMMENT,\n  NONCHARACTER_CHARACTER_REFERENCE,\n  NULL_CHARACTER_REFERENCE,\n  SURROGATE_CHARACTER_REFERENCE,\n  UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\n  UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\n  UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME,\n  UNEXPECTED_NULL_CHARACTER,\n  UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\n  UNEXPECTED_SOLIDUS_IN_TAG,\n  UNKNOWN_NAMED_CHARACTER_REFERENCE,\n\n  // Vue-specific parse errors\n  X_INVALID_END_TAG,\n  X_MISSING_END_TAG,\n  X_MISSING_INTERPOLATION_END,\n  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END,\n\n  // transform errors\n  X_V_IF_NO_EXPRESSION,\n  X_V_ELSE_NO_ADJACENT_IF,\n  X_V_FOR_NO_EXPRESSION,\n  X_V_FOR_MALFORMED_EXPRESSION,\n  X_V_BIND_NO_EXPRESSION,\n  X_V_ON_NO_EXPRESSION,\n  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\n  X_V_SLOT_NAMED_SLOT_ON_COMPONENT,\n  X_V_SLOT_MIXED_SLOT_USAGE,\n  X_V_SLOT_DUPLICATE_SLOT_NAMES,\n  X_V_SLOT_EXTRANEOUS_NON_SLOT_CHILDREN,\n  X_V_SLOT_MISPLACED,\n  X_V_MODEL_NO_EXPRESSION,\n  X_V_MODEL_MALFORMED_EXPRESSION,\n  X_V_MODEL_ON_SCOPE_VARIABLE,\n  X_INVALID_EXPRESSION,\n\n  // generic errors\n  X_PREFIX_ID_NOT_SUPPORTED,\n  X_MODULE_MODE_NOT_SUPPORTED,\n\n  // Special value for higher-order compilers to pick up the last code\n  // to avoid collision of error codes. This should always be kept as the last\n  // item.\n  __EXTEND_POINT__\n}\n\nexport const errorMessages: { [code: number]: string } = {\n  // parse errors\n  [ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT]: 'Illegal comment.',\n  [ErrorCodes.ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: invalid character.',\n  [ErrorCodes.CDATA_IN_HTML_CONTENT]:\n    'CDATA section is allowed only in XML context.',\n  [ErrorCodes.CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE]:\n    'Illegal numeric character reference: too big.',\n  [ErrorCodes.CONTROL_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: control character.',\n  [ErrorCodes.DUPLICATE_ATTRIBUTE]: 'Duplicate attribute.',\n  [ErrorCodes.END_TAG_WITH_ATTRIBUTES]: 'End tag cannot have attributes.',\n  [ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS]: \"Illegal '/' in tags.\",\n  [ErrorCodes.EOF_BEFORE_TAG_NAME]: 'Unexpected EOF in tag.',\n  [ErrorCodes.EOF_IN_CDATA]: 'Unexpected EOF in CDATA section.',\n  [ErrorCodes.EOF_IN_COMMENT]: 'Unexpected EOF in comment.',\n  [ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT]:\n    'Unexpected EOF in script.',\n  [ErrorCodes.EOF_IN_TAG]: 'Unexpected EOF in tag.',\n  [ErrorCodes.INCORRECTLY_CLOSED_COMMENT]: 'Incorrectly closed comment.',\n  [ErrorCodes.INCORRECTLY_OPENED_COMMENT]: 'Incorrectly opened comment.',\n  [ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME]:\n    \"Illegal tag name. Use '&lt;' to print '<'.\",\n  [ErrorCodes.MISSING_ATTRIBUTE_VALUE]: 'Attribute value was expected.',\n  [ErrorCodes.MISSING_END_TAG_NAME]: 'End tag name was expected.',\n  [ErrorCodes.MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE]:\n    'Semicolon was expected.',\n  [ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES]:\n    'Whitespace was expected.',\n  [ErrorCodes.NESTED_COMMENT]: \"Unexpected '<!--' in comment.\",\n  [ErrorCodes.NONCHARACTER_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: non character.',\n  [ErrorCodes.NULL_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: null character.',\n  [ErrorCodes.SURROGATE_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: non-pair surrogate.',\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME]:\n    'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE]:\n    'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\n  [ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME]:\n    \"Attribute name cannot start with '='.\",\n  [ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME]:\n    \"'<?' is allowed only in XML context.\",\n  [ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG]: \"Illegal '/' in tags.\",\n  [ErrorCodes.UNKNOWN_NAMED_CHARACTER_REFERENCE]: 'Unknown entity name.',\n\n  // Vue-specific parse errors\n  [ErrorCodes.X_INVALID_END_TAG]: 'Invalid end tag.',\n  [ErrorCodes.X_MISSING_END_TAG]: 'End tag was not found.',\n  [ErrorCodes.X_MISSING_INTERPOLATION_END]:\n    'Interpolation end sign was not found.',\n  [ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END]:\n    'End bracket for dynamic directive argument was not found. ' +\n    'Note that dynamic directive argument cannot contain spaces.',\n\n  // transform errors\n  [ErrorCodes.X_V_IF_NO_EXPRESSION]: `v-if/v-else-if is missing expression.`,\n  [ErrorCodes.X_V_ELSE_NO_ADJACENT_IF]: `v-else/v-else-if has no adjacent v-if.`,\n  [ErrorCodes.X_V_FOR_NO_EXPRESSION]: `v-for is missing expression.`,\n  [ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION]: `v-for has invalid expression.`,\n  [ErrorCodes.X_V_BIND_NO_EXPRESSION]: `v-bind is missing expression.`,\n  [ErrorCodes.X_V_ON_NO_EXPRESSION]: `v-on is missing expression.`,\n  [ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET]: `Unexpected custom directive on <slot> outlet.`,\n  [ErrorCodes.X_V_SLOT_NAMED_SLOT_ON_COMPONENT]:\n    `Named v-slot on component. ` +\n    `Named slots should use <template v-slot> syntax nested inside the component.`,\n  [ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE]:\n    `Mixed v-slot usage on both the component and nested <template>.` +\n    `The default slot should also use <template> syntax when there are other ` +\n    `named slots to avoid scope ambiguity.`,\n  [ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES]: `Duplicate slot names found. `,\n  [ErrorCodes.X_V_SLOT_EXTRANEOUS_NON_SLOT_CHILDREN]:\n    `Extraneous children found when component has explicit slots. ` +\n    `These children will be ignored.`,\n  [ErrorCodes.X_V_SLOT_MISPLACED]: `v-slot can only be used on components or <template> tags.`,\n  [ErrorCodes.X_V_MODEL_NO_EXPRESSION]: `v-model is missing expression.`,\n  [ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION]: `v-model value must be a valid JavaScript member expression.`,\n  [ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\n  [ErrorCodes.X_INVALID_EXPRESSION]: `Invalid JavaScript expression.`,\n\n  // generic errors\n  [ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\n  [ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED]: `ES module mode is not supported in this build of compiler.`\n}\n","import { isString } from '@vue/shared'\nimport { ForParseResult } from './transforms/vFor'\nimport {\n  CREATE_VNODE,\n  WITH_DIRECTIVES,\n  RENDER_SLOT,\n  CREATE_SLOTS,\n  RENDER_LIST,\n  OPEN_BLOCK,\n  CREATE_BLOCK,\n  FRAGMENT\n} from './runtimeHelpers'\nimport { PropsExpression } from './transforms/transformElement'\n\n// Vue template is a platform-agnostic superset of HTML (syntax only).\n// More namespaces like SVG and MathML are declared by platform specific\n// compilers.\nexport type Namespace = number\n\nexport const enum Namespaces {\n  HTML\n}\n\nexport const enum NodeTypes {\n  ROOT,\n  ELEMENT,\n  TEXT,\n  COMMENT,\n  SIMPLE_EXPRESSION,\n  INTERPOLATION,\n  ATTRIBUTE,\n  DIRECTIVE,\n  // containers\n  COMPOUND_EXPRESSION,\n  IF,\n  IF_BRANCH,\n  FOR,\n  TEXT_CALL,\n  // codegen\n  JS_CALL_EXPRESSION,\n  JS_OBJECT_EXPRESSION,\n  JS_PROPERTY,\n  JS_ARRAY_EXPRESSION,\n  JS_FUNCTION_EXPRESSION,\n  JS_SEQUENCE_EXPRESSION,\n  JS_CONDITIONAL_EXPRESSION,\n  JS_CACHE_EXPRESSION\n}\n\nexport const enum ElementTypes {\n  ELEMENT,\n  COMPONENT,\n  SLOT,\n  TEMPLATE,\n  PORTAL,\n  SUSPENSE\n}\n\nexport interface Node {\n  type: NodeTypes\n  loc: SourceLocation\n}\n\n// The node's range. The `start` is inclusive and `end` is exclusive.\n// [start, end)\nexport interface SourceLocation {\n  start: Position\n  end: Position\n  source: string\n}\n\nexport interface Position {\n  offset: number // from start of file\n  line: number\n  column: number\n}\n\nexport type ParentNode = RootNode | ElementNode | IfBranchNode | ForNode\n\nexport type ExpressionNode = SimpleExpressionNode | CompoundExpressionNode\n\nexport type TemplateChildNode =\n  | ElementNode\n  | InterpolationNode\n  | CompoundExpressionNode\n  | TextNode\n  | CommentNode\n  | IfNode\n  | ForNode\n  | TextCallNode\n\nexport interface RootNode extends Node {\n  type: NodeTypes.ROOT\n  children: TemplateChildNode[]\n  helpers: symbol[]\n  components: string[]\n  directives: string[]\n  hoists: JSChildNode[]\n  cached: number\n  codegenNode: TemplateChildNode | JSChildNode | undefined\n}\n\nexport type ElementNode =\n  | PlainElementNode\n  | ComponentNode\n  | SlotOutletNode\n  | TemplateNode\n  | PortalNode\n  | SuspenseNode\n\nexport interface BaseElementNode extends Node {\n  type: NodeTypes.ELEMENT\n  ns: Namespace\n  tag: string\n  tagType: ElementTypes\n  isSelfClosing: boolean\n  props: Array<AttributeNode | DirectiveNode>\n  children: TemplateChildNode[]\n  codegenNode: CallExpression | SimpleExpressionNode | undefined\n}\n\nexport interface PlainElementNode extends BaseElementNode {\n  tagType: ElementTypes.ELEMENT\n  codegenNode: ElementCodegenNode | undefined | SimpleExpressionNode // only when hoisted\n}\n\nexport interface ComponentNode extends BaseElementNode {\n  tagType: ElementTypes.COMPONENT\n  codegenNode: ComponentCodegenNode | undefined\n}\n\nexport interface SlotOutletNode extends BaseElementNode {\n  tagType: ElementTypes.SLOT\n  codegenNode: SlotOutletCodegenNode | undefined\n}\n\nexport interface TemplateNode extends BaseElementNode {\n  tagType: ElementTypes.TEMPLATE\n  codegenNode:\n    | ElementCodegenNode\n    | CodegenNodeWithDirective<ElementCodegenNode>\n    | undefined\n}\n\nexport interface PortalNode extends BaseElementNode {\n  tagType: ElementTypes.PORTAL\n  codegenNode: ElementCodegenNode | undefined\n}\n\nexport interface SuspenseNode extends BaseElementNode {\n  tagType: ElementTypes.SUSPENSE\n  codegenNode: ElementCodegenNode | undefined\n}\n\nexport interface TextNode extends Node {\n  type: NodeTypes.TEXT\n  content: string\n  isEmpty: boolean\n}\n\nexport interface CommentNode extends Node {\n  type: NodeTypes.COMMENT\n  content: string\n}\n\nexport interface AttributeNode extends Node {\n  type: NodeTypes.ATTRIBUTE\n  name: string\n  value: TextNode | undefined\n}\n\nexport interface DirectiveNode extends Node {\n  type: NodeTypes.DIRECTIVE\n  name: string\n  exp: ExpressionNode | undefined\n  arg: ExpressionNode | undefined\n  modifiers: string[]\n  // optional property to cache the expression parse result for v-for\n  parseResult?: ForParseResult\n}\n\nexport interface SimpleExpressionNode extends Node {\n  type: NodeTypes.SIMPLE_EXPRESSION\n  content: string\n  isStatic: boolean\n  isConstant: boolean\n  // an expression parsed as the params of a function will track\n  // the identifiers declared inside the function body.\n  identifiers?: string[]\n}\n\nexport interface InterpolationNode extends Node {\n  type: NodeTypes.INTERPOLATION\n  content: ExpressionNode\n}\n\nexport interface CompoundExpressionNode extends Node {\n  type: NodeTypes.COMPOUND_EXPRESSION\n  children: (\n    | SimpleExpressionNode\n    | InterpolationNode\n    | TextNode\n    | string\n    | symbol)[]\n  // an expression parsed as the params of a function will track\n  // the identifiers declared inside the function body.\n  identifiers?: string[]\n}\n\nexport interface IfNode extends Node {\n  type: NodeTypes.IF\n  branches: IfBranchNode[]\n  codegenNode: IfCodegenNode\n}\n\nexport interface IfBranchNode extends Node {\n  type: NodeTypes.IF_BRANCH\n  condition: ExpressionNode | undefined // else\n  children: TemplateChildNode[]\n}\n\nexport interface ForNode extends Node {\n  type: NodeTypes.FOR\n  source: ExpressionNode\n  valueAlias: ExpressionNode | undefined\n  keyAlias: ExpressionNode | undefined\n  objectIndexAlias: ExpressionNode | undefined\n  children: TemplateChildNode[]\n  codegenNode: ForCodegenNode\n}\n\nexport interface TextCallNode extends Node {\n  type: NodeTypes.TEXT_CALL\n  content: TextNode | InterpolationNode | CompoundExpressionNode\n  codegenNode: CallExpression\n}\n\n// We also include a number of JavaScript AST nodes for code generation.\n// The AST is an intentionally minimal subset just to meet the exact needs of\n// Vue render function generation.\nexport type JSChildNode =\n  | CallExpression\n  | ObjectExpression\n  | ArrayExpression\n  | ExpressionNode\n  | FunctionExpression\n  | ConditionalExpression\n  | SequenceExpression\n  | CacheExpression\n\nexport interface CallExpression extends Node {\n  type: NodeTypes.JS_CALL_EXPRESSION\n  callee: string | symbol\n  arguments: (\n    | string\n    | symbol\n    | JSChildNode\n    | TemplateChildNode\n    | TemplateChildNode[])[]\n}\n\nexport interface ObjectExpression extends Node {\n  type: NodeTypes.JS_OBJECT_EXPRESSION\n  properties: Array<Property>\n}\n\nexport interface Property extends Node {\n  type: NodeTypes.JS_PROPERTY\n  key: ExpressionNode\n  value: JSChildNode\n}\n\nexport interface ArrayExpression extends Node {\n  type: NodeTypes.JS_ARRAY_EXPRESSION\n  elements: Array<string | JSChildNode>\n}\n\nexport interface FunctionExpression extends Node {\n  type: NodeTypes.JS_FUNCTION_EXPRESSION\n  params: ExpressionNode | ExpressionNode[] | undefined\n  returns: TemplateChildNode | TemplateChildNode[] | JSChildNode\n  newline: boolean\n}\n\nexport interface SequenceExpression extends Node {\n  type: NodeTypes.JS_SEQUENCE_EXPRESSION\n  expressions: JSChildNode[]\n}\n\nexport interface ConditionalExpression extends Node {\n  type: NodeTypes.JS_CONDITIONAL_EXPRESSION\n  test: ExpressionNode\n  consequent: JSChildNode\n  alternate: JSChildNode\n}\n\nexport interface CacheExpression extends Node {\n  type: NodeTypes.JS_CACHE_EXPRESSION\n  index: number\n  value: JSChildNode\n}\n\n// Codegen Node Types ----------------------------------------------------------\n\n// createVNode(...)\nexport interface PlainElementCodegenNode extends CallExpression {\n  callee: typeof CREATE_VNODE | typeof CREATE_BLOCK\n  arguments:  // tag, props, children, patchFlag, dynamicProps\n    | [string | symbol]\n    | [string | symbol, PropsExpression]\n    | [string | symbol, 'null' | PropsExpression, TemplateChildNode[]]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | TemplateChildNode[],\n        string\n      ]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | TemplateChildNode[],\n        string,\n        string\n      ]\n}\n\nexport type ElementCodegenNode =\n  | PlainElementCodegenNode\n  | CodegenNodeWithDirective<PlainElementCodegenNode>\n\n// createVNode(...)\nexport interface PlainComponentCodegenNode extends CallExpression {\n  callee: typeof CREATE_VNODE | typeof CREATE_BLOCK\n  arguments:  // Comp, props, slots, patchFlag, dynamicProps\n    | [string | symbol]\n    | [string | symbol, PropsExpression]\n    | [string | symbol, 'null' | PropsExpression, SlotsExpression]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | SlotsExpression,\n        string\n      ]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | SlotsExpression,\n        string,\n        string\n      ]\n}\n\nexport type ComponentCodegenNode =\n  | PlainComponentCodegenNode\n  | CodegenNodeWithDirective<PlainComponentCodegenNode>\n\nexport type SlotsExpression = SlotsObjectExpression | DynamicSlotsExpression\n\n// { foo: () => [...] }\nexport interface SlotsObjectExpression extends ObjectExpression {\n  properties: SlotsObjectProperty[]\n}\n\nexport interface SlotsObjectProperty extends Property {\n  value: SlotFunctionExpression\n}\n\nexport interface SlotFunctionExpression extends FunctionExpression {\n  returns: TemplateChildNode[]\n}\n\n// createSlots({ ... }, [\n//    foo ? () => [] : undefined,\n//    renderList(list, i => () => [i])\n// ])\nexport interface DynamicSlotsExpression extends CallExpression {\n  callee: typeof CREATE_SLOTS\n  arguments: [SlotsObjectExpression, DynamicSlotEntries]\n}\n\nexport interface DynamicSlotEntries extends ArrayExpression {\n  elements: (ConditionalDynamicSlotNode | ListDynamicSlotNode)[]\n}\n\nexport interface ConditionalDynamicSlotNode extends ConditionalExpression {\n  consequent: DynamicSlotNode\n  alternate: DynamicSlotNode | SimpleExpressionNode\n}\n\nexport interface ListDynamicSlotNode extends CallExpression {\n  callee: typeof RENDER_LIST\n  arguments: [ExpressionNode, ListDynamicSlotIterator]\n}\n\nexport interface ListDynamicSlotIterator extends FunctionExpression {\n  returns: DynamicSlotNode\n}\n\nexport interface DynamicSlotNode extends ObjectExpression {\n  properties: [Property, DynamicSlotFnProperty]\n}\n\nexport interface DynamicSlotFnProperty extends Property {\n  value: SlotFunctionExpression\n}\n\n// withDirectives(createVNode(...), [\n//    [_directive_foo, someValue],\n//    [_directive_bar, someValue, \"arg\", { mod: true }]\n// ])\nexport interface CodegenNodeWithDirective<T extends CallExpression>\n  extends CallExpression {\n  callee: typeof WITH_DIRECTIVES\n  arguments: [T, DirectiveArguments]\n}\n\nexport interface DirectiveArguments extends ArrayExpression {\n  elements: DirectiveArgumentNode[]\n}\n\nexport interface DirectiveArgumentNode extends ArrayExpression {\n  elements:  // dir, exp, arg, modifiers\n    | [string]\n    | [string, ExpressionNode]\n    | [string, ExpressionNode, ExpressionNode]\n    | [string, ExpressionNode, ExpressionNode, ObjectExpression]\n}\n\n// renderSlot(...)\nexport interface SlotOutletCodegenNode extends CallExpression {\n  callee: typeof RENDER_SLOT\n  arguments:  // $slots, name, props, fallback\n    | [string, string | ExpressionNode]\n    | [string, string | ExpressionNode, PropsExpression]\n    | [\n        string,\n        string | ExpressionNode,\n        PropsExpression | '{}',\n        TemplateChildNode[]\n      ]\n}\n\nexport type BlockCodegenNode =\n  | ElementCodegenNode\n  | ComponentCodegenNode\n  | SlotOutletCodegenNode\n\nexport interface IfCodegenNode extends SequenceExpression {\n  expressions: [OpenBlockExpression, IfConditionalExpression]\n}\n\nexport interface IfConditionalExpression extends ConditionalExpression {\n  consequent: BlockCodegenNode\n  alternate: BlockCodegenNode | IfConditionalExpression\n}\n\nexport interface ForCodegenNode extends SequenceExpression {\n  expressions: [OpenBlockExpression, ForBlockCodegenNode]\n}\n\nexport interface ForBlockCodegenNode extends CallExpression {\n  callee: typeof CREATE_BLOCK\n  arguments: [typeof FRAGMENT, 'null', ForRenderListExpression, string]\n}\n\nexport interface ForRenderListExpression extends CallExpression {\n  callee: typeof RENDER_LIST\n  arguments: [ExpressionNode, ForIteratorExpression]\n}\n\nexport interface ForIteratorExpression extends FunctionExpression {\n  returns: BlockCodegenNode\n}\n\nexport interface OpenBlockExpression extends CallExpression {\n  callee: typeof OPEN_BLOCK\n  arguments: []\n}\n\n// AST Utilities ---------------------------------------------------------------\n\n// Some expressions, e.g. sequence and conditional expressions, are never\n// associated with template nodes, so their source locations are just a stub.\n// Container types like CompoundExpression also don't need a real location.\nexport const locStub: SourceLocation = {\n  source: '',\n  start: { line: 1, column: 1, offset: 0 },\n  end: { line: 1, column: 1, offset: 0 }\n}\n\nexport function createArrayExpression(\n  elements: ArrayExpression['elements'],\n  loc: SourceLocation = locStub\n): ArrayExpression {\n  return {\n    type: NodeTypes.JS_ARRAY_EXPRESSION,\n    loc,\n    elements\n  }\n}\n\nexport function createObjectExpression(\n  properties: ObjectExpression['properties'],\n  loc: SourceLocation = locStub\n): ObjectExpression {\n  return {\n    type: NodeTypes.JS_OBJECT_EXPRESSION,\n    loc,\n    properties\n  }\n}\n\nexport function createObjectProperty(\n  key: Property['key'] | string,\n  value: Property['value']\n): Property {\n  return {\n    type: NodeTypes.JS_PROPERTY,\n    loc: locStub,\n    key: isString(key) ? createSimpleExpression(key, true) : key,\n    value\n  }\n}\n\nexport function createSimpleExpression(\n  content: SimpleExpressionNode['content'],\n  isStatic: SimpleExpressionNode['isStatic'],\n  loc: SourceLocation = locStub,\n  isConstant: boolean = false\n): SimpleExpressionNode {\n  return {\n    type: NodeTypes.SIMPLE_EXPRESSION,\n    loc,\n    isConstant,\n    content,\n    isStatic\n  }\n}\n\nexport function createInterpolation(\n  content: InterpolationNode['content'] | string,\n  loc: SourceLocation\n): InterpolationNode {\n  return {\n    type: NodeTypes.INTERPOLATION,\n    loc,\n    content: isString(content)\n      ? createSimpleExpression(content, false, loc)\n      : content\n  }\n}\n\nexport function createCompoundExpression(\n  children: CompoundExpressionNode['children'],\n  loc: SourceLocation = locStub\n): CompoundExpressionNode {\n  return {\n    type: NodeTypes.COMPOUND_EXPRESSION,\n    loc,\n    children\n  }\n}\n\ntype InferCodegenNodeType<T> = T extends\n  | typeof CREATE_VNODE\n  | typeof CREATE_BLOCK\n  ? PlainElementCodegenNode | PlainComponentCodegenNode\n  : T extends typeof WITH_DIRECTIVES\n    ?\n        | CodegenNodeWithDirective<PlainElementCodegenNode>\n        | CodegenNodeWithDirective<PlainComponentCodegenNode>\n    : T extends typeof RENDER_SLOT ? SlotOutletCodegenNode : CallExpression\n\nexport function createCallExpression<T extends CallExpression['callee']>(\n  callee: T,\n  args: CallExpression['arguments'] = [],\n  loc: SourceLocation = locStub\n): InferCodegenNodeType<T> {\n  return {\n    type: NodeTypes.JS_CALL_EXPRESSION,\n    loc,\n    callee,\n    arguments: args\n  } as any\n}\n\nexport function createFunctionExpression(\n  params: FunctionExpression['params'],\n  returns: FunctionExpression['returns'],\n  newline: boolean = false,\n  loc: SourceLocation = locStub\n): FunctionExpression {\n  return {\n    type: NodeTypes.JS_FUNCTION_EXPRESSION,\n    params,\n    returns,\n    newline,\n    loc\n  }\n}\n\nexport function createSequenceExpression(\n  expressions: SequenceExpression['expressions']\n): SequenceExpression {\n  return {\n    type: NodeTypes.JS_SEQUENCE_EXPRESSION,\n    expressions,\n    loc: locStub\n  }\n}\n\nexport function createConditionalExpression(\n  test: ConditionalExpression['test'],\n  consequent: ConditionalExpression['consequent'],\n  alternate: ConditionalExpression['alternate']\n): ConditionalExpression {\n  return {\n    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n    test,\n    consequent,\n    alternate,\n    loc: locStub\n  }\n}\n\nexport function createCacheExpression(\n  index: number,\n  value: JSChildNode\n): CacheExpression {\n  return {\n    type: NodeTypes.JS_CACHE_EXPRESSION,\n    index,\n    value,\n    loc: locStub\n  }\n}\n","export const FRAGMENT = Symbol(__DEV__ ? `Fragment` : ``)\nexport const PORTAL = Symbol(__DEV__ ? `Portal` : ``)\nexport const COMMENT = Symbol(__DEV__ ? `Comment` : ``)\nexport const TEXT = Symbol(__DEV__ ? `Text` : ``)\nexport const SUSPENSE = Symbol(__DEV__ ? `Suspense` : ``)\nexport const OPEN_BLOCK = Symbol(__DEV__ ? `openBlock` : ``)\nexport const CREATE_BLOCK = Symbol(__DEV__ ? `createBlock` : ``)\nexport const CREATE_VNODE = Symbol(__DEV__ ? `createVNode` : ``)\nexport const RESOLVE_COMPONENT = Symbol(__DEV__ ? `resolveComponent` : ``)\nexport const RESOLVE_DYNAMIC_COMPONENT = Symbol(\n  __DEV__ ? `resolveDynamicComponent` : ``\n)\nexport const RESOLVE_DIRECTIVE = Symbol(__DEV__ ? `resolveDirective` : ``)\nexport const WITH_DIRECTIVES = Symbol(__DEV__ ? `withDirectives` : ``)\nexport const RENDER_LIST = Symbol(__DEV__ ? `renderList` : ``)\nexport const RENDER_SLOT = Symbol(__DEV__ ? `renderSlot` : ``)\nexport const CREATE_SLOTS = Symbol(__DEV__ ? `createSlots` : ``)\nexport const TO_STRING = Symbol(__DEV__ ? `toString` : ``)\nexport const MERGE_PROPS = Symbol(__DEV__ ? `mergeProps` : ``)\nexport const TO_HANDLERS = Symbol(__DEV__ ? `toHandlers` : ``)\nexport const CAMELIZE = Symbol(__DEV__ ? `camelize` : ``)\n\n// Name mapping for runtime helpers that need to be imported from 'vue' in\n// generated code. Make sure these are correctly exported in the runtime!\n// Using `any` here because TS doesn't allow symbols as index type.\nexport const helperNameMap: any = {\n  [FRAGMENT]: `Fragment`,\n  [PORTAL]: `Portal`,\n  [COMMENT]: `Comment`,\n  [TEXT]: `Text`,\n  [SUSPENSE]: `Suspense`,\n  [OPEN_BLOCK]: `openBlock`,\n  [CREATE_BLOCK]: `createBlock`,\n  [CREATE_VNODE]: `createVNode`,\n  [RESOLVE_COMPONENT]: `resolveComponent`,\n  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\n  [RESOLVE_DIRECTIVE]: `resolveDirective`,\n  [WITH_DIRECTIVES]: `withDirectives`,\n  [RENDER_LIST]: `renderList`,\n  [RENDER_SLOT]: `renderSlot`,\n  [CREATE_SLOTS]: `createSlots`,\n  [TO_STRING]: `toString`,\n  [MERGE_PROPS]: `mergeProps`,\n  [TO_HANDLERS]: `toHandlers`,\n  [CAMELIZE]: `camelize`\n}\n\nexport function registerRuntimeHelpers(helpers: any) {\n  Object.getOwnPropertySymbols(helpers).forEach(s => {\n    helperNameMap[s] = helpers[s]\n  })\n}\n","import {\n  SourceLocation,\n  Position,\n  ElementNode,\n  NodeTypes,\n  CallExpression,\n  SequenceExpression,\n  createSequenceExpression,\n  createCallExpression,\n  DirectiveNode,\n  ElementTypes,\n  TemplateChildNode,\n  RootNode,\n  ObjectExpression,\n  Property,\n  JSChildNode,\n  createObjectExpression,\n  SlotOutletNode,\n  TemplateNode,\n  BlockCodegenNode,\n  ElementCodegenNode,\n  SlotOutletCodegenNode,\n  ComponentCodegenNode,\n  ExpressionNode,\n  IfBranchNode\n} from './ast'\nimport { parse } from 'acorn'\nimport { walk } from 'estree-walker'\nimport { TransformContext } from './transform'\nimport { OPEN_BLOCK, MERGE_PROPS, RENDER_SLOT } from './runtimeHelpers'\nimport { isString, isFunction, isObject } from '@vue/shared'\n\n// cache node requires\n// lazy require dependencies so that they don't end up in rollup's dep graph\n// and thus can be tree-shaken in browser builds.\nlet _parse: typeof parse\nlet _walk: typeof walk\n\nexport function loadDep(name: string) {\n  if (typeof process !== 'undefined' && isFunction(require)) {\n    return require(name)\n  } else {\n    // This is only used when we are building a dev-only build of the compiler\n    // which runs in the browser but also uses Node deps.\n    return (window as any)._deps[name]\n  }\n}\n\nexport const parseJS: typeof parse = (code, options) => {\n  assert(\n    !__BROWSER__,\n    `Expression AST analysis can only be performed in non-browser builds.`\n  )\n  const parse = _parse || (_parse = loadDep('acorn').parse)\n  return parse(code, options)\n}\n\nexport const walkJS: typeof walk = (ast, walker) => {\n  assert(\n    !__BROWSER__,\n    `Expression AST analysis can only be performed in non-browser builds.`\n  )\n  const walk = _walk || (_walk = loadDep('estree-walker').walk)\n  return walk(ast, walker)\n}\n\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/\nexport const isSimpleIdentifier = (name: string): boolean =>\n  !nonIdentifierRE.test(name)\n\nconst memberExpRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\[[^\\]]+\\])*$/\nexport const isMemberExpression = (path: string): boolean =>\n  memberExpRE.test(path)\n\nexport function getInnerRange(\n  loc: SourceLocation,\n  offset: number,\n  length?: number\n): SourceLocation {\n  __DEV__ && assert(offset <= loc.source.length)\n  const source = loc.source.substr(offset, length)\n  const newLoc: SourceLocation = {\n    source,\n    start: advancePositionWithClone(loc.start, loc.source, offset),\n    end: loc.end\n  }\n\n  if (length != null) {\n    __DEV__ && assert(offset + length <= loc.source.length)\n    newLoc.end = advancePositionWithClone(\n      loc.start,\n      loc.source,\n      offset + length\n    )\n  }\n\n  return newLoc\n}\n\nexport function advancePositionWithClone(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number = source.length\n): Position {\n  return advancePositionWithMutation({ ...pos }, source, numberOfCharacters)\n}\n\n// advance by mutation without cloning (for performance reasons), since this\n// gets called a lot in the parser\nexport function advancePositionWithMutation(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number = source.length\n): Position {\n  let linesCount = 0\n  let lastNewLinePos = -1\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10 /* newline char code */) {\n      linesCount++\n      lastNewLinePos = i\n    }\n  }\n\n  pos.offset += numberOfCharacters\n  pos.line += linesCount\n  pos.column =\n    lastNewLinePos === -1\n      ? pos.column + numberOfCharacters\n      : Math.max(1, numberOfCharacters - lastNewLinePos)\n\n  return pos\n}\n\nexport function assert(condition: boolean, msg?: string) {\n  /* istanbul ignore if */\n  if (!condition) {\n    throw new Error(msg || `unexpected compiler condition`)\n  }\n}\n\nexport function findDir(\n  node: ElementNode,\n  name: string | RegExp,\n  allowEmpty: boolean = false\n): DirectiveNode | undefined {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (\n      p.type === NodeTypes.DIRECTIVE &&\n      (allowEmpty || p.exp) &&\n      (isString(name) ? p.name === name : name.test(p.name))\n    ) {\n      return p\n    }\n  }\n}\n\nexport function findProp(\n  node: ElementNode,\n  name: string,\n  dynamicOnly: boolean = false\n): ElementNode['props'][0] | undefined {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (p.type === NodeTypes.ATTRIBUTE) {\n      if (dynamicOnly) continue\n      if (p.name === name && p.value && !p.value.isEmpty) {\n        return p\n      }\n    } else if (\n      p.name === 'bind' &&\n      p.arg &&\n      p.arg.type === NodeTypes.SIMPLE_EXPRESSION &&\n      p.arg.isStatic &&\n      p.arg.content === name &&\n      p.exp\n    ) {\n      return p\n    }\n  }\n}\n\nexport function createBlockExpression(\n  blockExp: BlockCodegenNode,\n  context: TransformContext\n): SequenceExpression {\n  return createSequenceExpression([\n    createCallExpression(context.helper(OPEN_BLOCK)),\n    blockExp\n  ])\n}\n\nexport const isVSlot = (p: ElementNode['props'][0]): p is DirectiveNode =>\n  p.type === NodeTypes.DIRECTIVE && p.name === 'slot'\n\nexport const isTemplateNode = (\n  node: RootNode | TemplateChildNode\n): node is TemplateNode =>\n  node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.TEMPLATE\n\nexport const isSlotOutlet = (\n  node: RootNode | TemplateChildNode\n): node is SlotOutletNode =>\n  node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.SLOT\n\nexport function injectProp(\n  node: ElementCodegenNode | ComponentCodegenNode | SlotOutletCodegenNode,\n  prop: Property,\n  context: TransformContext\n) {\n  let propsWithInjection: ObjectExpression | CallExpression\n  const props =\n    node.callee === RENDER_SLOT ? node.arguments[2] : node.arguments[1]\n  if (props == null || isString(props)) {\n    propsWithInjection = createObjectExpression([prop])\n  } else if (props.type === NodeTypes.JS_CALL_EXPRESSION) {\n    // merged props... add ours\n    // only inject key to object literal if it's the first argument so that\n    // if doesn't override user provided keys\n    const first = props.arguments[0] as string | JSChildNode\n    if (!isString(first) && first.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n      first.properties.unshift(prop)\n    } else {\n      props.arguments.unshift(createObjectExpression([prop]))\n    }\n    propsWithInjection = props\n  } else if (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n    props.properties.unshift(prop)\n    propsWithInjection = props\n  } else {\n    // single v-bind with expression, return a merged replacement\n    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n      createObjectExpression([prop]),\n      props\n    ])\n  }\n  if (node.callee === RENDER_SLOT) {\n    node.arguments[2] = propsWithInjection\n  } else {\n    node.arguments[1] = propsWithInjection\n  }\n}\n\nexport function toValidAssetId(\n  name: string,\n  type: 'component' | 'directive'\n): string {\n  return `_${type}_${name.replace(/[^\\w]/g, '_')}`\n}\n\nexport function isEmptyExpression(node: ExpressionNode) {\n  return node.type === NodeTypes.SIMPLE_EXPRESSION && !node.content.trim()\n}\n\n// Check if a node contains expressions that reference current context scope ids\nexport function hasScopeRef(\n  node: TemplateChildNode | IfBranchNode | ExpressionNode | undefined,\n  ids: TransformContext['identifiers']\n): boolean {\n  if (!node || Object.keys(ids).length === 0) {\n    return false\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n      for (let i = 0; i < node.props.length; i++) {\n        const p = node.props[i]\n        if (\n          p.type === NodeTypes.DIRECTIVE &&\n          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))\n        ) {\n          return true\n        }\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.FOR:\n      if (hasScopeRef(node.source, ids)) {\n        return true\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.IF:\n      return node.branches.some(b => hasScopeRef(b, ids))\n    case NodeTypes.IF_BRANCH:\n      if (hasScopeRef(node.condition, ids)) {\n        return true\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.SIMPLE_EXPRESSION:\n      return (\n        !node.isStatic &&\n        isSimpleIdentifier(node.content) &&\n        !!ids[node.content]\n      )\n    case NodeTypes.COMPOUND_EXPRESSION:\n      return node.children.some(c => isObject(c) && hasScopeRef(c, ids))\n    case NodeTypes.INTERPOLATION:\n    case NodeTypes.TEXT_CALL:\n      return hasScopeRef(node.content, ids)\n    case NodeTypes.TEXT:\n    case NodeTypes.COMMENT:\n      return false\n    default:\n      if (__DEV__) {\n        const exhaustiveCheck: never = node\n        exhaustiveCheck\n      }\n      return false\n  }\n}\n","import { NO } from '@vue/shared'\nimport {\n  ErrorCodes,\n  createCompilerError,\n  defaultOnError,\n  CompilerError\n} from './errors'\nimport {\n  assert,\n  advancePositionWithMutation,\n  advancePositionWithClone\n} from './utils'\nimport {\n  Namespace,\n  Namespaces,\n  AttributeNode,\n  CommentNode,\n  DirectiveNode,\n  ElementNode,\n  ElementTypes,\n  ExpressionNode,\n  NodeTypes,\n  Position,\n  RootNode,\n  SourceLocation,\n  TextNode,\n  TemplateChildNode,\n  InterpolationNode\n} from './ast'\nimport { extend } from '@vue/shared'\n\nexport interface ParserOptions {\n  isVoidTag?: (tag: string) => boolean // e.g. img, br, hr\n  isNativeTag?: (tag: string) => boolean // e.g. loading-indicator in weex\n  isCustomElement?: (tag: string) => boolean\n  getNamespace?: (tag: string, parent: ElementNode | undefined) => Namespace\n  getTextMode?: (tag: string, ns: Namespace) => TextModes\n  delimiters?: [string, string] // ['{{', '}}']\n  ignoreSpaces?: boolean\n\n  // Map to HTML entities. E.g., `{ \"amp;\": \"&\" }`\n  // The full set is https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references\n  namedCharacterReferences?: { [name: string]: string | undefined }\n\n  onError?: (error: CompilerError) => void\n}\n\n// `isNativeTag` is optional, others are required\ntype MergedParserOptions = Omit<Required<ParserOptions>, 'isNativeTag'> &\n  Pick<ParserOptions, 'isNativeTag'>\n\nexport const defaultParserOptions: MergedParserOptions = {\n  delimiters: [`{{`, `}}`],\n  ignoreSpaces: true,\n  getNamespace: () => Namespaces.HTML,\n  getTextMode: () => TextModes.DATA,\n  isVoidTag: NO,\n  isCustomElement: NO,\n  namedCharacterReferences: {\n    'gt;': '>',\n    'lt;': '<',\n    'amp;': '&',\n    'apos;': \"'\",\n    'quot;': '\"'\n  },\n  onError: defaultOnError\n}\n\nexport const enum TextModes {\n  //          | Elements | Entities | End sign              | Inside of\n  DATA, //    | ✔       | ✔       | End tags of ancestors |\n  RCDATA, //  | ✘       | ✔       | End tag of the parent | <textarea>\n  RAWTEXT, // | ✘       | ✘       | End tag of the parent | <style>,<script>\n  CDATA,\n  ATTRIBUTE_VALUE\n}\n\ninterface ParserContext {\n  options: MergedParserOptions\n  readonly originalSource: string\n  source: string\n  offset: number\n  line: number\n  column: number\n  maxCRNameLength: number\n  inPre: boolean\n}\n\nexport function parse(content: string, options: ParserOptions = {}): RootNode {\n  const context = createParserContext(content, options)\n  const start = getCursor(context)\n\n  return {\n    type: NodeTypes.ROOT,\n    children: parseChildren(context, TextModes.DATA, []),\n    helpers: [],\n    components: [],\n    directives: [],\n    hoists: [],\n    cached: 0,\n    codegenNode: undefined,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction createParserContext(\n  content: string,\n  options: ParserOptions\n): ParserContext {\n  return {\n    options: {\n      ...defaultParserOptions,\n      ...options\n    },\n    column: 1,\n    line: 1,\n    offset: 0,\n    originalSource: content,\n    source: content,\n    maxCRNameLength: Object.keys(\n      options.namedCharacterReferences ||\n        defaultParserOptions.namedCharacterReferences\n    ).reduce((max, name) => Math.max(max, name.length), 0),\n    inPre: false\n  }\n}\n\nfunction parseChildren(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  const parent = last(ancestors)\n  const ns = parent ? parent.ns : Namespaces.HTML\n  const nodes: TemplateChildNode[] = []\n\n  while (!isEnd(context, mode, ancestors)) {\n    __DEV__ && assert(context.source.length > 0)\n    const s = context.source\n    let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined\n\n    if (!context.inPre && startsWith(s, context.options.delimiters[0])) {\n      // '{{'\n      node = parseInterpolation(context, mode)\n    } else if (mode === TextModes.DATA && s[0] === '<') {\n      // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\n      if (s.length === 1) {\n        emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)\n      } else if (s[1] === '!') {\n        // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\n        if (startsWith(s, '<!--')) {\n          node = parseComment(context)\n        } else if (startsWith(s, '<!DOCTYPE')) {\n          // Ignore DOCTYPE by a limitation.\n          node = parseBogusComment(context)\n        } else if (startsWith(s, '<![CDATA[')) {\n          if (ns !== Namespaces.HTML) {\n            node = parseCDATA(context, ancestors)\n          } else {\n            emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)\n            node = parseBogusComment(context)\n          }\n        } else {\n          emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)\n          node = parseBogusComment(context)\n        }\n      } else if (s[1] === '/') {\n        // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\n        if (s.length === 2) {\n          emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)\n        } else if (s[2] === '>') {\n          emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)\n          advanceBy(context, 3)\n          continue\n        } else if (/[a-z]/i.test(s[2])) {\n          emitError(context, ErrorCodes.X_INVALID_END_TAG)\n          parseTag(context, TagType.End, parent)\n          continue\n        } else {\n          emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 2)\n          node = parseBogusComment(context)\n        }\n      } else if (/[a-z]/i.test(s[1])) {\n        node = parseElement(context, ancestors)\n      } else if (s[1] === '?') {\n        emitError(\n          context,\n          ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\n          1\n        )\n        node = parseBogusComment(context)\n      } else {\n        emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)\n      }\n    }\n    if (!node) {\n      node = parseText(context, mode)\n    }\n\n    if (Array.isArray(node)) {\n      for (let i = 0; i < node.length; i++) {\n        pushNode(context, nodes, node[i])\n      }\n    } else {\n      pushNode(context, nodes, node)\n    }\n  }\n\n  return nodes\n}\n\nfunction pushNode(\n  context: ParserContext,\n  nodes: TemplateChildNode[],\n  node: TemplateChildNode\n): void {\n  // ignore comments in production\n  /* istanbul ignore next */\n  if (!__DEV__ && node.type === NodeTypes.COMMENT) {\n    return\n  }\n  if (\n    context.options.ignoreSpaces &&\n    node.type === NodeTypes.TEXT &&\n    node.isEmpty\n  ) {\n    return\n  }\n\n  // Merge if both this and the previous node are text and those are consecutive.\n  // This happens on \"a < b\" or something like.\n  const prev = last(nodes)\n  if (\n    prev &&\n    prev.type === NodeTypes.TEXT &&\n    node.type === NodeTypes.TEXT &&\n    prev.loc.end.offset === node.loc.start.offset\n  ) {\n    prev.content += node.content\n    prev.isEmpty = prev.content.trim().length === 0\n    prev.loc.end = node.loc.end\n    prev.loc.source += node.loc.source\n  } else {\n    nodes.push(node)\n  }\n}\n\nfunction parseCDATA(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  __DEV__ &&\n    assert(last(ancestors) == null || last(ancestors)!.ns !== Namespaces.HTML)\n  __DEV__ && assert(startsWith(context.source, '<![CDATA['))\n\n  advanceBy(context, 9)\n  const nodes = parseChildren(context, TextModes.CDATA, ancestors)\n  if (context.source.length === 0) {\n    emitError(context, ErrorCodes.EOF_IN_CDATA)\n  } else {\n    __DEV__ && assert(startsWith(context.source, ']]>'))\n    advanceBy(context, 3)\n  }\n\n  return nodes\n}\n\nfunction parseComment(context: ParserContext): CommentNode {\n  __DEV__ && assert(startsWith(context.source, '<!--'))\n\n  const start = getCursor(context)\n  let content: string\n\n  // Regular comment.\n  const match = /--(\\!)?>/.exec(context.source)\n  if (!match) {\n    content = context.source.slice(4)\n    advanceBy(context, context.source.length)\n    emitError(context, ErrorCodes.EOF_IN_COMMENT)\n  } else {\n    if (match.index <= 3) {\n      emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)\n    }\n    if (match[1]) {\n      emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)\n    }\n    content = context.source.slice(4, match.index)\n\n    // Advancing with reporting nested comments.\n    const s = context.source.slice(0, match.index)\n    let prevIndex = 1,\n      nestedIndex = 0\n    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\n      advanceBy(context, nestedIndex - prevIndex + 1)\n      if (nestedIndex + 4 < s.length) {\n        emitError(context, ErrorCodes.NESTED_COMMENT)\n      }\n      prevIndex = nestedIndex + 1\n    }\n    advanceBy(context, match.index + match[0].length - prevIndex + 1)\n  }\n\n  return {\n    type: NodeTypes.COMMENT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseBogusComment(context: ParserContext): CommentNode | undefined {\n  __DEV__ && assert(/^<(?:[\\!\\?]|\\/[^a-z>])/i.test(context.source))\n\n  const start = getCursor(context)\n  const contentStart = context.source[1] === '?' ? 1 : 2\n  let content: string\n\n  const closeIndex = context.source.indexOf('>')\n  if (closeIndex === -1) {\n    content = context.source.slice(contentStart)\n    advanceBy(context, context.source.length)\n  } else {\n    content = context.source.slice(contentStart, closeIndex)\n    advanceBy(context, closeIndex + 1)\n  }\n\n  return {\n    type: NodeTypes.COMMENT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseElement(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): ElementNode | undefined {\n  __DEV__ && assert(/^<[a-z]/i.test(context.source))\n\n  // Start tag.\n  const wasInPre = context.inPre\n  const parent = last(ancestors)\n  const element = parseTag(context, TagType.Start, parent)\n  const isPreBoundary = context.inPre && !wasInPre\n\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n    return element\n  }\n\n  // Children.\n  ancestors.push(element)\n  const mode = context.options.getTextMode(element.tag, element.ns)\n  const children = parseChildren(context, mode, ancestors)\n  ancestors.pop()\n\n  element.children = children\n\n  // End tag.\n  if (startsWithEndTagOpen(context.source, element.tag)) {\n    parseTag(context, TagType.End, parent)\n  } else {\n    emitError(context, ErrorCodes.X_MISSING_END_TAG)\n    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\n      const first = children[0]\n      if (first && startsWith(first.loc.source, '<!--')) {\n        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)\n      }\n    }\n  }\n\n  element.loc = getSelection(context, element.loc.start)\n\n  if (isPreBoundary) {\n    context.inPre = false\n  }\n  return element\n}\n\nconst enum TagType {\n  Start,\n  End\n}\n\n/**\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\n */\nfunction parseTag(\n  context: ParserContext,\n  type: TagType,\n  parent: ElementNode | undefined\n): ElementNode {\n  __DEV__ && assert(/^<\\/?[a-z]/i.test(context.source))\n  __DEV__ &&\n    assert(\n      type === (startsWith(context.source, '</') ? TagType.End : TagType.Start)\n    )\n\n  // Tag open.\n  const start = getCursor(context)\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source)!\n  const tag = match[1]\n  const ns = context.options.getNamespace(tag, parent)\n\n  advanceBy(context, match[0].length)\n  advanceSpaces(context)\n\n  // save current state in case we need to re-parse attributes with v-pre\n  const cursor = getCursor(context)\n  const currentSource = context.source\n\n  // Attributes.\n  let props = parseAttributes(context, type)\n\n  // check v-pre\n  if (\n    !context.inPre &&\n    props.some(p => p.type === NodeTypes.DIRECTIVE && p.name === 'pre')\n  ) {\n    context.inPre = true\n    // reset context\n    extend(context, cursor)\n    context.source = currentSource\n    // re-parse attrs and filter out v-pre itself\n    props = parseAttributes(context, type).filter(p => p.name !== 'v-pre')\n  }\n\n  // Tag close.\n  let isSelfClosing = false\n  if (context.source.length === 0) {\n    emitError(context, ErrorCodes.EOF_IN_TAG)\n  } else {\n    isSelfClosing = startsWith(context.source, '/>')\n    if (type === TagType.End && isSelfClosing) {\n      emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)\n    }\n    advanceBy(context, isSelfClosing ? 2 : 1)\n  }\n\n  let tagType = ElementTypes.ELEMENT\n  if (!context.inPre && !context.options.isCustomElement(tag)) {\n    if (context.options.isNativeTag) {\n      if (!context.options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT\n    } else {\n      if (/^[A-Z]/.test(tag)) tagType = ElementTypes.COMPONENT\n    }\n\n    if (tag === 'slot') tagType = ElementTypes.SLOT\n    else if (tag === 'template') tagType = ElementTypes.TEMPLATE\n    else if (tag === 'portal' || tag === 'Portal') tagType = ElementTypes.PORTAL\n    else if (tag === 'suspense' || tag === 'Suspense')\n      tagType = ElementTypes.SUSPENSE\n  }\n\n  return {\n    type: NodeTypes.ELEMENT,\n    ns,\n    tag,\n    tagType,\n    props,\n    isSelfClosing,\n    children: [],\n    loc: getSelection(context, start),\n    codegenNode: undefined // to be created during transform phase\n  }\n}\n\nfunction parseAttributes(\n  context: ParserContext,\n  type: TagType\n): (AttributeNode | DirectiveNode)[] {\n  const props = []\n  const attributeNames = new Set<string>()\n  while (\n    context.source.length > 0 &&\n    !startsWith(context.source, '>') &&\n    !startsWith(context.source, '/>')\n  ) {\n    if (startsWith(context.source, '/')) {\n      emitError(context, ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG)\n      advanceBy(context, 1)\n      advanceSpaces(context)\n      continue\n    }\n    if (type === TagType.End) {\n      emitError(context, ErrorCodes.END_TAG_WITH_ATTRIBUTES)\n    }\n\n    const attr = parseAttribute(context, attributeNames)\n    if (type === TagType.Start) {\n      props.push(attr)\n    }\n\n    if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\n      emitError(context, ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES)\n    }\n    advanceSpaces(context)\n  }\n  return props\n}\n\nfunction parseAttribute(\n  context: ParserContext,\n  nameSet: Set<string>\n): AttributeNode | DirectiveNode {\n  __DEV__ && assert(/^[^\\t\\r\\n\\f />]/.test(context.source))\n\n  // Name.\n  const start = getCursor(context)\n  const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source)!\n  const name = match[0]\n\n  if (nameSet.has(name)) {\n    emitError(context, ErrorCodes.DUPLICATE_ATTRIBUTE)\n  }\n  nameSet.add(name)\n\n  if (name[0] === '=') {\n    emitError(context, ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME)\n  }\n  {\n    const pattern = /[\"'<]/g\n    let m: RegExpExecArray | null\n    while ((m = pattern.exec(name)) !== null) {\n      emitError(\n        context,\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\n        m.index\n      )\n    }\n  }\n\n  advanceBy(context, name.length)\n\n  // Value\n  let value:\n    | {\n        content: string\n        isQuoted: boolean\n        loc: SourceLocation\n      }\n    | undefined = undefined\n\n  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\n    advanceSpaces(context)\n    advanceBy(context, 1)\n    advanceSpaces(context)\n    value = parseAttributeValue(context)\n    if (!value) {\n      emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE)\n    }\n  }\n  const loc = getSelection(context, start)\n\n  if (!context.inPre && /^(v-|:|@|#)/.test(name)) {\n    const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec(\n      name\n    )!\n\n    let arg: ExpressionNode | undefined\n\n    if (match[2]) {\n      const startOffset = name.split(match[2], 2)!.shift()!.length\n      const loc = getSelection(\n        context,\n        getNewPosition(context, start, startOffset),\n        getNewPosition(context, start, startOffset + match[2].length)\n      )\n      let content = match[2]\n      let isStatic = true\n\n      if (content.startsWith('[')) {\n        isStatic = false\n\n        if (!content.endsWith(']')) {\n          emitError(\n            context,\n            ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END\n          )\n        }\n\n        content = content.substr(1, content.length - 2)\n      }\n\n      arg = {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content,\n        isStatic,\n        isConstant: isStatic,\n        loc\n      }\n    }\n\n    if (value && value.isQuoted) {\n      const valueLoc = value.loc\n      valueLoc.start.offset++\n      valueLoc.start.column++\n      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)\n      valueLoc.source = valueLoc.source.slice(1, -1)\n    }\n\n    return {\n      type: NodeTypes.DIRECTIVE,\n      name:\n        match[1] ||\n        (startsWith(name, ':')\n          ? 'bind'\n          : startsWith(name, '@')\n            ? 'on'\n            : 'slot'),\n      exp: value && {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: value.content,\n        isStatic: false,\n        // Treat as non-constant by default. This can be potentially set to\n        // true by `transformExpression` to make it eligible for hoisting.\n        isConstant: false,\n        loc: value.loc\n      },\n      arg,\n      modifiers: match[3] ? match[3].substr(1).split('.') : [],\n      loc\n    }\n  }\n\n  return {\n    type: NodeTypes.ATTRIBUTE,\n    name,\n    value: value && {\n      type: NodeTypes.TEXT,\n      content: value.content,\n      isEmpty: value.content.trim().length === 0,\n      loc: value.loc\n    },\n    loc\n  }\n}\n\nfunction parseAttributeValue(\n  context: ParserContext\n):\n  | {\n      content: string\n      isQuoted: boolean\n      loc: SourceLocation\n    }\n  | undefined {\n  const start = getCursor(context)\n  let content: string\n\n  const quote = context.source[0]\n  const isQuoted = quote === `\"` || quote === `'`\n  if (isQuoted) {\n    // Quoted value.\n    advanceBy(context, 1)\n\n    const endIndex = context.source.indexOf(quote)\n    if (endIndex === -1) {\n      content = parseTextData(\n        context,\n        context.source.length,\n        TextModes.ATTRIBUTE_VALUE\n      )\n    } else {\n      content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)\n      advanceBy(context, 1)\n    }\n  } else {\n    // Unquoted\n    const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source)\n    if (!match) {\n      return undefined\n    }\n    let unexpectedChars = /[\"'<=`]/g\n    let m: RegExpExecArray | null\n    while ((m = unexpectedChars.exec(match[0])) !== null) {\n      emitError(\n        context,\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\n        m.index\n      )\n    }\n    content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)\n  }\n\n  return { content, isQuoted, loc: getSelection(context, start) }\n}\n\nfunction parseInterpolation(\n  context: ParserContext,\n  mode: TextModes\n): InterpolationNode | undefined {\n  const [open, close] = context.options.delimiters\n  __DEV__ && assert(startsWith(context.source, open))\n\n  const closeIndex = context.source.indexOf(close, open.length)\n  if (closeIndex === -1) {\n    emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)\n    return undefined\n  }\n\n  const start = getCursor(context)\n  advanceBy(context, open.length)\n  const innerStart = getCursor(context)\n  const innerEnd = getCursor(context)\n  const rawContentLength = closeIndex - open.length\n  const rawContent = context.source.slice(0, rawContentLength)\n  const preTrimContent = parseTextData(context, rawContentLength, mode)\n  const content = preTrimContent.trim()\n  const startOffset = preTrimContent.indexOf(content)\n  if (startOffset > 0) {\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\n  }\n  const endOffset =\n    rawContentLength - (preTrimContent.length - content.length - startOffset)\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\n  advanceBy(context, close.length)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      isStatic: false,\n      // Set `isConstant` to false by default and will decide in transformExpression\n      isConstant: false,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseText(context: ParserContext, mode: TextModes): TextNode {\n  __DEV__ && assert(context.source.length > 0)\n\n  const [open] = context.options.delimiters\n  const endIndex = Math.min(\n    ...[\n      context.source.indexOf('<', 1),\n      context.source.indexOf(open, 1),\n      mode === TextModes.CDATA ? context.source.indexOf(']]>') : -1,\n      context.source.length\n    ].filter(n => n !== -1)\n  )\n  __DEV__ && assert(endIndex > 0)\n\n  const start = getCursor(context)\n  const content = parseTextData(context, endIndex, mode)\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n    loc: getSelection(context, start),\n    isEmpty: !content.trim()\n  }\n}\n\n/**\n * Get text data with a given length from the current location.\n * This translates HTML entities in the text data.\n */\nfunction parseTextData(\n  context: ParserContext,\n  length: number,\n  mode: TextModes\n): string {\n  if (mode === TextModes.RAWTEXT || mode === TextModes.CDATA) {\n    const text = context.source.slice(0, length)\n    advanceBy(context, length)\n    return text\n  }\n\n  // DATA or RCDATA. Entity decoding required.\n  const end = context.offset + length\n  let text: string = ''\n\n  while (context.offset < end) {\n    const head = /&(?:#x?)?/i.exec(context.source)\n    if (!head || context.offset + head.index >= end) {\n      const remaining = end - context.offset\n      text += context.source.slice(0, remaining)\n      advanceBy(context, remaining)\n      break\n    }\n\n    // Advance to the \"&\".\n    text += context.source.slice(0, head.index)\n    advanceBy(context, head.index)\n\n    if (head[0] === '&') {\n      // Named character reference.\n      let name = '',\n        value: string | undefined = undefined\n      if (/[0-9a-z]/i.test(context.source[1])) {\n        for (\n          let length = context.maxCRNameLength;\n          !value && length > 0;\n          --length\n        ) {\n          name = context.source.substr(1, length)\n          value = context.options.namedCharacterReferences[name]\n        }\n        if (value) {\n          const semi = name.endsWith(';')\n          if (\n            mode === TextModes.ATTRIBUTE_VALUE &&\n            !semi &&\n            /[=a-z0-9]/i.test(context.source[1 + name.length] || '')\n          ) {\n            text += '&'\n            text += name\n            advanceBy(context, 1 + name.length)\n          } else {\n            text += value\n            advanceBy(context, 1 + name.length)\n            if (!semi) {\n              emitError(\n                context,\n                ErrorCodes.MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE\n              )\n            }\n          }\n        } else {\n          emitError(context, ErrorCodes.UNKNOWN_NAMED_CHARACTER_REFERENCE)\n          text += '&'\n          text += name\n          advanceBy(context, 1 + name.length)\n        }\n      } else {\n        text += '&'\n        advanceBy(context, 1)\n      }\n    } else {\n      // Numeric character reference.\n      const hex = head[0] === '&#x'\n      const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/\n      const body = pattern.exec(context.source)\n      if (!body) {\n        text += head[0]\n        emitError(\n          context,\n          ErrorCodes.ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE\n        )\n        advanceBy(context, head[0].length)\n      } else {\n        // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\n        let cp = Number.parseInt(body[1], hex ? 16 : 10)\n        if (cp === 0) {\n          emitError(context, ErrorCodes.NULL_CHARACTER_REFERENCE)\n          cp = 0xfffd\n        } else if (cp > 0x10ffff) {\n          emitError(\n            context,\n            ErrorCodes.CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE\n          )\n          cp = 0xfffd\n        } else if (cp >= 0xd800 && cp <= 0xdfff) {\n          emitError(context, ErrorCodes.SURROGATE_CHARACTER_REFERENCE)\n          cp = 0xfffd\n        } else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) {\n          emitError(context, ErrorCodes.NONCHARACTER_CHARACTER_REFERENCE)\n        } else if (\n          (cp >= 0x01 && cp <= 0x08) ||\n          cp === 0x0b ||\n          (cp >= 0x0d && cp <= 0x1f) ||\n          (cp >= 0x7f && cp <= 0x9f)\n        ) {\n          emitError(context, ErrorCodes.CONTROL_CHARACTER_REFERENCE)\n          cp = CCR_REPLACEMENTS[cp] || cp\n        }\n        text += String.fromCodePoint(cp)\n        advanceBy(context, body[0].length)\n        if (!body![0].endsWith(';')) {\n          emitError(\n            context,\n            ErrorCodes.MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE\n          )\n        }\n      }\n    }\n  }\n  return text\n}\n\nfunction getCursor(context: ParserContext): Position {\n  const { column, line, offset } = context\n  return { column, line, offset }\n}\n\nfunction getSelection(\n  context: ParserContext,\n  start: Position,\n  end?: Position\n): SourceLocation {\n  end = end || getCursor(context)\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset)\n  }\n}\n\nfunction last<T>(xs: T[]): T | undefined {\n  return xs[xs.length - 1]\n}\n\nfunction startsWith(source: string, searchString: string): boolean {\n  return source.startsWith(searchString)\n}\n\nfunction advanceBy(context: ParserContext, numberOfCharacters: number): void {\n  const { source } = context\n  __DEV__ && assert(numberOfCharacters <= source.length)\n  advancePositionWithMutation(context, source, numberOfCharacters)\n  context.source = source.slice(numberOfCharacters)\n}\n\nfunction advanceSpaces(context: ParserContext): void {\n  const match = /^[\\t\\r\\n\\f ]+/.exec(context.source)\n  if (match) {\n    advanceBy(context, match[0].length)\n  }\n}\n\nfunction getNewPosition(\n  context: ParserContext,\n  start: Position,\n  numberOfCharacters: number\n): Position {\n  return advancePositionWithClone(\n    start,\n    context.originalSource.slice(start.offset, numberOfCharacters),\n    numberOfCharacters\n  )\n}\n\nfunction emitError(\n  context: ParserContext,\n  code: ErrorCodes,\n  offset?: number\n): void {\n  const loc = getCursor(context)\n  if (offset) {\n    loc.offset += offset\n    loc.column += offset\n  }\n  context.options.onError(\n    createCompilerError(code, {\n      start: loc,\n      end: loc,\n      source: ''\n    })\n  )\n}\n\nfunction isEnd(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): boolean {\n  const s = context.source\n\n  switch (mode) {\n    case TextModes.DATA:\n      if (startsWith(s, '</')) {\n        //TODO: probably bad performance\n        for (let i = ancestors.length - 1; i >= 0; --i) {\n          if (startsWithEndTagOpen(s, ancestors[i].tag)) {\n            return true\n          }\n        }\n      }\n      break\n\n    case TextModes.RCDATA:\n    case TextModes.RAWTEXT: {\n      const parent = last(ancestors)\n      if (parent && startsWithEndTagOpen(s, parent.tag)) {\n        return true\n      }\n      break\n    }\n\n    case TextModes.CDATA:\n      if (startsWith(s, ']]>')) {\n        return true\n      }\n      break\n  }\n\n  return !s\n}\n\nfunction startsWithEndTagOpen(source: string, tag: string): boolean {\n  return (\n    startsWith(source, '</') &&\n    source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&\n    /[\\t\\n\\f />]/.test(source[2 + tag.length] || '>')\n  )\n}\n\n// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\nconst CCR_REPLACEMENTS: { [key: number]: number | undefined } = {\n  0x80: 0x20ac,\n  0x82: 0x201a,\n  0x83: 0x0192,\n  0x84: 0x201e,\n  0x85: 0x2026,\n  0x86: 0x2020,\n  0x87: 0x2021,\n  0x88: 0x02c6,\n  0x89: 0x2030,\n  0x8a: 0x0160,\n  0x8b: 0x2039,\n  0x8c: 0x0152,\n  0x8e: 0x017d,\n  0x91: 0x2018,\n  0x92: 0x2019,\n  0x93: 0x201c,\n  0x94: 0x201d,\n  0x95: 0x2022,\n  0x96: 0x2013,\n  0x97: 0x2014,\n  0x98: 0x02dc,\n  0x99: 0x2122,\n  0x9a: 0x0161,\n  0x9b: 0x203a,\n  0x9c: 0x0153,\n  0x9e: 0x017e,\n  0x9f: 0x0178\n}\n","import {\n  RootNode,\n  NodeTypes,\n  TemplateChildNode,\n  SimpleExpressionNode,\n  ElementTypes,\n  ElementCodegenNode,\n  PlainElementNode,\n  ComponentNode,\n  TemplateNode,\n  ElementNode,\n  PlainElementCodegenNode\n} from '../ast'\nimport { TransformContext } from '../transform'\nimport { WITH_DIRECTIVES } from '../runtimeHelpers'\nimport { PatchFlags, isString, isSymbol } from '@vue/shared'\nimport { isSlotOutlet, findProp } from '../utils'\n\nexport function hoistStatic(root: RootNode, context: TransformContext) {\n  walk(\n    root.children,\n    context,\n    new Map(),\n    isSingleElementRoot(root, root.children[0])\n  )\n}\n\nexport function isSingleElementRoot(\n  root: RootNode,\n  child: TemplateChildNode\n): child is PlainElementNode | ComponentNode | TemplateNode {\n  const { children } = root\n  return (\n    children.length === 1 &&\n    child.type === NodeTypes.ELEMENT &&\n    !isSlotOutlet(child)\n  )\n}\n\nfunction walk(\n  children: TemplateChildNode[],\n  context: TransformContext,\n  resultCache: Map<TemplateChildNode, boolean>,\n  doNotHoistNode: boolean = false\n) {\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    // only plain elements are eligible for hoisting.\n    if (\n      child.type === NodeTypes.ELEMENT &&\n      child.tagType === ElementTypes.ELEMENT\n    ) {\n      if (!doNotHoistNode && isStaticNode(child, resultCache)) {\n        // whole tree is static\n        child.codegenNode = context.hoist(child.codegenNode!)\n        continue\n      } else {\n        // node may contain dynamic children, but its props may be eligible for\n        // hoisting.\n        const flag = getPatchFlag(child)\n        if (\n          (!flag ||\n            flag === PatchFlags.NEED_PATCH ||\n            flag === PatchFlags.TEXT) &&\n          !hasDynamicKeyOrRef(child) &&\n          !hasCachedProps(child)\n        ) {\n          const props = getNodeProps(child)\n          if (props && props !== `null`) {\n            getVNodeCall(child).arguments[1] = context.hoist(props)\n          }\n        }\n      }\n    }\n    if (child.type === NodeTypes.ELEMENT) {\n      walk(child.children, context, resultCache)\n    } else if (child.type === NodeTypes.FOR) {\n      // Do not hoist v-for single child because it has to be a block\n      walk(child.children, context, resultCache, child.children.length === 1)\n    } else if (child.type === NodeTypes.IF) {\n      for (let i = 0; i < child.branches.length; i++) {\n        const branchChildren = child.branches[i].children\n        // Do not hoist v-if single child because it has to be a block\n        walk(branchChildren, context, resultCache, branchChildren.length === 1)\n      }\n    }\n  }\n}\n\nexport function isStaticNode(\n  node: TemplateChildNode | SimpleExpressionNode,\n  resultCache: Map<TemplateChildNode, boolean> = new Map()\n): boolean {\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n      if (node.tagType !== ElementTypes.ELEMENT) {\n        return false\n      }\n      const cached = resultCache.get(node)\n      if (cached !== undefined) {\n        return cached\n      }\n      const flag = getPatchFlag(node)\n      if (!flag && !hasDynamicKeyOrRef(node) && !hasCachedProps(node)) {\n        // element self is static. check its children.\n        for (let i = 0; i < node.children.length; i++) {\n          if (!isStaticNode(node.children[i], resultCache)) {\n            resultCache.set(node, false)\n            return false\n          }\n        }\n        resultCache.set(node, true)\n        return true\n      } else {\n        resultCache.set(node, false)\n        return false\n      }\n    case NodeTypes.TEXT:\n    case NodeTypes.COMMENT:\n      return true\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n      return false\n    case NodeTypes.INTERPOLATION:\n    case NodeTypes.TEXT_CALL:\n      return isStaticNode(node.content, resultCache)\n    case NodeTypes.SIMPLE_EXPRESSION:\n      return node.isConstant\n    case NodeTypes.COMPOUND_EXPRESSION:\n      return node.children.every(child => {\n        return (\n          isString(child) || isSymbol(child) || isStaticNode(child, resultCache)\n        )\n      })\n    default:\n      if (__DEV__) {\n        const exhaustiveCheck: never = node\n        exhaustiveCheck\n      }\n      return false\n  }\n}\n\nfunction hasDynamicKeyOrRef(node: ElementNode): boolean {\n  return !!(findProp(node, 'key', true) || findProp(node, 'ref', true))\n}\n\nfunction hasCachedProps(node: PlainElementNode): boolean {\n  if (__BROWSER__) {\n    return false\n  }\n  const props = getNodeProps(node)\n  if (\n    props &&\n    props !== 'null' &&\n    props.type === NodeTypes.JS_OBJECT_EXPRESSION\n  ) {\n    const { properties } = props\n    for (let i = 0; i < properties.length; i++) {\n      if (properties[i].value.type === NodeTypes.JS_CACHE_EXPRESSION) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction getVNodeCall(node: PlainElementNode) {\n  let codegenNode = node.codegenNode as ElementCodegenNode\n  if (codegenNode.callee === WITH_DIRECTIVES) {\n    codegenNode = codegenNode.arguments[0]\n  }\n  return codegenNode\n}\n\nfunction getVNodeArgAt(\n  node: PlainElementNode,\n  index: number\n): PlainElementCodegenNode['arguments'][number] {\n  return getVNodeCall(node).arguments[index]\n}\n\nfunction getPatchFlag(node: PlainElementNode): number | undefined {\n  const flag = getVNodeArgAt(node, 3) as string\n  return flag ? parseInt(flag, 10) : undefined\n}\n\nfunction getNodeProps(node: PlainElementNode) {\n  return getVNodeArgAt(node, 1) as PlainElementCodegenNode['arguments'][1]\n}\n","import {\n  RootNode,\n  NodeTypes,\n  ParentNode,\n  TemplateChildNode,\n  ElementNode,\n  DirectiveNode,\n  Property,\n  ExpressionNode,\n  createSimpleExpression,\n  JSChildNode,\n  SimpleExpressionNode,\n  ElementTypes,\n  ElementCodegenNode,\n  ComponentCodegenNode,\n  createCallExpression,\n  CacheExpression,\n  createCacheExpression\n} from './ast'\nimport { isString, isArray } from '@vue/shared'\nimport { CompilerError, defaultOnError } from './errors'\nimport {\n  TO_STRING,\n  COMMENT,\n  CREATE_VNODE,\n  FRAGMENT,\n  helperNameMap,\n  WITH_DIRECTIVES,\n  CREATE_BLOCK\n} from './runtimeHelpers'\nimport { isVSlot, createBlockExpression } from './utils'\nimport { hoistStatic, isSingleElementRoot } from './transforms/hoistStatic'\n\n// There are two types of transforms:\n//\n// - NodeTransform:\n//   Transforms that operate directly on a ChildNode. NodeTransforms may mutate,\n//   replace or remove the node being processed.\nexport type NodeTransform = (\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) => void | (() => void) | (() => void)[]\n\n// - DirectiveTransform:\n//   Transforms that handles a single directive attribute on an element.\n//   It translates the raw directive into actual props for the VNode.\nexport type DirectiveTransform = (\n  dir: DirectiveNode,\n  node: ElementNode,\n  context: TransformContext,\n  // a platform specific compiler can import the base transform and augment\n  // it by passing in this optional argument.\n  augmentor?: (ret: DirectiveTransformResult) => DirectiveTransformResult\n) => DirectiveTransformResult\n\nexport interface DirectiveTransformResult {\n  props: Property[]\n  needRuntime: boolean | symbol\n}\n\n// A structural directive transform is a technically a NodeTransform;\n// Only v-if and v-for fall into this category.\nexport type StructuralDirectiveTransform = (\n  node: ElementNode,\n  dir: DirectiveNode,\n  context: TransformContext\n) => void | (() => void)\n\nexport interface TransformOptions {\n  nodeTransforms?: NodeTransform[]\n  directiveTransforms?: { [name: string]: DirectiveTransform }\n  prefixIdentifiers?: boolean\n  hoistStatic?: boolean\n  cacheHandlers?: boolean\n  onError?: (error: CompilerError) => void\n}\n\nexport interface TransformContext extends Required<TransformOptions> {\n  root: RootNode\n  helpers: Set<symbol>\n  components: Set<string>\n  directives: Set<string>\n  hoists: JSChildNode[]\n  cached: number\n  identifiers: { [name: string]: number | undefined }\n  scopes: {\n    vFor: number\n    vSlot: number\n    vPre: number\n    vOnce: number\n  }\n  parent: ParentNode | null\n  childIndex: number\n  currentNode: RootNode | TemplateChildNode | null\n  helper<T extends symbol>(name: T): T\n  helperString(name: symbol): string\n  replaceNode(node: TemplateChildNode): void\n  removeNode(node?: TemplateChildNode): void\n  onNodeRemoved(): void\n  addIdentifiers(exp: ExpressionNode | string): void\n  removeIdentifiers(exp: ExpressionNode | string): void\n  hoist(exp: JSChildNode): SimpleExpressionNode\n  cache<T extends JSChildNode>(exp: T): CacheExpression | T\n}\n\nfunction createTransformContext(\n  root: RootNode,\n  {\n    prefixIdentifiers = false,\n    hoistStatic = false,\n    cacheHandlers = false,\n    nodeTransforms = [],\n    directiveTransforms = {},\n    onError = defaultOnError\n  }: TransformOptions\n): TransformContext {\n  const context: TransformContext = {\n    root,\n    helpers: new Set(),\n    components: new Set(),\n    directives: new Set(),\n    hoists: [],\n    cached: 0,\n    identifiers: {},\n    scopes: {\n      vFor: 0,\n      vSlot: 0,\n      vPre: 0,\n      vOnce: 0\n    },\n    prefixIdentifiers,\n    hoistStatic,\n    cacheHandlers,\n    nodeTransforms,\n    directiveTransforms,\n    onError,\n    parent: null,\n    currentNode: root,\n    childIndex: 0,\n    helper(name) {\n      context.helpers.add(name)\n      return name\n    },\n    helperString(name) {\n      return (\n        (context.prefixIdentifiers ? `` : `_`) +\n        helperNameMap[context.helper(name)]\n      )\n    },\n    replaceNode(node) {\n      /* istanbul ignore if */\n      if (__DEV__) {\n        if (!context.currentNode) {\n          throw new Error(`Node being replaced is already removed.`)\n        }\n        if (!context.parent) {\n          throw new Error(`Cannot replace root node.`)\n        }\n      }\n      context.parent!.children[context.childIndex] = context.currentNode = node\n    },\n    removeNode(node) {\n      if (__DEV__ && !context.parent) {\n        throw new Error(`Cannot remove root node.`)\n      }\n      const list = context.parent!.children\n      const removalIndex = node\n        ? list.indexOf(node)\n        : context.currentNode\n          ? context.childIndex\n          : -1\n      /* istanbul ignore if */\n      if (__DEV__ && removalIndex < 0) {\n        throw new Error(`node being removed is not a child of current parent`)\n      }\n      if (!node || node === context.currentNode) {\n        // current node removed\n        context.currentNode = null\n        context.onNodeRemoved()\n      } else {\n        // sibling node removed\n        if (context.childIndex > removalIndex) {\n          context.childIndex--\n          context.onNodeRemoved()\n        }\n      }\n      context.parent!.children.splice(removalIndex, 1)\n    },\n    onNodeRemoved: () => {},\n    addIdentifiers(exp) {\n      // identifier tracking only happens in non-browser builds.\n      if (!__BROWSER__) {\n        if (isString(exp)) {\n          addId(exp)\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(addId)\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          addId(exp.content)\n        }\n      }\n    },\n    removeIdentifiers(exp) {\n      if (!__BROWSER__) {\n        if (isString(exp)) {\n          removeId(exp)\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(removeId)\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          removeId(exp.content)\n        }\n      }\n    },\n    hoist(exp) {\n      context.hoists.push(exp)\n      return createSimpleExpression(\n        `_hoisted_${context.hoists.length}`,\n        false,\n        exp.loc\n      )\n    },\n    cache(exp) {\n      return cacheHandlers ? createCacheExpression(++context.cached, exp) : exp\n    }\n  }\n\n  function addId(id: string) {\n    const { identifiers } = context\n    if (identifiers[id] === undefined) {\n      identifiers[id] = 0\n    }\n    identifiers[id]!++\n  }\n\n  function removeId(id: string) {\n    context.identifiers[id]!--\n  }\n\n  return context\n}\n\nexport function transform(root: RootNode, options: TransformOptions) {\n  const context = createTransformContext(root, options)\n  traverseNode(root, context)\n  if (options.hoistStatic) {\n    hoistStatic(root, context)\n  }\n  finalizeRoot(root, context)\n}\n\nfunction finalizeRoot(root: RootNode, context: TransformContext) {\n  const { helper } = context\n  const { children } = root\n  const child = children[0]\n  if (children.length === 1) {\n    // if the single child is an element, turn it into a block.\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\n      // single element root is never hoisted so codegenNode will never be\n      // SimpleExpressionNode\n      const codegenNode = child.codegenNode as\n        | ElementCodegenNode\n        | ComponentCodegenNode\n      if (codegenNode.callee === WITH_DIRECTIVES) {\n        codegenNode.arguments[0].callee = helper(CREATE_BLOCK)\n      } else {\n        codegenNode.callee = helper(CREATE_BLOCK)\n      }\n      root.codegenNode = createBlockExpression(codegenNode, context)\n    } else {\n      // - single <slot/>, IfNode, ForNode: already blocks.\n      // - single text node: always patched.\n      // root codegen falls through via genNode()\n      root.codegenNode = child\n    }\n  } else if (children.length > 1) {\n    // root has multiple nodes - return a fragment block.\n    root.codegenNode = createBlockExpression(\n      createCallExpression(helper(CREATE_BLOCK), [\n        helper(FRAGMENT),\n        `null`,\n        root.children\n      ]),\n      context\n    )\n  } else {\n    // no children = noop. codegen will return null.\n  }\n  // finalize meta information\n  root.helpers = [...context.helpers]\n  root.components = [...context.components]\n  root.directives = [...context.directives]\n  root.hoists = context.hoists\n  root.cached = context.cached\n}\n\nexport function traverseChildren(\n  parent: ParentNode,\n  context: TransformContext\n) {\n  let i = 0\n  const nodeRemoved = () => {\n    i--\n  }\n  for (; i < parent.children.length; i++) {\n    const child = parent.children[i]\n    if (isString(child)) continue\n    context.currentNode = child\n    context.parent = parent\n    context.childIndex = i\n    context.onNodeRemoved = nodeRemoved\n    traverseNode(child, context)\n  }\n}\n\nexport function traverseNode(\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) {\n  // apply transform plugins\n  const { nodeTransforms } = context\n  const exitFns = []\n  for (let i = 0; i < nodeTransforms.length; i++) {\n    const onExit = nodeTransforms[i](node, context)\n    if (onExit) {\n      if (isArray(onExit)) {\n        exitFns.push(...onExit)\n      } else {\n        exitFns.push(onExit)\n      }\n    }\n    if (!context.currentNode) {\n      // node was removed\n      return\n    } else {\n      // node may have been replaced\n      node = context.currentNode\n    }\n  }\n\n  switch (node.type) {\n    case NodeTypes.COMMENT:\n      // inject import for the Comment symbol, which is needed for creating\n      // comment nodes with `createVNode`\n      context.helper(CREATE_VNODE)\n      context.helper(COMMENT)\n      break\n    case NodeTypes.INTERPOLATION:\n      // no need to traverse, but we need to inject toString helper\n      context.helper(TO_STRING)\n      break\n\n    // for container types, further traverse downwards\n    case NodeTypes.IF:\n      for (let i = 0; i < node.branches.length; i++) {\n        traverseChildren(node.branches[i], context)\n      }\n      break\n    case NodeTypes.FOR:\n    case NodeTypes.ELEMENT:\n    case NodeTypes.ROOT:\n      traverseChildren(node, context)\n      break\n  }\n\n  // exit transforms\n  let i = exitFns.length\n  while (i--) {\n    exitFns[i]()\n  }\n}\n\nexport function createStructuralDirectiveTransform(\n  name: string | RegExp,\n  fn: StructuralDirectiveTransform\n): NodeTransform {\n  const matches = isString(name)\n    ? (n: string) => n === name\n    : (n: string) => name.test(n)\n\n  return (node, context) => {\n    if (node.type === NodeTypes.ELEMENT) {\n      const { props } = node\n      // structural directive transforms are not concerned with slots\n      // as they are handled separately in vSlot.ts\n      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {\n        return\n      }\n      const exitFns = []\n      for (let i = 0; i < props.length; i++) {\n        const prop = props[i]\n        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {\n          // structural directives are removed to avoid infinite recursion\n          // also we remove them *before* applying so that it can further\n          // traverse itself in case it moves the node around\n          props.splice(i, 1)\n          i--\n          const onExit = fn(node, prop, context)\n          if (onExit) exitFns.push(onExit)\n        }\n      }\n      return exitFns\n    }\n  }\n}\n","import {\n  RootNode,\n  TemplateChildNode,\n  TextNode,\n  CommentNode,\n  ExpressionNode,\n  NodeTypes,\n  JSChildNode,\n  CallExpression,\n  ArrayExpression,\n  ObjectExpression,\n  SourceLocation,\n  Position,\n  InterpolationNode,\n  CompoundExpressionNode,\n  SimpleExpressionNode,\n  FunctionExpression,\n  SequenceExpression,\n  ConditionalExpression,\n  CacheExpression\n} from './ast'\nimport { SourceMapGenerator, RawSourceMap } from 'source-map'\nimport {\n  advancePositionWithMutation,\n  assert,\n  isSimpleIdentifier,\n  loadDep,\n  toValidAssetId\n} from './utils'\nimport { isString, isArray, isSymbol } from '@vue/shared'\nimport {\n  TO_STRING,\n  CREATE_VNODE,\n  COMMENT,\n  helperNameMap,\n  RESOLVE_COMPONENT,\n  RESOLVE_DIRECTIVE\n} from './runtimeHelpers'\n\ntype CodegenNode = TemplateChildNode | JSChildNode\n\nexport interface CodegenOptions {\n  // - Module mode will generate ES module import statements for helpers\n  //   and export the render function as the default export.\n  // - Function mode will generate a single `const { helpers... } = Vue`\n  //   statement and return the render function. It is meant to be used with\n  //   `new Function(code)()` to generate a render function at runtime.\n  // Default: 'function'\n  mode?: 'module' | 'function'\n  // Prefix suitable identifiers with _ctx.\n  // If this option is false, the generated code will be wrapped in a\n  // `with (this) { ... }` block.\n  // Default: false\n  prefixIdentifiers?: boolean\n  // Generate source map?\n  // Default: false\n  sourceMap?: boolean\n  // Filename for source map generation.\n  // Default: `template.vue.html`\n  filename?: string\n}\n\nexport interface CodegenResult {\n  code: string\n  ast: RootNode\n  map?: RawSourceMap\n}\n\nexport interface CodegenContext extends Required<CodegenOptions> {\n  source: string\n  code: string\n  line: number\n  column: number\n  offset: number\n  indentLevel: number\n  map?: SourceMapGenerator\n  helper(key: symbol): string\n  push(code: string, node?: CodegenNode, openOnly?: boolean): void\n  resetMapping(loc: SourceLocation): void\n  indent(): void\n  deindent(withoutNewLine?: boolean): void\n  newline(): void\n}\n\nfunction createCodegenContext(\n  ast: RootNode,\n  {\n    mode = 'function',\n    prefixIdentifiers = mode === 'module',\n    sourceMap = false,\n    filename = `template.vue.html`\n  }: CodegenOptions\n): CodegenContext {\n  const context: CodegenContext = {\n    mode,\n    prefixIdentifiers,\n    sourceMap,\n    filename,\n    source: ast.loc.source,\n    code: ``,\n    column: 1,\n    line: 1,\n    offset: 0,\n    indentLevel: 0,\n\n    // lazy require source-map implementation, only in non-browser builds!\n    map:\n      __BROWSER__ || !sourceMap\n        ? undefined\n        : new (loadDep('source-map')).SourceMapGenerator(),\n\n    helper(key) {\n      const name = helperNameMap[key]\n      return prefixIdentifiers ? name : `_${name}`\n    },\n    push(code, node, openOnly) {\n      context.code += code\n      if (!__BROWSER__ && context.map) {\n        if (node) {\n          let name\n          if (node.type === NodeTypes.SIMPLE_EXPRESSION && !node.isStatic) {\n            const content = node.content.replace(/^_ctx\\./, '')\n            if (content !== node.content && isSimpleIdentifier(content)) {\n              name = content\n            }\n          }\n          addMapping(node.loc.start, name)\n        }\n        advancePositionWithMutation(context, code)\n        if (node && !openOnly) {\n          addMapping(node.loc.end)\n        }\n      }\n    },\n    resetMapping(loc: SourceLocation) {\n      if (!__BROWSER__ && context.map) {\n        addMapping(loc.start)\n      }\n    },\n    indent() {\n      newline(++context.indentLevel)\n    },\n    deindent(withoutNewLine = false) {\n      if (withoutNewLine) {\n        --context.indentLevel\n      } else {\n        newline(--context.indentLevel)\n      }\n    },\n    newline() {\n      newline(context.indentLevel)\n    }\n  }\n\n  function newline(n: number) {\n    context.push('\\n' + `  `.repeat(n))\n  }\n\n  function addMapping(loc: Position, name?: string) {\n    context.map!.addMapping({\n      name,\n      source: context.filename,\n      original: {\n        line: loc.line,\n        column: loc.column - 1 // source-map column is 0 based\n      },\n      generated: {\n        line: context.line,\n        column: context.column - 1\n      }\n    })\n  }\n\n  if (!__BROWSER__ && context.map) {\n    context.map.setSourceContent(filename, context.source)\n  }\n  return context\n}\n\nexport function generate(\n  ast: RootNode,\n  options: CodegenOptions = {}\n): CodegenResult {\n  const context = createCodegenContext(ast, options)\n  const {\n    mode,\n    push,\n    helper,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline\n  } = context\n  const hasHelpers = ast.helpers.length > 0\n  const useWithBlock = !prefixIdentifiers && mode !== 'module'\n\n  // preambles\n  if (mode === 'function') {\n    // Generate const declaration for helpers\n    // In prefix mode, we place the const declaration at top so it's done\n    // only once; But if we not prefixing, we place the declaration inside the\n    // with block so it doesn't incur the `in` check cost for every helper access.\n    if (hasHelpers) {\n      if (prefixIdentifiers) {\n        push(`const { ${ast.helpers.map(helper).join(', ')} } = Vue\\n`)\n      } else {\n        // \"with\" mode.\n        // save Vue in a separate variable to avoid collision\n        push(`const _Vue = Vue\\n`)\n        // in \"with\" mode, helpers are declared inside the with block to avoid\n        // has check cost, but hoists are lifted out of the function - we need\n        // to provide the helper here.\n        if (ast.hoists.length) {\n          push(`const _${helperNameMap[CREATE_VNODE]} = Vue.createVNode\\n`)\n          if (ast.helpers.includes(COMMENT)) {\n            push(`const _${helperNameMap[COMMENT]} = Vue.Comment\\n`)\n          }\n        }\n      }\n    }\n    genHoists(ast.hoists, context)\n    newline()\n    push(`return `)\n  } else {\n    // generate import statements for helpers\n    if (hasHelpers) {\n      push(`import { ${ast.helpers.map(helper).join(', ')} } from \"vue\"\\n`)\n    }\n    genHoists(ast.hoists, context)\n    newline()\n    push(`export default `)\n  }\n\n  // enter render function\n  push(`function render() {`)\n  indent()\n\n  if (useWithBlock) {\n    push(`with (this) {`)\n    indent()\n    // function mode const declarations should be inside with block\n    // also they should be renamed to avoid collision with user properties\n    if (hasHelpers) {\n      push(\n        `const { ${ast.helpers\n          .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)\n          .join(', ')} } = _Vue`\n      )\n      newline()\n      newline()\n    }\n  } else {\n    push(`const _ctx = this`)\n    if (ast.cached > 0) {\n      newline()\n      push(`const _cache = _ctx.$cache`)\n    }\n    newline()\n  }\n\n  // generate asset resolution statements\n  if (ast.components.length) {\n    genAssets(ast.components, 'component', context)\n  }\n  if (ast.directives.length) {\n    genAssets(ast.directives, 'directive', context)\n  }\n  if (ast.components.length || ast.directives.length) {\n    newline()\n  }\n\n  // generate the VNode tree expression\n  push(`return `)\n  if (ast.codegenNode) {\n    genNode(ast.codegenNode, context)\n  } else {\n    push(`null`)\n  }\n\n  if (useWithBlock) {\n    deindent()\n    push(`}`)\n  }\n\n  deindent()\n  push(`}`)\n  return {\n    ast,\n    code: context.code,\n    map: context.map ? context.map.toJSON() : undefined\n  }\n}\n\nfunction genAssets(\n  assets: string[],\n  type: 'component' | 'directive',\n  context: CodegenContext\n) {\n  const resolver = context.helper(\n    type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE\n  )\n  for (let i = 0; i < assets.length; i++) {\n    const id = assets[i]\n    context.push(\n      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`\n    )\n    context.newline()\n  }\n}\n\nfunction genHoists(hoists: JSChildNode[], context: CodegenContext) {\n  if (!hoists.length) {\n    return\n  }\n  context.newline()\n  hoists.forEach((exp, i) => {\n    context.push(`const _hoisted_${i + 1} = `)\n    genNode(exp, context)\n    context.newline()\n  })\n}\n\nfunction isText(n: string | CodegenNode) {\n  return (\n    isString(n) ||\n    n.type === NodeTypes.SIMPLE_EXPRESSION ||\n    n.type === NodeTypes.TEXT ||\n    n.type === NodeTypes.INTERPOLATION ||\n    n.type === NodeTypes.COMPOUND_EXPRESSION\n  )\n}\n\nfunction genNodeListAsArray(\n  nodes: (string | CodegenNode | TemplateChildNode[])[],\n  context: CodegenContext\n) {\n  const multilines =\n    nodes.length > 3 ||\n    ((!__BROWSER__ || __DEV__) && nodes.some(n => isArray(n) || !isText(n)))\n  context.push(`[`)\n  multilines && context.indent()\n  genNodeList(nodes, context, multilines)\n  multilines && context.deindent()\n  context.push(`]`)\n}\n\nfunction genNodeList(\n  nodes: (string | symbol | CodegenNode | TemplateChildNode[])[],\n  context: CodegenContext,\n  multilines: boolean = false\n) {\n  const { push, newline } = context\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]\n    if (isString(node)) {\n      push(node)\n    } else if (isArray(node)) {\n      genNodeListAsArray(node, context)\n    } else {\n      genNode(node, context)\n    }\n    if (i < nodes.length - 1) {\n      if (multilines) {\n        push(',')\n        newline()\n      } else {\n        push(', ')\n      }\n    }\n  }\n}\n\nfunction genNode(node: CodegenNode | symbol | string, context: CodegenContext) {\n  if (isString(node)) {\n    context.push(node)\n    return\n  }\n  if (isSymbol(node)) {\n    context.push(context.helper(node))\n    return\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n      __DEV__ &&\n        assert(\n          node.codegenNode != null,\n          `Codegen node is missing for element/if/for node. ` +\n            `Apply appropriate transforms first.`\n        )\n      genNode(node.codegenNode!, context)\n      break\n    case NodeTypes.TEXT:\n      genText(node, context)\n      break\n    case NodeTypes.SIMPLE_EXPRESSION:\n      genExpression(node, context)\n      break\n    case NodeTypes.INTERPOLATION:\n      genInterpolation(node, context)\n      break\n    case NodeTypes.TEXT_CALL:\n      genNode(node.codegenNode, context)\n      break\n    case NodeTypes.COMPOUND_EXPRESSION:\n      genCompoundExpression(node, context)\n      break\n    case NodeTypes.COMMENT:\n      genComment(node, context)\n      break\n    case NodeTypes.JS_CALL_EXPRESSION:\n      genCallExpression(node, context)\n      break\n    case NodeTypes.JS_OBJECT_EXPRESSION:\n      genObjectExpression(node, context)\n      break\n    case NodeTypes.JS_ARRAY_EXPRESSION:\n      genArrayExpression(node, context)\n      break\n    case NodeTypes.JS_FUNCTION_EXPRESSION:\n      genFunctionExpression(node, context)\n      break\n    case NodeTypes.JS_SEQUENCE_EXPRESSION:\n      genSequenceExpression(node, context)\n      break\n    case NodeTypes.JS_CONDITIONAL_EXPRESSION:\n      genConditionalExpression(node, context)\n      break\n    case NodeTypes.JS_CACHE_EXPRESSION:\n      genCacheExpression(node, context)\n      break\n    /* istanbul ignore next */\n    default:\n      if (__DEV__) {\n        assert(false, `unhandled codegen node type: ${(node as any).type}`)\n        // make sure we exhaust all possible types\n        const exhaustiveCheck: never = node\n        return exhaustiveCheck\n      }\n  }\n}\n\nfunction genText(\n  node: TextNode | SimpleExpressionNode,\n  context: CodegenContext\n) {\n  context.push(JSON.stringify(node.content), node)\n}\n\nfunction genExpression(node: SimpleExpressionNode, context: CodegenContext) {\n  const { content, isStatic } = node\n  context.push(isStatic ? JSON.stringify(content) : content, node)\n}\n\nfunction genInterpolation(node: InterpolationNode, context: CodegenContext) {\n  const { push, helper } = context\n  push(`${helper(TO_STRING)}(`)\n  genNode(node.content, context)\n  push(`)`)\n}\n\nfunction genCompoundExpression(\n  node: CompoundExpressionNode,\n  context: CodegenContext\n) {\n  for (let i = 0; i < node.children!.length; i++) {\n    const child = node.children![i]\n    if (isString(child)) {\n      context.push(child)\n    } else {\n      genNode(child, context)\n    }\n  }\n}\n\nfunction genExpressionAsPropertyKey(\n  node: ExpressionNode,\n  context: CodegenContext\n) {\n  const { push } = context\n  if (node.type === NodeTypes.COMPOUND_EXPRESSION) {\n    push(`[`)\n    genCompoundExpression(node, context)\n    push(`]`)\n  } else if (node.isStatic) {\n    // only quote keys if necessary\n    const text = isSimpleIdentifier(node.content)\n      ? node.content\n      : JSON.stringify(node.content)\n    push(text, node)\n  } else {\n    push(`[${node.content}]`, node)\n  }\n}\n\nfunction genComment(node: CommentNode, context: CodegenContext) {\n  if (__DEV__) {\n    const { push, helper } = context\n    push(\n      `${helper(CREATE_VNODE)}(${helper(COMMENT)}, null, ${JSON.stringify(\n        node.content\n      )})`,\n      node\n    )\n  }\n}\n\n// JavaScript\nfunction genCallExpression(node: CallExpression, context: CodegenContext) {\n  const callee = isString(node.callee)\n    ? node.callee\n    : context.helper(node.callee)\n  context.push(callee + `(`, node, true)\n  genNodeList(node.arguments, context)\n  context.push(`)`)\n}\n\nfunction genObjectExpression(node: ObjectExpression, context: CodegenContext) {\n  const { push, indent, deindent, newline, resetMapping } = context\n  const { properties } = node\n  if (!properties.length) {\n    push(`{}`, node)\n    return\n  }\n  const multilines =\n    properties.length > 1 ||\n    ((!__BROWSER__ || __DEV__) &&\n      properties.some(p => p.value.type !== NodeTypes.SIMPLE_EXPRESSION))\n  push(multilines ? `{` : `{ `)\n  multilines && indent()\n  for (let i = 0; i < properties.length; i++) {\n    const { key, value, loc } = properties[i]\n    resetMapping(loc) // reset source mapping for every property.\n    // key\n    genExpressionAsPropertyKey(key, context)\n    push(`: `)\n    // value\n    genNode(value, context)\n    if (i < properties.length - 1) {\n      // will only reach this if it's multilines\n      push(`,`)\n      newline()\n    }\n  }\n  multilines && deindent()\n  const lastChar = context.code[context.code.length - 1]\n  push(multilines || /[\\])}]/.test(lastChar) ? `}` : ` }`)\n}\n\nfunction genArrayExpression(node: ArrayExpression, context: CodegenContext) {\n  genNodeListAsArray(node.elements, context)\n}\n\nfunction genFunctionExpression(\n  node: FunctionExpression,\n  context: CodegenContext\n) {\n  const { push, indent, deindent } = context\n  const { params, returns, newline } = node\n  push(`(`, node)\n  if (isArray(params)) {\n    genNodeList(params, context)\n  } else if (params) {\n    genNode(params, context)\n  }\n  push(`) => `)\n  if (newline) {\n    push(`{`)\n    indent()\n    push(`return `)\n  }\n  if (isArray(returns)) {\n    genNodeListAsArray(returns, context)\n  } else {\n    genNode(returns, context)\n  }\n  if (newline) {\n    deindent()\n    push(`}`)\n  }\n}\n\nfunction genConditionalExpression(\n  node: ConditionalExpression,\n  context: CodegenContext\n) {\n  const { test, consequent, alternate } = node\n  const { push, indent, deindent, newline } = context\n  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {\n    const needsParens = !isSimpleIdentifier(test.content)\n    needsParens && push(`(`)\n    genExpression(test, context)\n    needsParens && push(`)`)\n  } else {\n    push(`(`)\n    genCompoundExpression(test, context)\n    push(`)`)\n  }\n  indent()\n  context.indentLevel++\n  push(`? `)\n  genNode(consequent, context)\n  context.indentLevel--\n  newline()\n  push(`: `)\n  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\n  if (!isNested) {\n    context.indentLevel++\n  }\n  genNode(alternate, context)\n  if (!isNested) {\n    context.indentLevel--\n  }\n  deindent(true /* without newline */)\n}\n\nfunction genSequenceExpression(\n  node: SequenceExpression,\n  context: CodegenContext\n) {\n  context.push(`(`)\n  genNodeList(node.expressions, context)\n  context.push(`)`)\n}\n\nfunction genCacheExpression(node: CacheExpression, context: CodegenContext) {\n  context.push(`_cache[${node.index}] || (_cache[${node.index}] = `)\n  genNode(node.value, context)\n  context.push(`)`)\n}\n","import {\n  createStructuralDirectiveTransform,\n  traverseChildren,\n  TransformContext\n} from '../transform'\nimport {\n  NodeTypes,\n  ElementTypes,\n  ElementNode,\n  DirectiveNode,\n  IfBranchNode,\n  SimpleExpressionNode,\n  createSequenceExpression,\n  createCallExpression,\n  createConditionalExpression,\n  ConditionalExpression,\n  CallExpression,\n  createSimpleExpression,\n  createObjectProperty,\n  createObjectExpression,\n  IfCodegenNode,\n  IfConditionalExpression,\n  BlockCodegenNode,\n  SlotOutletCodegenNode,\n  ElementCodegenNode,\n  ComponentCodegenNode\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { processExpression } from './transformExpression'\nimport {\n  OPEN_BLOCK,\n  CREATE_BLOCK,\n  COMMENT,\n  FRAGMENT,\n  WITH_DIRECTIVES,\n  CREATE_VNODE\n} from '../runtimeHelpers'\nimport { injectProp } from '../utils'\n\nexport const transformIf = createStructuralDirectiveTransform(\n  /^(if|else|else-if)$/,\n  (node, dir, context) => {\n    if (\n      dir.name !== 'else' &&\n      (!dir.exp || !(dir.exp as SimpleExpressionNode).content.trim())\n    ) {\n      const loc = dir.exp ? dir.exp.loc : node.loc\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_IF_NO_EXPRESSION, dir.loc)\n      )\n      dir.exp = createSimpleExpression(`true`, false, loc)\n    }\n\n    if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {\n      // dir.exp can only be simple expression because vIf transform is applied\n      // before expression transform.\n      dir.exp = processExpression(dir.exp as SimpleExpressionNode, context)\n    }\n\n    if (dir.name === 'if') {\n      const branch = createIfBranch(node, dir)\n      const codegenNode = createSequenceExpression([\n        createCallExpression(context.helper(OPEN_BLOCK))\n      ]) as IfCodegenNode\n\n      context.replaceNode({\n        type: NodeTypes.IF,\n        loc: node.loc,\n        branches: [branch],\n        codegenNode\n      })\n\n      // Exit callback. Complete the codegenNode when all children have been\n      // transformed.\n      return () => {\n        codegenNode.expressions.push(createCodegenNodeForBranch(\n          branch,\n          0,\n          context\n        ) as IfConditionalExpression)\n      }\n    } else {\n      // locate the adjacent v-if\n      const siblings = context.parent!.children\n      const comments = []\n      let i = siblings.indexOf(node)\n      while (i-- >= -1) {\n        const sibling = siblings[i]\n        if (__DEV__ && sibling && sibling.type === NodeTypes.COMMENT) {\n          context.removeNode(sibling)\n          comments.unshift(sibling)\n          continue\n        }\n        if (sibling && sibling.type === NodeTypes.IF) {\n          // move the node to the if node's branches\n          context.removeNode()\n          const branch = createIfBranch(node, dir)\n          if (__DEV__ && comments.length) {\n            branch.children = [...comments, ...branch.children]\n          }\n          sibling.branches.push(branch)\n          // since the branch was removed, it will not be traversed.\n          // make sure to traverse here.\n          traverseChildren(branch, context)\n          // make sure to reset currentNode after traversal to indicate this\n          // node has been removed.\n          context.currentNode = null\n          // attach this branch's codegen node to the v-if root.\n          let parentCondition = sibling.codegenNode\n            .expressions[1] as ConditionalExpression\n          while (true) {\n            if (\n              parentCondition.alternate.type ===\n              NodeTypes.JS_CONDITIONAL_EXPRESSION\n            ) {\n              parentCondition = parentCondition.alternate\n            } else {\n              parentCondition.alternate = createCodegenNodeForBranch(\n                branch,\n                sibling.branches.length - 1,\n                context\n              )\n              break\n            }\n          }\n        } else {\n          context.onError(\n            createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc)\n          )\n        }\n        break\n      }\n    }\n  }\n)\n\nfunction createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode {\n  return {\n    type: NodeTypes.IF_BRANCH,\n    loc: node.loc,\n    condition: dir.name === 'else' ? undefined : dir.exp,\n    children: node.tagType === ElementTypes.TEMPLATE ? node.children : [node]\n  }\n}\n\nfunction createCodegenNodeForBranch(\n  branch: IfBranchNode,\n  index: number,\n  context: TransformContext\n): IfConditionalExpression | BlockCodegenNode {\n  if (branch.condition) {\n    return createConditionalExpression(\n      branch.condition,\n      createChildrenCodegenNode(branch, index, context),\n      createCallExpression(context.helper(CREATE_BLOCK), [\n        context.helper(COMMENT)\n      ])\n    ) as IfConditionalExpression\n  } else {\n    return createChildrenCodegenNode(branch, index, context) as BlockCodegenNode\n  }\n}\n\nfunction createChildrenCodegenNode(\n  branch: IfBranchNode,\n  index: number,\n  context: TransformContext\n): CallExpression {\n  const { helper } = context\n  const keyProperty = createObjectProperty(\n    `key`,\n    createSimpleExpression(index + '', false)\n  )\n  const { children } = branch\n  const child = children[0]\n  const needFragmentWrapper =\n    children.length !== 1 || child.type !== NodeTypes.ELEMENT\n  if (needFragmentWrapper) {\n    const blockArgs: CallExpression['arguments'] = [\n      helper(FRAGMENT),\n      createObjectExpression([keyProperty]),\n      children\n    ]\n    if (children.length === 1 && child.type === NodeTypes.FOR) {\n      // optimize away nested fragments when child is a ForNode\n      const forBlockArgs = child.codegenNode.expressions[1].arguments\n      // directly use the for block's children and patchFlag\n      blockArgs[2] = forBlockArgs[2]\n      blockArgs[3] = forBlockArgs[3]\n    }\n    return createCallExpression(helper(CREATE_BLOCK), blockArgs)\n  } else {\n    const childCodegen = (child as ElementNode).codegenNode as\n      | ElementCodegenNode\n      | ComponentCodegenNode\n      | SlotOutletCodegenNode\n    let vnodeCall = childCodegen\n    // Element with custom directives. Locate the actual createVNode() call.\n    if (vnodeCall.callee === WITH_DIRECTIVES) {\n      vnodeCall = vnodeCall.arguments[0]\n    }\n    // Change createVNode to createBlock.\n    if (vnodeCall.callee === CREATE_VNODE) {\n      vnodeCall.callee = helper(CREATE_BLOCK)\n    }\n    // inject branch key\n    injectProp(vnodeCall, keyProperty, context)\n    return childCodegen\n  }\n}\n","import {\n  createStructuralDirectiveTransform,\n  TransformContext\n} from '../transform'\nimport {\n  NodeTypes,\n  ExpressionNode,\n  createSimpleExpression,\n  SourceLocation,\n  SimpleExpressionNode,\n  createSequenceExpression,\n  createCallExpression,\n  createFunctionExpression,\n  ElementTypes,\n  createObjectExpression,\n  createObjectProperty,\n  ForCodegenNode,\n  ElementCodegenNode\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  getInnerRange,\n  findProp,\n  createBlockExpression,\n  isTemplateNode,\n  isSlotOutlet,\n  injectProp\n} from '../utils'\nimport {\n  RENDER_LIST,\n  OPEN_BLOCK,\n  CREATE_BLOCK,\n  FRAGMENT,\n  WITH_DIRECTIVES\n} from '../runtimeHelpers'\nimport { processExpression } from './transformExpression'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\n\nexport const transformFor = createStructuralDirectiveTransform(\n  'for',\n  (node, dir, context) => {\n    if (!dir.exp) {\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_FOR_NO_EXPRESSION, dir.loc)\n      )\n      return\n    }\n\n    const parseResult = parseForExpression(\n      // can only be simple expression because vFor transform is applied\n      // before expression transform.\n      dir.exp as SimpleExpressionNode,\n      context\n    )\n\n    if (!parseResult) {\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, dir.loc)\n      )\n      return\n    }\n\n    const { helper, addIdentifiers, removeIdentifiers, scopes } = context\n    const { source, value, key, index } = parseResult\n\n    // create the loop render function expression now, and add the\n    // iterator on exit after all children have been traversed\n    const renderExp = createCallExpression(helper(RENDER_LIST), [source])\n    const keyProp = findProp(node, `key`)\n    const fragmentFlag = keyProp\n      ? PatchFlags.KEYED_FRAGMENT\n      : PatchFlags.UNKEYED_FRAGMENT\n    const codegenNode = createSequenceExpression([\n      // fragment blocks disable tracking since they always diff their children\n      createCallExpression(helper(OPEN_BLOCK), [`false`]),\n      createCallExpression(helper(CREATE_BLOCK), [\n        helper(FRAGMENT),\n        `null`,\n        renderExp,\n        fragmentFlag + (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``)\n      ])\n    ]) as ForCodegenNode\n\n    context.replaceNode({\n      type: NodeTypes.FOR,\n      loc: dir.loc,\n      source,\n      valueAlias: value,\n      keyAlias: key,\n      objectIndexAlias: index,\n      children: node.tagType === ElementTypes.TEMPLATE ? node.children : [node],\n      codegenNode\n    })\n\n    // bookkeeping\n    scopes.vFor++\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      // scope management\n      // inject identifiers to context\n      value && addIdentifiers(value)\n      key && addIdentifiers(key)\n      index && addIdentifiers(index)\n    }\n\n    return () => {\n      scopes.vFor--\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        value && removeIdentifiers(value)\n        key && removeIdentifiers(key)\n        index && removeIdentifiers(index)\n      }\n\n      // finish the codegen now that all children have been traversed\n      let childBlock\n      const isTemplate = isTemplateNode(node)\n      const slotOutlet = isSlotOutlet(node)\n        ? node\n        : isTemplate &&\n          node.children.length === 1 &&\n          isSlotOutlet(node.children[0])\n          ? node.children[0]\n          : null\n      const keyProperty = keyProp\n        ? createObjectProperty(\n            `key`,\n            keyProp.type === NodeTypes.ATTRIBUTE\n              ? createSimpleExpression(keyProp.value!.content, true)\n              : keyProp.exp!\n          )\n        : null\n      if (slotOutlet) {\n        // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\n        childBlock = slotOutlet.codegenNode!\n        if (isTemplate && keyProperty) {\n          // <template v-for=\"...\" :key=\"...\"><slot/></template>\n          // we need to inject the key to the renderSlot() call.\n          // the props for renderSlot is passed as the 3rd argument.\n          injectProp(childBlock, keyProperty, context)\n        }\n      } else if (isTemplate) {\n        // <template v-for=\"...\">\n        // should generate a fragment block for each loop\n        childBlock = createBlockExpression(\n          createCallExpression(helper(CREATE_BLOCK), [\n            helper(FRAGMENT),\n            keyProperty ? createObjectExpression([keyProperty]) : `null`,\n            node.children\n          ]),\n          context\n        )\n      } else {\n        // Normal element v-for. Directly use the child's codegenNode\n        // arguments, but replace createVNode() with createBlock()\n        let codegenNode = node.codegenNode as ElementCodegenNode\n        if (codegenNode.callee === WITH_DIRECTIVES) {\n          codegenNode.arguments[0].callee = helper(CREATE_BLOCK)\n        } else {\n          codegenNode.callee = helper(CREATE_BLOCK)\n        }\n        childBlock = createBlockExpression(codegenNode, context)\n      }\n\n      renderExp.arguments.push(\n        createFunctionExpression(\n          createForLoopParams(parseResult),\n          childBlock,\n          true /* force newline */\n        )\n      )\n    }\n  }\n)\n\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\n// This regex doesn't cover the case if key or index aliases have destructuring,\n// but those do not make sense in the first place, so this works in practice.\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\nconst stripParensRE = /^\\(|\\)$/g\n\nexport interface ForParseResult {\n  source: ExpressionNode\n  value: ExpressionNode | undefined\n  key: ExpressionNode | undefined\n  index: ExpressionNode | undefined\n}\n\nexport function parseForExpression(\n  input: SimpleExpressionNode,\n  context: TransformContext\n): ForParseResult | undefined {\n  const loc = input.loc\n  const exp = input.content\n  const inMatch = exp.match(forAliasRE)\n  if (!inMatch) return\n\n  const [, LHS, RHS] = inMatch\n\n  const result: ForParseResult = {\n    source: createAliasExpression(\n      loc,\n      RHS.trim(),\n      exp.indexOf(RHS, LHS.length)\n    ),\n    value: undefined,\n    key: undefined,\n    index: undefined\n  }\n  if (!__BROWSER__ && context.prefixIdentifiers) {\n    result.source = processExpression(\n      result.source as SimpleExpressionNode,\n      context\n    )\n  }\n\n  let valueContent = LHS.trim()\n    .replace(stripParensRE, '')\n    .trim()\n  const trimmedOffset = LHS.indexOf(valueContent)\n\n  const iteratorMatch = valueContent.match(forIteratorRE)\n  if (iteratorMatch) {\n    valueContent = valueContent.replace(forIteratorRE, '').trim()\n\n    const keyContent = iteratorMatch[1].trim()\n    let keyOffset: number | undefined\n    if (keyContent) {\n      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)\n      result.key = createAliasExpression(loc, keyContent, keyOffset)\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        result.key = processExpression(result.key, context, true)\n      }\n    }\n\n    if (iteratorMatch[2]) {\n      const indexContent = iteratorMatch[2].trim()\n\n      if (indexContent) {\n        result.index = createAliasExpression(\n          loc,\n          indexContent,\n          exp.indexOf(\n            indexContent,\n            result.key\n              ? keyOffset! + keyContent.length\n              : trimmedOffset + valueContent.length\n          )\n        )\n        if (!__BROWSER__ && context.prefixIdentifiers) {\n          result.index = processExpression(result.index, context, true)\n        }\n      }\n    }\n  }\n\n  if (valueContent) {\n    result.value = createAliasExpression(loc, valueContent, trimmedOffset)\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      result.value = processExpression(result.value, context, true)\n    }\n  }\n\n  return result\n}\n\nfunction createAliasExpression(\n  range: SourceLocation,\n  content: string,\n  offset: number\n): SimpleExpressionNode {\n  return createSimpleExpression(\n    content,\n    false,\n    getInnerRange(range, offset, content.length)\n  )\n}\n\nexport function createForLoopParams({\n  value,\n  key,\n  index\n}: ForParseResult): ExpressionNode[] {\n  const params: ExpressionNode[] = []\n  if (value) {\n    params.push(value)\n  }\n  if (key) {\n    if (!value) {\n      params.push(createSimpleExpression(`_`, false))\n    }\n    params.push(key)\n  }\n  if (index) {\n    if (!key) {\n      if (!value) {\n        params.push(createSimpleExpression(`_`, false))\n      }\n      params.push(createSimpleExpression(`__`, false))\n    }\n    params.push(index)\n  }\n  return params\n}\n","import {\n  ElementNode,\n  ObjectExpression,\n  createObjectExpression,\n  NodeTypes,\n  createObjectProperty,\n  createSimpleExpression,\n  createFunctionExpression,\n  DirectiveNode,\n  ElementTypes,\n  ExpressionNode,\n  Property,\n  TemplateChildNode,\n  SourceLocation,\n  createConditionalExpression,\n  ConditionalExpression,\n  JSChildNode,\n  SimpleExpressionNode,\n  FunctionExpression,\n  CallExpression,\n  createCallExpression,\n  createArrayExpression\n} from '../ast'\nimport { TransformContext, NodeTransform } from '../transform'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { findDir, isTemplateNode, assert, isVSlot, hasScopeRef } from '../utils'\nimport { CREATE_SLOTS, RENDER_LIST } from '../runtimeHelpers'\nimport { parseForExpression, createForLoopParams } from './vFor'\n\nconst isStaticExp = (p: JSChildNode): p is SimpleExpressionNode =>\n  p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStatic\n\nconst defaultFallback = createSimpleExpression(`undefined`, false)\n\n// A NodeTransform that:\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\n//    by transformExpression. This is only applied in non-browser builds with\n//    { prefixIdentifiers: true }.\n// 2. Track v-slot depths so that we know a slot is inside another slot.\n//    Note the exit callback is executed before buildSlots() on the same node,\n//    so only nested slots see positive numbers.\nexport const trackSlotScopes: NodeTransform = (node, context) => {\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    (node.tagType === ElementTypes.COMPONENT ||\n      node.tagType === ElementTypes.TEMPLATE)\n  ) {\n    // We are only checking non-empty v-slot here\n    // since we only care about slots that introduce scope variables.\n    const vSlot = findDir(node, 'slot')\n    if (vSlot) {\n      const slotProps = vSlot.exp\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        slotProps && context.addIdentifiers(slotProps)\n      }\n      context.scopes.vSlot++\n      return () => {\n        if (!__BROWSER__ && context.prefixIdentifiers) {\n          slotProps && context.removeIdentifiers(slotProps)\n        }\n        context.scopes.vSlot--\n      }\n    }\n  }\n}\n\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\nexport const trackVForSlotScopes: NodeTransform = (node, context) => {\n  let vFor\n  if (\n    isTemplateNode(node) &&\n    node.props.some(isVSlot) &&\n    (vFor = findDir(node, 'for'))\n  ) {\n    const result = (vFor.parseResult = parseForExpression(\n      vFor.exp as SimpleExpressionNode,\n      context\n    ))\n    if (result) {\n      const { value, key, index } = result\n      const { addIdentifiers, removeIdentifiers } = context\n      value && addIdentifiers(value)\n      key && addIdentifiers(key)\n      index && addIdentifiers(index)\n\n      return () => {\n        value && removeIdentifiers(value)\n        key && removeIdentifiers(key)\n        index && removeIdentifiers(index)\n      }\n    }\n  }\n}\n\n// Instead of being a DirectiveTransform, v-slot processing is called during\n// transformElement to build the slots object for a component.\nexport function buildSlots(\n  node: ElementNode,\n  context: TransformContext\n): {\n  slots: ObjectExpression | CallExpression\n  hasDynamicSlots: boolean\n} {\n  const { children, loc } = node\n  const slotsProperties: Property[] = []\n  const dynamicSlots: (ConditionalExpression | CallExpression)[] = []\n\n  // If the slot is inside a v-for or another v-slot, force it to be dynamic\n  // since it likely uses a scope variable.\n  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0\n  // with `prefixIdentifiers: true`, this can be further optimized to make\n  // it dynamic only when the slot actually uses the scope variables.\n  if (!__BROWSER__ && context.prefixIdentifiers) {\n    hasDynamicSlots = hasScopeRef(node, context.identifiers)\n  }\n\n  // 1. Check for default slot with slotProps on component itself.\n  //    <Comp v-slot=\"{ prop }\"/>\n  const explicitDefaultSlot = findDir(node, 'slot', true)\n  if (explicitDefaultSlot) {\n    const { arg, exp, loc } = explicitDefaultSlot\n    if (arg) {\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_SLOT_NAMED_SLOT_ON_COMPONENT, loc)\n      )\n    }\n    slotsProperties.push(buildDefaultSlot(exp, children, loc))\n  }\n\n  // 2. Iterate through children and check for template slots\n  //    <template v-slot:foo=\"{ prop }\">\n  let hasTemplateSlots = false\n  let extraneousChild: TemplateChildNode | undefined = undefined\n  const seenSlotNames = new Set<string>()\n  for (let i = 0; i < children.length; i++) {\n    const slotElement = children[i]\n    let slotDir\n\n    if (\n      !isTemplateNode(slotElement) ||\n      !(slotDir = findDir(slotElement, 'slot', true))\n    ) {\n      // not a <template v-slot>, skip.\n      if (slotElement.type !== NodeTypes.COMMENT && !extraneousChild) {\n        extraneousChild = slotElement\n      }\n      continue\n    }\n\n    if (explicitDefaultSlot) {\n      // already has on-component default slot - this is incorrect usage.\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE, slotDir.loc)\n      )\n      break\n    }\n\n    hasTemplateSlots = true\n    const { children: slotChildren, loc: slotLoc } = slotElement\n    const {\n      arg: slotName = createSimpleExpression(`default`, true),\n      exp: slotProps,\n      loc: dirLoc\n    } = slotDir\n\n    // check if name is dynamic.\n    let staticSlotName: string | undefined\n    if (isStaticExp(slotName)) {\n      staticSlotName = slotName ? slotName.content : `default`\n    } else {\n      hasDynamicSlots = true\n    }\n\n    const slotFunction = createFunctionExpression(\n      slotProps,\n      slotChildren,\n      false,\n      slotChildren.length ? slotChildren[0].loc : slotLoc\n    )\n\n    // check if this slot is conditional (v-if/v-for)\n    let vIf: DirectiveNode | undefined\n    let vElse: DirectiveNode | undefined\n    let vFor: DirectiveNode | undefined\n    if ((vIf = findDir(slotElement, 'if'))) {\n      hasDynamicSlots = true\n      dynamicSlots.push(\n        createConditionalExpression(\n          vIf.exp!,\n          buildDynamicSlot(slotName, slotFunction),\n          defaultFallback\n        )\n      )\n    } else if (\n      (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))\n    ) {\n      // find adjacent v-if\n      let j = i\n      let prev\n      while (j--) {\n        prev = children[j]\n        if (prev.type !== NodeTypes.COMMENT) {\n          break\n        }\n      }\n      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\n        // remove node\n        children.splice(i, 1)\n        i--\n        __DEV__ && assert(dynamicSlots.length > 0)\n        // attach this slot to previous conditional\n        let conditional = dynamicSlots[\n          dynamicSlots.length - 1\n        ] as ConditionalExpression\n        while (\n          conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\n        ) {\n          conditional = conditional.alternate\n        }\n        conditional.alternate = vElse.exp\n          ? createConditionalExpression(\n              vElse.exp,\n              buildDynamicSlot(slotName, slotFunction),\n              defaultFallback\n            )\n          : buildDynamicSlot(slotName, slotFunction)\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, vElse.loc)\n        )\n      }\n    } else if ((vFor = findDir(slotElement, 'for'))) {\n      hasDynamicSlots = true\n      const parseResult =\n        vFor.parseResult ||\n        parseForExpression(vFor.exp as SimpleExpressionNode, context)\n      if (parseResult) {\n        // Render the dynamic slots as an array and add it to the createSlot()\n        // args. The runtime knows how to handle it appropriately.\n        dynamicSlots.push(\n          createCallExpression(context.helper(RENDER_LIST), [\n            parseResult.source,\n            createFunctionExpression(\n              createForLoopParams(parseResult),\n              buildDynamicSlot(slotName, slotFunction),\n              true\n            )\n          ])\n        )\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, vFor.loc)\n        )\n      }\n    } else {\n      // check duplicate static names\n      if (staticSlotName) {\n        if (seenSlotNames.has(staticSlotName)) {\n          context.onError(\n            createCompilerError(\n              ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES,\n              dirLoc\n            )\n          )\n          continue\n        }\n        seenSlotNames.add(staticSlotName)\n      }\n      slotsProperties.push(createObjectProperty(slotName, slotFunction))\n    }\n  }\n\n  if (hasTemplateSlots && extraneousChild) {\n    context.onError(\n      createCompilerError(\n        ErrorCodes.X_V_SLOT_EXTRANEOUS_NON_SLOT_CHILDREN,\n        extraneousChild.loc\n      )\n    )\n  }\n\n  if (!explicitDefaultSlot && !hasTemplateSlots) {\n    // implicit default slot.\n    slotsProperties.push(buildDefaultSlot(undefined, children, loc))\n  }\n\n  let slots: ObjectExpression | CallExpression = createObjectExpression(\n    slotsProperties.concat(\n      createObjectProperty(`_compiled`, createSimpleExpression(`true`, false))\n    ),\n    loc\n  )\n  if (dynamicSlots.length) {\n    slots = createCallExpression(context.helper(CREATE_SLOTS), [\n      slots,\n      createArrayExpression(dynamicSlots)\n    ])\n  }\n\n  return {\n    slots,\n    hasDynamicSlots\n  }\n}\n\nfunction buildDefaultSlot(\n  slotProps: ExpressionNode | undefined,\n  children: TemplateChildNode[],\n  loc: SourceLocation\n): Property {\n  return createObjectProperty(\n    `default`,\n    createFunctionExpression(\n      slotProps,\n      children,\n      false,\n      children.length ? children[0].loc : loc\n    )\n  )\n}\n\nfunction buildDynamicSlot(\n  name: ExpressionNode,\n  fn: FunctionExpression\n): ObjectExpression {\n  return createObjectExpression([\n    createObjectProperty(`name`, name),\n    createObjectProperty(`fn`, fn)\n  ])\n}\n","import { NodeTransform, TransformContext } from '../transform'\nimport {\n  NodeTypes,\n  ElementTypes,\n  CallExpression,\n  ObjectExpression,\n  ElementNode,\n  DirectiveNode,\n  ExpressionNode,\n  ArrayExpression,\n  createCallExpression,\n  createArrayExpression,\n  createObjectProperty,\n  createSimpleExpression,\n  createObjectExpression,\n  Property\n} from '../ast'\nimport { PatchFlags, PatchFlagNames, isSymbol } from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  CREATE_VNODE,\n  WITH_DIRECTIVES,\n  RESOLVE_DIRECTIVE,\n  RESOLVE_COMPONENT,\n  RESOLVE_DYNAMIC_COMPONENT,\n  MERGE_PROPS,\n  TO_HANDLERS,\n  PORTAL,\n  SUSPENSE\n} from '../runtimeHelpers'\nimport { getInnerRange, isVSlot, toValidAssetId, findProp } from '../utils'\nimport { buildSlots } from './vSlot'\nimport { isStaticNode } from './hoistStatic'\n\n// some directive transforms (e.g. v-model) may return a symbol for runtime\n// import, which should be used instead of a resolveDirective call.\nconst directiveImportMap = new WeakMap<DirectiveNode, symbol>()\n\n// generate a JavaScript AST for this element's codegen\nexport const transformElement: NodeTransform = (node, context) => {\n  if (\n    node.type !== NodeTypes.ELEMENT ||\n    // handled by transformSlotOutlet\n    node.tagType === ElementTypes.SLOT ||\n    // <template v-if/v-for> should have already been replaced\n    // <templte v-slot> is handled by buildSlots\n    (node.tagType === ElementTypes.TEMPLATE && node.props.some(isVSlot))\n  ) {\n    return\n  }\n  // perform the work on exit, after all child expressions have been\n  // processed and merged.\n  return () => {\n    const isComponent = node.tagType === ElementTypes.COMPONENT\n    let hasProps = node.props.length > 0\n    let patchFlag: number = 0\n    let runtimeDirectives: DirectiveNode[] | undefined\n    let dynamicPropNames: string[] | undefined\n    let dynamicComponent: string | CallExpression | undefined\n\n    // handle dynamic component\n    const isProp = findProp(node, 'is')\n    if (node.tag === 'component') {\n      if (isProp) {\n        // static <component is=\"foo\" />\n        if (isProp.type === NodeTypes.ATTRIBUTE) {\n          const tag = isProp.value && isProp.value.content\n          if (tag) {\n            context.helper(RESOLVE_COMPONENT)\n            context.components.add(tag)\n            dynamicComponent = toValidAssetId(tag, `component`)\n          }\n        }\n        // dynamic <component :is=\"asdf\" />\n        else if (isProp.exp) {\n          dynamicComponent = createCallExpression(\n            context.helper(RESOLVE_DYNAMIC_COMPONENT),\n            [isProp.exp]\n          )\n        }\n      }\n    }\n\n    if (isComponent && !dynamicComponent) {\n      context.helper(RESOLVE_COMPONENT)\n      context.components.add(node.tag)\n    }\n\n    const args: CallExpression['arguments'] = [\n      dynamicComponent\n        ? dynamicComponent\n        : isComponent\n          ? toValidAssetId(node.tag, `component`)\n          : node.tagType === ElementTypes.PORTAL\n            ? context.helper(PORTAL)\n            : node.tagType === ElementTypes.SUSPENSE\n              ? context.helper(SUSPENSE)\n              : `\"${node.tag}\"`\n    ]\n    // props\n    if (hasProps) {\n      const propsBuildResult = buildProps(\n        node,\n        context,\n        // skip reserved \"is\" prop <component is>\n        node.props.filter(p => p !== isProp)\n      )\n      patchFlag = propsBuildResult.patchFlag\n      dynamicPropNames = propsBuildResult.dynamicPropNames\n      runtimeDirectives = propsBuildResult.directives\n      if (!propsBuildResult.props) {\n        hasProps = false\n      } else {\n        args.push(propsBuildResult.props)\n      }\n    }\n    // children\n    const hasChildren = node.children.length > 0\n    if (hasChildren) {\n      if (!hasProps) {\n        args.push(`null`)\n      }\n      if (isComponent) {\n        const { slots, hasDynamicSlots } = buildSlots(node, context)\n        args.push(slots)\n        if (hasDynamicSlots) {\n          patchFlag |= PatchFlags.DYNAMIC_SLOTS\n        }\n      } else if (node.children.length === 1) {\n        const child = node.children[0]\n        const type = child.type\n        // check for dynamic text children\n        const hasDynamicTextChild =\n          type === NodeTypes.INTERPOLATION ||\n          type === NodeTypes.COMPOUND_EXPRESSION\n        if (hasDynamicTextChild && !isStaticNode(child)) {\n          patchFlag |= PatchFlags.TEXT\n        }\n        // pass directly if the only child is a text node\n        // (plain / interpolation / expression)\n        if (hasDynamicTextChild || type === NodeTypes.TEXT) {\n          args.push(child)\n        } else {\n          args.push(node.children)\n        }\n      } else {\n        args.push(node.children)\n      }\n    }\n    // patchFlag & dynamicPropNames\n    if (patchFlag !== 0) {\n      if (!hasChildren) {\n        if (!hasProps) {\n          args.push(`null`)\n        }\n        args.push(`null`)\n      }\n      if (__DEV__) {\n        const flagNames = Object.keys(PatchFlagNames)\n          .map(Number)\n          .filter(n => n > 0 && patchFlag & n)\n          .map(n => PatchFlagNames[n])\n          .join(`, `)\n        args.push(patchFlag + ` /* ${flagNames} */`)\n      } else {\n        args.push(patchFlag + '')\n      }\n      if (dynamicPropNames && dynamicPropNames.length) {\n        args.push(\n          `[${dynamicPropNames.map(n => JSON.stringify(n)).join(`, `)}]`\n        )\n      }\n    }\n\n    const { loc } = node\n    const vnode = createCallExpression(context.helper(CREATE_VNODE), args, loc)\n\n    if (runtimeDirectives && runtimeDirectives.length) {\n      node.codegenNode = createCallExpression(\n        context.helper(WITH_DIRECTIVES),\n        [\n          vnode,\n          createArrayExpression(\n            runtimeDirectives.map(dir => buildDirectiveArgs(dir, context)),\n            loc\n          )\n        ],\n        loc\n      )\n    } else {\n      node.codegenNode = vnode\n    }\n  }\n}\n\nexport type PropsExpression = ObjectExpression | CallExpression | ExpressionNode\n\nexport function buildProps(\n  node: ElementNode,\n  context: TransformContext,\n  props: ElementNode['props'] = node.props\n): {\n  props: PropsExpression | undefined\n  directives: DirectiveNode[]\n  patchFlag: number\n  dynamicPropNames: string[]\n} {\n  const elementLoc = node.loc\n  const isComponent = node.tagType === ElementTypes.COMPONENT\n  let properties: ObjectExpression['properties'] = []\n  const mergeArgs: PropsExpression[] = []\n  const runtimeDirectives: DirectiveNode[] = []\n\n  // patchFlag analysis\n  let patchFlag = 0\n  let hasRef = false\n  let hasClassBinding = false\n  let hasStyleBinding = false\n  let hasDynamicKeys = false\n  const dynamicPropNames: string[] = []\n\n  const analyzePatchFlag = ({ key, value }: Property) => {\n    if (key.type === NodeTypes.SIMPLE_EXPRESSION && key.isStatic) {\n      if (\n        value.type === NodeTypes.JS_CACHE_EXPRESSION ||\n        ((value.type === NodeTypes.SIMPLE_EXPRESSION ||\n          value.type === NodeTypes.COMPOUND_EXPRESSION) &&\n          isStaticNode(value))\n      ) {\n        return\n      }\n      const name = key.content\n      if (name === 'ref') {\n        hasRef = true\n      } else if (name === 'class') {\n        hasClassBinding = true\n      } else if (name === 'style') {\n        hasStyleBinding = true\n      } else if (name !== 'key') {\n        dynamicPropNames.push(name)\n      }\n    } else {\n      hasDynamicKeys = true\n    }\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    // static attribute\n    const prop = props[i]\n    if (prop.type === NodeTypes.ATTRIBUTE) {\n      const { loc, name, value } = prop\n      if (name === 'ref') {\n        hasRef = true\n      }\n      properties.push(\n        createObjectProperty(\n          createSimpleExpression(\n            name,\n            true,\n            getInnerRange(loc, 0, name.length)\n          ),\n          createSimpleExpression(\n            value ? value.content : '',\n            true,\n            value ? value.loc : loc\n          )\n        )\n      )\n    } else {\n      // directives\n      const { name, arg, exp, loc } = prop\n\n      // skip v-slot - it is handled by its dedicated transform.\n      if (name === 'slot') {\n        if (!isComponent) {\n          context.onError(\n            createCompilerError(ErrorCodes.X_V_SLOT_MISPLACED, loc)\n          )\n        }\n        continue\n      }\n\n      // special case for v-bind and v-on with no argument\n      const isBind = name === 'bind'\n      const isOn = name === 'on'\n      if (!arg && (isBind || isOn)) {\n        hasDynamicKeys = true\n        if (exp) {\n          if (properties.length) {\n            mergeArgs.push(\n              createObjectExpression(dedupeProperties(properties), elementLoc)\n            )\n            properties = []\n          }\n          if (isBind) {\n            mergeArgs.push(exp)\n          } else {\n            // v-on=\"obj\" -> toHandlers(obj)\n            mergeArgs.push({\n              type: NodeTypes.JS_CALL_EXPRESSION,\n              loc,\n              callee: context.helper(TO_HANDLERS),\n              arguments: [exp]\n            })\n          }\n        } else {\n          context.onError(\n            createCompilerError(\n              isBind\n                ? ErrorCodes.X_V_BIND_NO_EXPRESSION\n                : ErrorCodes.X_V_ON_NO_EXPRESSION,\n              loc\n            )\n          )\n        }\n        continue\n      }\n\n      const directiveTransform = context.directiveTransforms[name]\n      if (directiveTransform) {\n        // has built-in directive transform.\n        const { props, needRuntime } = directiveTransform(prop, node, context)\n        props.forEach(analyzePatchFlag)\n        properties.push(...props)\n        if (needRuntime) {\n          runtimeDirectives.push(prop)\n          if (isSymbol(needRuntime)) {\n            directiveImportMap.set(prop, needRuntime)\n          }\n        }\n      } else {\n        // no built-in transform, this is a user custom directive.\n        runtimeDirectives.push(prop)\n      }\n    }\n  }\n\n  let propsExpression: PropsExpression | undefined = undefined\n\n  // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\n  if (mergeArgs.length) {\n    if (properties.length) {\n      mergeArgs.push(\n        createObjectExpression(dedupeProperties(properties), elementLoc)\n      )\n    }\n    if (mergeArgs.length > 1) {\n      propsExpression = createCallExpression(\n        context.helper(MERGE_PROPS),\n        mergeArgs,\n        elementLoc\n      )\n    } else {\n      // single v-bind with nothing else - no need for a mergeProps call\n      propsExpression = mergeArgs[0]\n    }\n  } else if (properties.length) {\n    propsExpression = createObjectExpression(\n      dedupeProperties(properties),\n      elementLoc\n    )\n  }\n\n  // patchFlag analysis\n  if (hasDynamicKeys) {\n    patchFlag |= PatchFlags.FULL_PROPS\n  } else {\n    if (hasClassBinding) {\n      patchFlag |= PatchFlags.CLASS\n    }\n    if (hasStyleBinding) {\n      patchFlag |= PatchFlags.STYLE\n    }\n    if (dynamicPropNames.length) {\n      patchFlag |= PatchFlags.PROPS\n    }\n  }\n  if (patchFlag === 0 && (hasRef || runtimeDirectives.length > 0)) {\n    patchFlag |= PatchFlags.NEED_PATCH\n  }\n\n  return {\n    props: propsExpression,\n    directives: runtimeDirectives,\n    patchFlag,\n    dynamicPropNames\n  }\n}\n\n// Dedupe props in an object literal.\n// Literal duplicated attributes would have been warned during the parse phase,\n// however, it's possible to encounter duplicated `onXXX` handlers with different\n// modifiers. We also need to merge static and dynamic class / style attributes.\n// - onXXX handlers / style: merge into array\n// - class: merge into single expression with concatenation\nfunction dedupeProperties(properties: Property[]): Property[] {\n  const knownProps: Record<string, Property> = {}\n  const deduped: Property[] = []\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i]\n    // dynamic keys are always allowed\n    if (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {\n      deduped.push(prop)\n      continue\n    }\n    const name = prop.key.content\n    const existing = knownProps[name]\n    if (existing) {\n      if (\n        name === 'style' ||\n        name === 'class' ||\n        name.startsWith('on') ||\n        name.startsWith('vnode')\n      ) {\n        mergeAsArray(existing, prop)\n      }\n      // unexpected duplicate, should have emitted error during parse\n    } else {\n      knownProps[name] = prop\n      deduped.push(prop)\n    }\n  }\n  return deduped\n}\n\nfunction mergeAsArray(existing: Property, incoming: Property) {\n  if (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {\n    existing.value.elements.push(incoming.value)\n  } else {\n    existing.value = createArrayExpression(\n      [existing.value, incoming.value],\n      existing.loc\n    )\n  }\n}\n\nfunction buildDirectiveArgs(\n  dir: DirectiveNode,\n  context: TransformContext\n): ArrayExpression {\n  const dirArgs: ArrayExpression['elements'] = []\n  const runtime = directiveImportMap.get(dir)\n  if (runtime) {\n    context.helper(runtime)\n    dirArgs.push(context.helperString(runtime))\n  } else {\n    // inject statement for resolving directive\n    context.helper(RESOLVE_DIRECTIVE)\n    context.directives.add(dir.name)\n    dirArgs.push(toValidAssetId(dir.name, `directive`))\n  }\n  const { loc } = dir\n  if (dir.exp) dirArgs.push(dir.exp)\n  if (dir.arg) {\n    if (!dir.exp) {\n      dirArgs.push(`void 0`)\n    }\n    dirArgs.push(dir.arg)\n  }\n  if (Object.keys(dir.modifiers).length) {\n    if (!dir.arg) {\n      if (!dir.exp) {\n        dirArgs.push(`void 0`)\n      }\n      dirArgs.push(`void 0`)\n    }\n    dirArgs.push(\n      createObjectExpression(\n        dir.modifiers.map(modifier =>\n          createObjectProperty(\n            modifier,\n            createSimpleExpression(`true`, false, loc)\n          )\n        ),\n        loc\n      )\n    )\n  }\n  return createArrayExpression(dirArgs, dir.loc)\n}\n","import { NodeTransform } from '../transform'\nimport {\n  NodeTypes,\n  CallExpression,\n  createCallExpression,\n  ExpressionNode\n} from '../ast'\nimport { isSlotOutlet } from '../utils'\nimport { buildProps } from './transformElement'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { RENDER_SLOT } from '../runtimeHelpers'\n\nexport const transformSlotOutlet: NodeTransform = (node, context) => {\n  if (isSlotOutlet(node)) {\n    const { props, children, loc } = node\n    const $slots = context.prefixIdentifiers ? `_ctx.$slots` : `$slots`\n    let slotName: string | ExpressionNode = `\"default\"`\n\n    // check for <slot name=\"xxx\" OR :name=\"xxx\" />\n    let nameIndex: number = -1\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i]\n      if (prop.type === NodeTypes.ATTRIBUTE) {\n        if (prop.name === `name` && prop.value) {\n          // static name=\"xxx\"\n          slotName = JSON.stringify(prop.value.content)\n          nameIndex = i\n          break\n        }\n      } else if (prop.name === `bind`) {\n        const { arg, exp } = prop\n        if (\n          arg &&\n          exp &&\n          arg.type === NodeTypes.SIMPLE_EXPRESSION &&\n          arg.isStatic &&\n          arg.content === `name`\n        ) {\n          // dynamic :name=\"xxx\"\n          slotName = exp\n          nameIndex = i\n          break\n        }\n      }\n    }\n\n    const slotArgs: CallExpression['arguments'] = [$slots, slotName]\n    const propsWithoutName =\n      nameIndex > -1\n        ? props.slice(0, nameIndex).concat(props.slice(nameIndex + 1))\n        : props\n    let hasProps = propsWithoutName.length > 0\n    if (hasProps) {\n      const { props: propsExpression, directives } = buildProps(\n        node,\n        context,\n        propsWithoutName\n      )\n      if (directives.length) {\n        context.onError(\n          createCompilerError(\n            ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\n            directives[0].loc\n          )\n        )\n      }\n      if (propsExpression) {\n        slotArgs.push(propsExpression)\n      } else {\n        hasProps = false\n      }\n    }\n\n    if (children.length) {\n      if (!hasProps) {\n        slotArgs.push(`{}`)\n      }\n      slotArgs.push(children)\n    }\n\n    node.codegenNode = createCallExpression(\n      context.helper(RENDER_SLOT),\n      slotArgs,\n      loc\n    )\n  }\n}\n","import { DirectiveTransform, DirectiveTransformResult } from '../transform'\nimport {\n  DirectiveNode,\n  createObjectProperty,\n  createSimpleExpression,\n  ExpressionNode,\n  NodeTypes,\n  createCompoundExpression,\n  SimpleExpressionNode\n} from '../ast'\nimport { capitalize } from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { processExpression } from './transformExpression'\nimport { isMemberExpression, hasScopeRef } from '../utils'\n\nconst fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/\n\nexport interface VOnDirectiveNode extends DirectiveNode {\n  // v-on without arg is handled directly in ./element.ts due to it affecting\n  // codegen for the entire props object. This transform here is only for v-on\n  // *with* args.\n  arg: ExpressionNode\n  // exp is guaranteed to be a simple expression here because v-on w/ arg is\n  // skipped by transformExpression as a special case.\n  exp: SimpleExpressionNode | undefined\n}\n\nexport const transformOn: DirectiveTransform = (\n  dir: VOnDirectiveNode,\n  node,\n  context,\n  augmentor\n) => {\n  const { loc, modifiers, arg } = dir\n  if (!dir.exp && !modifiers.length) {\n    context.onError(createCompilerError(ErrorCodes.X_V_ON_NO_EXPRESSION, loc))\n  }\n  let eventName: ExpressionNode\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n    if (arg.isStatic) {\n      eventName = createSimpleExpression(\n        `on${capitalize(arg.content)}`,\n        true,\n        arg.loc\n      )\n    } else {\n      eventName = createCompoundExpression([`\"on\" + (`, arg, `)`])\n    }\n  } else {\n    // already a compound expression.\n    eventName = arg\n    eventName.children.unshift(`\"on\" + (`)\n    eventName.children.push(`)`)\n  }\n\n  // handler processing\n  let exp: ExpressionNode | undefined = dir.exp\n  let isCacheable: boolean = !exp\n  if (exp) {\n    const isMemberExp = isMemberExpression(exp.content)\n    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))\n\n    // process the expression since it's been skipped\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      context.addIdentifiers(`$event`)\n      exp = processExpression(exp, context)\n      context.removeIdentifiers(`$event`)\n      // with scope analysis, the function is hoistable if it has no reference\n      // to scope variables.\n      isCacheable =\n        context.cacheHandlers && !hasScopeRef(exp, context.identifiers)\n      // If the expression is optimizable and is a member expression pointing\n      // to a function, turn it into invocation (and wrap in an arrow function\n      // below) so that it always accesses the latest value when called - thus\n      // avoiding the need to be patched.\n      if (isCacheable && isMemberExp) {\n        if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          exp.content += `($event)`\n        } else {\n          exp.children.push(`($event)`)\n        }\n      }\n    }\n\n    if (isInlineStatement || (isCacheable && isMemberExp)) {\n      // wrap inline statement in a function expression\n      exp = createCompoundExpression([\n        `$event => (`,\n        ...(exp.type === NodeTypes.SIMPLE_EXPRESSION ? [exp] : exp.children),\n        `)`\n      ])\n    }\n  }\n\n  let ret: DirectiveTransformResult = {\n    props: [\n      createObjectProperty(\n        eventName,\n        exp || createSimpleExpression(`() => {}`, false, loc)\n      )\n    ],\n    needRuntime: false\n  }\n\n  // apply extended compiler augmentor\n  if (augmentor) {\n    ret = augmentor(ret)\n  }\n\n  if (isCacheable) {\n    // cache handlers so that it's always the same handler being passed down.\n    // this avoids unnecessary re-renders when users use inline hanlders on\n    // components.\n    ret.props[0].value = context.cache(ret.props[0].value)\n  }\n\n  return ret\n}\n","import { DirectiveTransform } from '../transform'\nimport { createObjectProperty, createSimpleExpression, NodeTypes } from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { camelize } from '@vue/shared'\nimport { CAMELIZE } from '../runtimeHelpers'\n\n// v-bind without arg is handled directly in ./element.ts due to it affecting\n// codegen for the entire props object. This transform here is only for v-bind\n// *with* args.\nexport const transformBind: DirectiveTransform = (dir, node, context) => {\n  const { exp, modifiers, loc } = dir\n  const arg = dir.arg!\n  if (!exp) {\n    context.onError(createCompilerError(ErrorCodes.X_V_BIND_NO_EXPRESSION, loc))\n  }\n  // .prop is no longer necessary due to new patch behavior\n  // .sync is replaced by v-model:arg\n  if (modifiers.includes('camel')) {\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n      if (arg.isStatic) {\n        arg.content = camelize(arg.content)\n      } else {\n        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`\n      }\n    } else {\n      arg.children.unshift(`${context.helperString(CAMELIZE)}(`)\n      arg.children.push(`)`)\n    }\n  }\n  return {\n    props: [\n      createObjectProperty(arg!, exp || createSimpleExpression('', true, loc))\n    ],\n    needRuntime: false\n  }\n}\n","import { NodeTransform } from '../transform'\nimport {\n  NodeTypes,\n  TemplateChildNode,\n  TextNode,\n  InterpolationNode,\n  CompoundExpressionNode,\n  createCallExpression\n} from '../ast'\nimport { TEXT, CREATE_VNODE } from '../runtimeHelpers'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\n\nconst isText = (\n  node: TemplateChildNode\n): node is TextNode | InterpolationNode =>\n  node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT\n\n// Merge adjacent text nodes and expressions into a single expression\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\nexport const transformText: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.ROOT || node.type === NodeTypes.ELEMENT) {\n    // perform the transform on node exit so that all expressions have already\n    // been processed.\n    return () => {\n      const children = node.children\n      let currentContainer: CompoundExpressionNode | undefined = undefined\n      let hasText = false\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n        if (isText(child)) {\n          hasText = true\n          for (let j = i + 1; j < children.length; j++) {\n            const next = children[j]\n            if (isText(next)) {\n              if (!currentContainer) {\n                currentContainer = children[i] = {\n                  type: NodeTypes.COMPOUND_EXPRESSION,\n                  loc: child.loc,\n                  children: [child]\n                }\n              }\n              // merge adjacent text node into current\n              currentContainer.children.push(` + `, next)\n              children.splice(j, 1)\n              j--\n            } else {\n              currentContainer = undefined\n              break\n            }\n          }\n        }\n      }\n\n      if (hasText && children.length > 1) {\n        // when an element has mixed text/element children, convert text nodes\n        // into createVNode(Text) calls.\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i]\n          if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {\n            const callArgs = [context.helper(TEXT), `null`, child]\n            if (child.type !== NodeTypes.TEXT) {\n              callArgs.push(\n                `${PatchFlags.TEXT} /* ${PatchFlagNames[PatchFlags.TEXT]} */`\n              )\n            }\n            children[i] = {\n              type: NodeTypes.TEXT_CALL,\n              content: child,\n              loc: child.loc,\n              codegenNode: createCallExpression(\n                context.helper(CREATE_VNODE),\n                callArgs\n              )\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import {\n  DirectiveTransform,\n  createObjectProperty,\n  createSimpleExpression\n} from '@vue/compiler-core'\n\nexport const transformOnce: DirectiveTransform = dir => {\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`$once`, true, dir.loc),\n        createSimpleExpression('true', false)\n      )\n    ],\n    needRuntime: false\n  }\n}\n","import { DirectiveTransform } from '../transform'\nimport {\n  createSimpleExpression,\n  createObjectProperty,\n  createCompoundExpression,\n  NodeTypes,\n  Property,\n  ElementTypes\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { isMemberExpression, isSimpleIdentifier, hasScopeRef } from '../utils'\n\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\n  const { exp, arg } = dir\n  if (!exp) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_NO_EXPRESSION, dir.loc)\n    )\n    return createTransformProps()\n  }\n\n  const expString =\n    exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : exp.loc.source\n  if (!isMemberExpression(expString)) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION, exp.loc)\n    )\n    return createTransformProps()\n  }\n\n  if (\n    !__BROWSER__ &&\n    context.prefixIdentifiers &&\n    isSimpleIdentifier(expString) &&\n    context.identifiers[expString]\n  ) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE, exp.loc)\n    )\n    return createTransformProps()\n  }\n\n  const propName = arg ? arg : createSimpleExpression('modelValue', true)\n  const eventName = arg\n    ? arg.type === NodeTypes.SIMPLE_EXPRESSION && arg.isStatic\n      ? createSimpleExpression('onUpdate:' + arg.content, true)\n      : createCompoundExpression([\n          createSimpleExpression('onUpdate:', true),\n          '+',\n          ...(arg.type === NodeTypes.SIMPLE_EXPRESSION ? [arg] : arg.children)\n        ])\n    : createSimpleExpression('onUpdate:modelValue', true)\n\n  const props = [\n    // modelValue: foo\n    createObjectProperty(propName, dir.exp!),\n    // \"onUpdate:modelValue\": $event => (foo = $event)\n    createObjectProperty(\n      eventName,\n      createCompoundExpression([\n        `$event => (`,\n        ...(exp.type === NodeTypes.SIMPLE_EXPRESSION ? [exp] : exp.children),\n        ` = $event)`\n      ])\n    )\n  ]\n\n  // cache v-model handler if applicable (when it doesn't refer any scope vars)\n  if (\n    !__BROWSER__ &&\n    context.prefixIdentifiers &&\n    !hasScopeRef(exp, context.identifiers)\n  ) {\n    props[1].value = context.cache(props[1].value)\n  }\n\n  // modelModifiers: { foo: true, \"bar-baz\": true }\n  if (dir.modifiers.length && node.tagType === ElementTypes.COMPONENT) {\n    const modifiers = dir.modifiers\n      .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\n      .join(`, `)\n    props.push(\n      createObjectProperty(\n        `modelModifiers`,\n        createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, true)\n      )\n    )\n  }\n\n  return createTransformProps(props)\n}\n\nfunction createTransformProps(props: Property[] = []) {\n  return { props, needRuntime: false }\n}\n","const range: number = 2\n\nexport function generateCodeFrame(\n  source: string,\n  start: number = 0,\n  end: number = source.length\n): string {\n  const lines = source.split(/\\r?\\n/)\n  let count = 0\n  const res = []\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue\n        res.push(\n          `${j + 1}${' '.repeat(3 - String(j + 1).length)}|  ${lines[j]}`\n        )\n        const lineLength = lines[j].length\n        if (j === i) {\n          // push underline\n          const pad = start - (count - lineLength) + 1\n          const length = end > count ? lineLength - pad : end - start\n          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length))\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.min(end - count, lineLength)\n            res.push(`   |  ` + '^'.repeat(length))\n          }\n          count += lineLength + 1\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n","import { parse, ParserOptions } from './parse'\nimport { transform, TransformOptions } from './transform'\nimport { generate, CodegenOptions, CodegenResult } from './codegen'\nimport { RootNode } from './ast'\nimport { isString } from '@vue/shared'\nimport { transformIf } from './transforms/vIf'\nimport { transformFor } from './transforms/vFor'\nimport { transformExpression } from './transforms/transformExpression'\nimport { transformSlotOutlet } from './transforms/transformSlotOutlet'\nimport { transformElement } from './transforms/transformElement'\nimport { transformOn } from './transforms/vOn'\nimport { transformBind } from './transforms/vBind'\nimport { defaultOnError, createCompilerError, ErrorCodes } from './errors'\nimport { trackSlotScopes, trackVForSlotScopes } from './transforms/vSlot'\nimport { transformText } from './transforms/transformText'\nimport { transformOnce } from './transforms/vOnce'\nimport { transformModel } from './transforms/vModel'\n\nexport type CompilerOptions = ParserOptions & TransformOptions & CodegenOptions\n\n// we name it `baseCompile` so that higher order compilers like @vue/compiler-dom\n// can export `compile` while re-exporting everything else.\nexport function baseCompile(\n  template: string | RootNode,\n  options: CompilerOptions = {}\n): CodegenResult {\n  /* istanbul ignore if */\n  if (__BROWSER__) {\n    const onError = options.onError || defaultOnError\n    if (options.prefixIdentifiers === true) {\n      onError(createCompilerError(ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED))\n    } else if (options.mode === 'module') {\n      onError(createCompilerError(ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED))\n    }\n  }\n\n  const ast = isString(template) ? parse(template, options) : template\n\n  const prefixIdentifiers =\n    !__BROWSER__ &&\n    (options.prefixIdentifiers === true || options.mode === 'module')\n\n  transform(ast, {\n    ...options,\n    prefixIdentifiers,\n    nodeTransforms: [\n      transformIf,\n      transformFor,\n      ...(prefixIdentifiers\n        ? [\n            // order is important\n            trackVForSlotScopes,\n            transformExpression\n          ]\n        : []),\n      transformSlotOutlet,\n      transformElement,\n      trackSlotScopes,\n      transformText,\n      ...(options.nodeTransforms || []) // user transforms\n    ],\n    directiveTransforms: {\n      on: transformOn,\n      bind: transformBind,\n      once: transformOnce,\n      model: transformModel,\n      ...(options.directiveTransforms || {}) // user transforms\n    }\n  })\n\n  return generate(ast, {\n    ...options,\n    prefixIdentifiers\n  })\n}\n\n// Also expose lower level APIs & types\nexport { parse, ParserOptions, TextModes } from './parse'\nexport {\n  transform,\n  createStructuralDirectiveTransform,\n  TransformOptions,\n  TransformContext,\n  NodeTransform,\n  StructuralDirectiveTransform,\n  DirectiveTransform\n} from './transform'\nexport {\n  generate,\n  CodegenOptions,\n  CodegenContext,\n  CodegenResult\n} from './codegen'\nexport {\n  ErrorCodes,\n  CoreCompilerError,\n  CompilerError,\n  createCompilerError\n} from './errors'\nexport * from './ast'\nexport * from './utils'\nexport * from './codeframe'\nexport { registerRuntimeHelpers } from './runtimeHelpers'\n\n// expose transforms so higher-order compilers can import and extend them\nexport { transformModel } from './transforms/vModel'\nexport { transformOn } from './transforms/vOn'\n","import { makeMap } from '../../shared/src/makeMap'\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS =\n  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n  'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +\n  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n  'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +\n  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n  'option,output,progress,select,textarea,details,dialog,menu,menuitem,' +\n  'summary,content,element,shadow,template,blockquote,iframe,tfoot'\n\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS =\n  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n  'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n  'foreignObject,g,hatch,hatchpath,image,line,lineGradient,marker,mask,' +\n  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n  'text,textPath,title,tspan,unknown,use,view'\n\nconst VOID_TAGS =\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\n\nexport const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)\nexport const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)\nexport const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)\n","import {\n  TextModes,\n  ParserOptions,\n  ElementNode,\n  Namespaces,\n  NodeTypes\n} from '@vue/compiler-core'\nimport { isVoidTag, isHTMLTag, isSVGTag } from './tagConfig'\n\nexport const enum DOMNamespaces {\n  HTML = Namespaces.HTML,\n  SVG,\n  MATH_ML\n}\n\nexport const parserOptionsMinimal: ParserOptions = {\n  isVoidTag,\n\n  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),\n\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace(tag: string, parent: ElementNode | undefined): DOMNamespaces {\n    let ns = parent ? parent.ns : DOMNamespaces.HTML\n\n    if (parent && ns === DOMNamespaces.MATH_ML) {\n      if (parent.tag === 'annotation-xml') {\n        if (tag === 'svg') {\n          return DOMNamespaces.SVG\n        }\n        if (\n          parent.props.some(\n            a =>\n              a.type === NodeTypes.ATTRIBUTE &&\n              a.name === 'encoding' &&\n              a.value != null &&\n              (a.value.content === 'text/html' ||\n                a.value.content === 'application/xhtml+xml')\n          )\n        ) {\n          ns = DOMNamespaces.HTML\n        }\n      } else if (\n        /^m(?:[ions]|text)$/.test(parent.tag) &&\n        tag !== 'mglyph' &&\n        tag !== 'malignmark'\n      ) {\n        ns = DOMNamespaces.HTML\n      }\n    } else if (parent && ns === DOMNamespaces.SVG) {\n      if (\n        parent.tag === 'foreignObject' ||\n        parent.tag === 'desc' ||\n        parent.tag === 'title'\n      ) {\n        ns = DOMNamespaces.HTML\n      }\n    }\n\n    if (ns === DOMNamespaces.HTML) {\n      if (tag === 'svg') {\n        return DOMNamespaces.SVG\n      }\n      if (tag === 'math') {\n        return DOMNamespaces.MATH_ML\n      }\n    }\n    return ns\n  },\n\n  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\n  getTextMode(tag: string, ns: DOMNamespaces): TextModes {\n    if (ns === DOMNamespaces.HTML) {\n      if (tag === 'textarea' || tag === 'title') {\n        return TextModes.RCDATA\n      }\n      if (\n        /^(?:style|xmp|iframe|noembed|noframes|script|noscript)$/i.test(tag)\n      ) {\n        return TextModes.RAWTEXT\n      }\n    }\n    return TextModes.DATA\n  }\n}\n","import {\n  NodeTransform,\n  NodeTypes,\n  createSimpleExpression\n} from '@vue/compiler-core'\n\n// Parse inline CSS strings for static style attributes into an object.\n// This is a NodeTransform since it works on the static `style` attribute and\n// converts it into a dynamic equivalent:\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\n// It is then processed by `transformElement` and included in the generated\n// props.\nexport const transformStyle: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.ELEMENT) {\n    node.props.forEach((p, i) => {\n      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {\n        // replace p with an expression node\n        const parsed = JSON.stringify(parseInlineCSS(p.value.content))\n        const exp = context.hoist(createSimpleExpression(parsed, false, p.loc))\n        node.props[i] = {\n          type: NodeTypes.DIRECTIVE,\n          name: `bind`,\n          arg: createSimpleExpression(`style`, true, p.loc),\n          exp,\n          modifiers: [],\n          loc: p.loc\n        }\n      }\n    })\n  }\n}\n\nconst listDelimiterRE = /;(?![^(]*\\))/g\nconst propertyDelimiterRE = /:(.+)/\n\nfunction parseInlineCSS(cssText: string): Record<string, string> {\n  const res: Record<string, string> = {}\n  cssText.split(listDelimiterRE).forEach(function(item) {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE)\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim())\n    }\n  })\n  return res\n}\n","import { DirectiveTransform } from 'packages/compiler-core/src/transform'\n\nexport const transformCloak: DirectiveTransform = (node, context) => {\n  return { props: [], needRuntime: false }\n}\n","import {\n  SourceLocation,\n  CompilerError,\n  createCompilerError,\n  ErrorCodes\n} from '@vue/compiler-core'\n\nexport interface DOMCompilerError extends CompilerError {\n  code: DOMErrorCodes\n}\n\nexport function createDOMCompilerError(\n  code: DOMErrorCodes,\n  loc?: SourceLocation\n): DOMCompilerError {\n  return createCompilerError(\n    code,\n    loc,\n    __DEV__ || !__BROWSER__ ? DOMErrorMessages : undefined\n  )\n}\n\nexport const enum DOMErrorCodes {\n  X_V_HTML_NO_EXPRESSION = ErrorCodes.__EXTEND_POINT__,\n  X_V_HTML_WITH_CHILDREN,\n  X_V_TEXT_NO_EXPRESSION,\n  X_V_TEXT_WITH_CHILDREN,\n  X_V_MODEL_ON_INVALID_ELEMENT,\n  X_V_MODEL_ARG_ON_ELEMENT,\n  X_V_MODEL_ON_FILE_INPUT_ELEMENT\n}\n\nexport const DOMErrorMessages: { [code: number]: string } = {\n  [DOMErrorCodes.X_V_HTML_NO_EXPRESSION]: `v-html is missing expression.`,\n  [DOMErrorCodes.X_V_HTML_WITH_CHILDREN]: `v-html will override element children.`,\n  [DOMErrorCodes.X_V_TEXT_NO_EXPRESSION]: `v-text is missing expression.`,\n  [DOMErrorCodes.X_V_TEXT_WITH_CHILDREN]: `v-text will override element children.`,\n  [DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\n  [DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT]: `v-model argument is not supported on plain elements.`,\n  [DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT]: `v-model cannot used on file inputs since they are read-only. Use a v-on:change listener instead.`\n}\n","import {\n  DirectiveTransform,\n  createObjectProperty,\n  createSimpleExpression\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\n\nexport const transformVHtml: DirectiveTransform = (dir, node, context) => {\n  const { exp, loc } = dir\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_NO_EXPRESSION, loc)\n    )\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_WITH_CHILDREN, loc)\n    )\n    node.children.length = 0\n  }\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`innerHTML`, true, loc),\n        exp || createSimpleExpression('', true)\n      )\n    ],\n    needRuntime: false\n  }\n}\n","import {\n  DirectiveTransform,\n  createObjectProperty,\n  createSimpleExpression\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\n\nexport const transformVText: DirectiveTransform = (dir, node, context) => {\n  const { exp, loc } = dir\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_NO_EXPRESSION, loc)\n    )\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_WITH_CHILDREN, loc)\n    )\n    node.children.length = 0\n  }\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`textContent`, true, loc),\n        exp || createSimpleExpression('', true)\n      )\n    ],\n    needRuntime: false\n  }\n}\n","import { registerRuntimeHelpers } from '@vue/compiler-core'\n\nexport const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)\nexport const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)\nexport const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)\nexport const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)\nexport const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)\n\nexport const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)\nexport const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)\n\nregisterRuntimeHelpers({\n  [V_MODEL_RADIO]: `vModelRadio`,\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\n  [V_MODEL_TEXT]: `vModelText`,\n  [V_MODEL_SELECT]: `vModelSelect`,\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\n  [V_ON_WITH_KEYS]: `withKeys`\n})\n","import {\n  transformModel as baseTransform,\n  DirectiveTransform,\n  ElementTypes,\n  findProp,\n  NodeTypes\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\nimport {\n  V_MODEL_CHECKBOX,\n  V_MODEL_RADIO,\n  V_MODEL_SELECT,\n  V_MODEL_TEXT,\n  V_MODEL_DYNAMIC\n} from '../runtimeHelpers'\n\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\n  const baseResult = baseTransform(dir, node, context)\n  // base transform has errors\n  if (!baseResult.props.length) {\n    return baseResult\n  }\n\n  const { tag, tagType } = node\n  if (tagType === ElementTypes.ELEMENT) {\n    if (dir.arg) {\n      context.onError(\n        createDOMCompilerError(\n          DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT,\n          dir.arg.loc\n        )\n      )\n    }\n\n    if (tag === 'input' || tag === 'textarea' || tag === 'select') {\n      let directiveToUse = V_MODEL_TEXT\n      let isInvalidType = false\n      if (tag === 'input') {\n        const type = findProp(node, `type`)\n        if (type) {\n          if (type.type === NodeTypes.DIRECTIVE) {\n            // :type=\"foo\"\n            directiveToUse = V_MODEL_DYNAMIC\n          } else if (type.value) {\n            switch (type.value.content) {\n              case 'radio':\n                directiveToUse = V_MODEL_RADIO\n                break\n              case 'checkbox':\n                directiveToUse = V_MODEL_CHECKBOX\n                break\n              case 'file':\n                isInvalidType = true\n                context.onError(\n                  createDOMCompilerError(\n                    DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT,\n                    dir.loc\n                  )\n                )\n                break\n            }\n          }\n        }\n      } else if (tag === 'select') {\n        directiveToUse = V_MODEL_SELECT\n      }\n      // inject runtime directive\n      // by returning the helper symbol via needRuntime\n      // the import will replaced a resolveDirective call.\n      if (!isInvalidType) {\n        baseResult.needRuntime = context.helper(directiveToUse)\n      }\n    } else {\n      context.onError(\n        createDOMCompilerError(\n          DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT,\n          dir.loc\n        )\n      )\n    }\n  }\n  return baseResult\n}\n","import {\n  transformOn as baseTransform,\n  DirectiveTransform,\n  createObjectProperty,\n  createCallExpression,\n  createObjectExpression,\n  createSimpleExpression,\n  NodeTypes\n} from '@vue/compiler-core'\nimport { V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS } from '../runtimeHelpers'\nimport { makeMap } from '@vue/shared'\n\nconst isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)\nconst isNonKeyModifier = /*#__PURE__*/ makeMap(\n  // event propagation management\n  `stop,prevent,self,` +\n    // system modifiers + exact\n    `ctrl,shift,alt,meta,exact,` +\n    // mouse\n    `left,middle,right`\n)\nconst isKeyboardEvent = /*#__PURE__*/ makeMap(\n  `onkeyup,onkeydown,onkeypress`,\n  true\n)\n\nexport const transformOn: DirectiveTransform = (dir, node, context) => {\n  return baseTransform(dir, node, context, baseResult => {\n    const { modifiers } = dir\n    if (!modifiers.length) return baseResult\n\n    let { key, value: handlerExp } = baseResult.props[0]\n\n    // modifiers for addEventListener() options, e.g. .passive & .capture\n    const eventOptionModifiers = modifiers.filter(isEventOptionModifier)\n    // modifiers that needs runtime guards\n    const runtimeModifiers = modifiers.filter(m => !isEventOptionModifier(m))\n\n    // built-in modifiers that are not keys\n    const nonKeyModifiers = runtimeModifiers.filter(isNonKeyModifier)\n    if (nonKeyModifiers.length) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\n        handlerExp,\n        JSON.stringify(nonKeyModifiers)\n      ])\n    }\n\n    const keyModifiers = runtimeModifiers.filter(m => !isNonKeyModifier(m))\n    if (\n      keyModifiers.length &&\n      // if event name is dynamic, always wrap with keys guard\n      (key.type === NodeTypes.COMPOUND_EXPRESSION ||\n        !key.isStatic ||\n        isKeyboardEvent(key.content))\n    ) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\n        handlerExp,\n        JSON.stringify(keyModifiers)\n      ])\n    }\n\n    if (eventOptionModifiers.length) {\n      handlerExp = createObjectExpression([\n        createObjectProperty('handler', handlerExp),\n        createObjectProperty(\n          'options',\n          createObjectExpression(\n            eventOptionModifiers.map(modifier =>\n              createObjectProperty(\n                modifier,\n                createSimpleExpression('true', false)\n              )\n            )\n          )\n        )\n      ])\n    }\n\n    return {\n      props: [createObjectProperty(key, handlerExp)],\n      needRuntime: false\n    }\n  })\n}\n","import { baseCompile, CompilerOptions, CodegenResult } from '@vue/compiler-core'\nimport { parserOptionsMinimal } from './parserOptionsMinimal'\nimport { parserOptionsStandard } from './parserOptionsStandard'\nimport { transformStyle } from './transforms/transformStyle'\nimport { transformCloak } from './transforms/vCloak'\nimport { transformVHtml } from './transforms/vHtml'\nimport { transformVText } from './transforms/vText'\nimport { transformModel } from './transforms/vModel'\nimport { transformOn } from './transforms/vOn'\n\nexport function compile(\n  template: string,\n  options: CompilerOptions = {}\n): CodegenResult {\n  return baseCompile(template, {\n    ...options,\n    ...(__BROWSER__ ? parserOptionsMinimal : parserOptionsStandard),\n    nodeTransforms: [transformStyle, ...(options.nodeTransforms || [])],\n    directiveTransforms: {\n      cloak: transformCloak,\n      html: transformVHtml,\n      text: transformVText,\n      model: transformModel, // override compiler-core\n      on: transformOn,\n      ...(options.directiveTransforms || {})\n    }\n  })\n}\n\nexport * from '@vue/compiler-core'\nexport * from './tagConfig'\n"],"names":["PatchFlagNames","1","2","4","8","32","16","64","128","256","[object Object]","makeMap","str","expectsLowerCase","map","Object","create","list","split","i","length","val","toLowerCase","NO","extend","a","b","key","isArray","Array","isFunction","isString","isSymbol","isObject","camelizeRE","defaultOnError","error","createCompilerError","code","loc","messages","msg","locInfo","start","line","column","SyntaxError","locStub","source","offset","end","createArrayExpression","elements","type","createObjectExpression","properties","createObjectProperty","value","createSimpleExpression","content","isStatic","isConstant","createInterpolation","createCompoundExpression","children","createCallExpression","callee","args","arguments","createFunctionExpression","params","returns","newline","createSequenceExpression","expressions","createConditionalExpression","test","consequent","alternate","createCacheExpression","index","FRAGMENT","Symbol","PORTAL","COMMENT","TEXT","SUSPENSE","OPEN_BLOCK","CREATE_BLOCK","CREATE_VNODE","RESOLVE_COMPONENT","RESOLVE_DYNAMIC_COMPONENT","RESOLVE_DIRECTIVE","WITH_DIRECTIVES","RENDER_LIST","RENDER_SLOT","CREATE_SLOTS","TO_STRING","MERGE_PROPS","TO_HANDLERS","CAMELIZE","helperNameMap","registerRuntimeHelpers","helpers","getOwnPropertySymbols","forEach","s","_parse","_walk","loadDep","name","process","require","window","_deps","parseJS","options","assert","parse","walkJS","ast","walker","walk","nonIdentifierRE","isSimpleIdentifier","memberExpRE","isMemberExpression","path","getInnerRange","newLoc","substr","advancePositionWithClone","pos","numberOfCharacters","advancePositionWithMutation","linesCount","lastNewLinePos","charCodeAt","Math","max","condition","Error","findDir","node","allowEmpty","props","p","exp","findProp","dynamicOnly","isEmpty","arg","createBlockExpression","blockExp","context","helper","isVSlot","isTemplateNode","tagType","isSlotOutlet","injectProp","prop","propsWithInjection","first","unshift","toValidAssetId","replace","isEmptyExpression","trim","hasScopeRef","ids","keys","some","c","branches","defaultParserOptions","delimiters","ignoreSpaces","getNamespace","getTextMode","isVoidTag","isCustomElement","namedCharacterReferences","gt;","lt;","amp;","apos;","quot;","onError","originalSource","maxCRNameLength","reduce","inPre","createParserContext","getCursor","parseChildren","components","directives","hoists","cached","codegenNode","undefined","getSelection","mode","ancestors","parent","last","ns","nodes","isEnd","startsWith","parseInterpolation","emitError","parseComment","parseBogusComment","parseCDATA","advanceBy","parseTag","parseElement","parseText","pushNode","prev","push","match","exec","slice","prevIndex","nestedIndex","indexOf","contentStart","closeIndex","wasInPre","element","isPreBoundary","isSelfClosing","tag","pop","startsWithEndTagOpen","advanceSpaces","cursor","currentSource","parseAttributes","filter","isNativeTag","attributeNames","Set","attr","parseAttribute","nameSet","has","add","pattern","m","quote","isQuoted","endIndex","parseTextData","unexpectedChars","parseAttributeValue","startOffset","shift","getNewPosition","endsWith","valueLoc","modifiers","open","close","innerStart","innerEnd","rawContentLength","rawContent","preTrimContent","min","n","text","head","remaining","semi","hex","body","cp","Number","parseInt","CCR_REPLACEMENTS","String","fromCodePoint","xs","searchString","130","131","132","133","134","135","136","137","138","139","140","142","145","146","147","148","149","150","151","152","153","154","155","156","158","159","hoistStatic","root","resultCache","doNotHoistNode","child","isStaticNode","hoist","flag","getPatchFlag","hasDynamicKeyOrRef","hasCachedProps","getVNodeArgAt","getVNodeCall","branchChildren","Map","isSingleElementRoot","get","set","every","transform","prefixIdentifiers","cacheHandlers","nodeTransforms","directiveTransforms","identifiers","scopes","vFor","vSlot","vPre","vOnce","currentNode","childIndex","helperString","removalIndex","onNodeRemoved","splice","cache","createTransformContext","traverseNode","finalizeRoot","traverseChildren","nodeRemoved","exitFns","onExit","createStructuralDirectiveTransform","fn","matches","generate","sourceMap","filename","indentLevel","openOnly","withoutNewLine","repeat","createCodegenContext","indent","deindent","hasHelpers","useWithBlock","join","includes","genHoists","genAssets","genNode","toJSON","assets","resolver","id","JSON","stringify","genNodeListAsArray","multilines","genNodeList","genText","genExpression","genInterpolation","genCompoundExpression","genCallExpression","resetMapping","genExpressionAsPropertyKey","lastChar","genObjectExpression","genArrayExpression","genFunctionExpression","genSequenceExpression","needsParens","isNested","genConditionalExpression","genCacheExpression","transformIf","dir","branch","createIfBranch","replaceNode","createCodegenNodeForBranch","siblings","sibling","removeNode","parentCondition","createChildrenCodegenNode","keyProperty","blockArgs","forBlockArgs","childCodegen","vnodeCall","transformFor","parseResult","parseForExpression","addIdentifiers","removeIdentifiers","renderExp","keyProp","fragmentFlag","valueAlias","keyAlias","objectIndexAlias","childBlock","isTemplate","slotOutlet","createForLoopParams","forAliasRE","forIteratorRE","stripParensRE","input","inMatch","LHS","RHS","result","createAliasExpression","valueContent","trimmedOffset","iteratorMatch","keyContent","keyOffset","indexContent","range","isStaticExp","defaultFallback","trackSlotScopes","buildDefaultSlot","slotProps","buildDynamicSlot","directiveImportMap","WeakMap","transformElement","isComponent","runtimeDirectives","dynamicPropNames","dynamicComponent","hasProps","patchFlag","isProp","propsBuildResult","buildProps","hasChildren","slots","hasDynamicSlots","slotsProperties","dynamicSlots","explicitDefaultSlot","hasTemplateSlots","extraneousChild","seenSlotNames","slotElement","slotDir","slotChildren","slotLoc","slotName","dirLoc","staticSlotName","slotFunction","vIf","vElse","j","conditional","concat","buildSlots","hasDynamicTextChild","vnode","dirArgs","runtime","modifier","buildDirectiveArgs","elementLoc","mergeArgs","hasRef","hasClassBinding","hasStyleBinding","hasDynamicKeys","analyzePatchFlag","isBind","isOn","dedupeProperties","directiveTransform","needRuntime","propsExpression","knownProps","deduped","existing","mergeAsArray","incoming","transformSlotOutlet","$slots","nameIndex","slotArgs","propsWithoutName","fnExpRE","transformOn","augmentor","eventName","charAt","toUpperCase","capitalize","isCacheable","isMemberExp","ret","transformBind","_","camelize","isText","transformText","currentContainer","hasText","next","callArgs","transformOnce","transformModel","createTransformProps","expString","propName","generateCodeFrame","lines","count","res","lineLength","pad","baseCompile","template","on","bind","once","model","isHTMLTag","isSVGTag","parserOptionsMinimal","transformStyle","parsed","cssText","listDelimiterRE","item","tmp","propertyDelimiterRE","parseInlineCSS","transformCloak","createDOMCompilerError","transformVHtml","transformVText","V_MODEL_RADIO","V_MODEL_CHECKBOX","V_MODEL_TEXT","V_MODEL_SELECT","V_MODEL_DYNAMIC","V_ON_WITH_MODIFIERS","V_ON_WITH_KEYS","baseResult","baseTransform","directiveToUse","isInvalidType","isEventOptionModifier","isNonKeyModifier","isKeyboardEvent","handlerExp","eventOptionModifiers","runtimeModifiers","nonKeyModifiers","keyModifiers","compile","cloak","html"],"mappings":"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"}