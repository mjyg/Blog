{"version":3,"file":"compiler-dom.global.prod.js","sources":["../../shared/src/patchFlags.ts","../../shared/src/makeMap.ts","../../shared/src/index.ts","../../compiler-core/src/errors.ts","../../compiler-core/src/ast.ts","../../compiler-core/src/runtimeHelpers.ts","../../compiler-core/src/utils.ts","../../compiler-core/src/parse.ts","../../compiler-core/src/transforms/hoistStatic.ts","../../compiler-core/src/transform.ts","../../compiler-core/src/codegen.ts","../../compiler-core/src/transforms/vIf.ts","../../compiler-core/src/transforms/vFor.ts","../../compiler-core/src/transforms/vSlot.ts","../../compiler-core/src/transforms/transformElement.ts","../../compiler-core/src/transforms/transformSlotOutlet.ts","../../compiler-core/src/transforms/vOn.ts","../../compiler-core/src/transforms/vBind.ts","../../compiler-core/src/transforms/transformText.ts","../../compiler-core/src/transforms/vOnce.ts","../../compiler-core/src/transforms/vModel.ts","../../compiler-core/src/codeframe.ts","../../compiler-core/src/index.ts","../src/tagConfig.ts","../src/parserOptionsMinimal.ts","../src/transforms/transformStyle.ts","../src/transforms/vCloak.ts","../src/errors.ts","../src/transforms/vHtml.ts","../src/transforms/vText.ts","../src/runtimeHelpers.ts","../src/transforms/vModel.ts","../src/transforms/vOn.ts","../src/index.ts"],"sourcesContent":["// Patch flags are optimization hints generated by the compiler.\n// when a block with dynamicChildren is encountered during diff, the algorithm\n// enters \"optimized mode\". In this mode, we know that the vdom is produced by\n// a render function generated by the compiler, so the algorithm only needs to\n// handle updates explicitly marked by these patch flags.\n\n// Patch flags can be combined using the | bitwise operator and can be checked\n// using the & operator, e.g.\n//\n//   const flag = TEXT | CLASS\n//   if (flag & TEXT) { ... }\n//\n// Check the `patchElement` function in './createRenderer.ts' to see how the\n// flags are handled during diff.\n\nexport const enum PatchFlags {\n  // Indicates an element with dynamic textContent (children fast path)\n  TEXT = 1,\n\n  // Indicates an element with dynamic class binding.\n  CLASS = 1 << 1,\n\n  // Indicates an element with dynamic style\n  // The compiler pre-compiles static string styles into static objects\n  // + detects and hoists inline static objects\n  // e.g. style=\"color: red\" and :style=\"{ color: 'red' }\" both get hoisted as\n  //   const style = { color: 'red' }\n  //   render() { return e('div', { style }) }\n  STYLE = 1 << 2,\n\n  // Indicates an element that has non-class/style dynamic props.\n  // Can also be on a component that has any dynamic props (includes\n  // class/style). when this flag is present, the vnode also has a dynamicProps\n  // array that contains the keys of the props that may change so the runtime\n  // can diff them faster (without having to worry about removed props)\n  PROPS = 1 << 3,\n\n  // Indicates an element with props with dynamic keys. When keys change, a full\n  // diff is always needed to remove the old key. This flag is mutually\n  // exclusive with CLASS, STYLE and PROPS.\n  FULL_PROPS = 1 << 4,\n\n  // Indicates an element that only needs non-props patching, e.g. ref or\n  // directives (onVnodeXXX hooks). It simply marks the vnode as \"need patch\",\n  // since every patched vnode checks for refs and onVnodeXXX hooks.\n  // This flag is never directly matched against, it simply serves as a non-zero\n  // value.\n  NEED_PATCH = 1 << 5,\n\n  // Indicates a fragment with keyed or partially keyed children\n  KEYED_FRAGMENT = 1 << 6,\n\n  // Indicates a fragment with unkeyed children.\n  UNKEYED_FRAGMENT = 1 << 7,\n\n  // Indicates a component with dynamic slots (e.g. slot that references a v-for\n  // iterated value, or dynamic slot names).\n  // Components with this flag are always force updated.\n  DYNAMIC_SLOTS = 1 << 8,\n\n  // A special flag that indicates that the diffing algorithm should bail out\n  // of optimized mode. This is only on block fragments created by renderSlot()\n  // when encountering non-compiler generated slots (i.e. manually written\n  // render functions, which should always be fully diffed)\n  BAIL = -1\n}\n\n// runtime object for public consumption\nexport const PublicPatchFlags = {\n  TEXT: PatchFlags.TEXT,\n  CLASS: PatchFlags.CLASS,\n  STYLE: PatchFlags.STYLE,\n  PROPS: PatchFlags.PROPS,\n  NEED_PATCH: PatchFlags.NEED_PATCH,\n  FULL_PROPS: PatchFlags.FULL_PROPS,\n  KEYED_FRAGMENT: PatchFlags.KEYED_FRAGMENT,\n  UNKEYED_FRAGMENT: PatchFlags.UNKEYED_FRAGMENT,\n  DYNAMIC_SLOTS: PatchFlags.DYNAMIC_SLOTS,\n  BAIL: PatchFlags.BAIL\n}\n\n// dev only flag -> name mapping\nexport const PatchFlagNames = {\n  [PatchFlags.TEXT]: `TEXT`,\n  [PatchFlags.CLASS]: `CLASS`,\n  [PatchFlags.STYLE]: `STYLE`,\n  [PatchFlags.PROPS]: `PROPS`,\n  [PatchFlags.NEED_PATCH]: `NEED_PATCH`,\n  [PatchFlags.FULL_PROPS]: `FULL_PROPS`,\n  [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`,\n  [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`,\n  [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`,\n  [PatchFlags.BAIL]: `BAIL`\n}\n","// Make a map and return a function for checking if a key\n// is in that map.\n//\n// IMPORTANT: all calls of this function must be prefixed with /*#__PURE__*/\n// So that rollup can tree-shake them if necessary.\nexport function makeMap(\n  str: string,\n  expectsLowerCase?: boolean\n): (key: string) => boolean {\n  const map: Record<string, boolean> = Object.create(null)\n  const list: Array<string> = str.split(',')\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\n}\n","export * from './patchFlags'\nexport { isGloballyWhitelisted } from './globalsWhitelist'\nexport { makeMap } from './makeMap'\n\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\n  ? Object.freeze({})\n  : {}\nexport const EMPTY_ARR: [] = []\n\nexport const NOOP = () => {}\n\n/**\n * Always return false.\n */\nexport const NO = () => false\n\nexport const isOn = (key: string) => key[0] === 'o' && key[1] === 'n'\n\nexport const extend = <T extends object, U extends object>(\n  a: T,\n  b: U\n): T & U => {\n  for (const key in b) {\n    ;(a as any)[key] = b[key]\n  }\n  return a as any\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const isArray = Array.isArray\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === 'function'\nexport const isString = (val: unknown): val is string => typeof val === 'string'\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport function isPromise<T = any>(val: unknown): val is Promise<T> {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\n}\n\nexport const objectToString = Object.prototype.toString\nexport const toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\nexport const isPlainObject = (val: unknown): val is object =>\n  toTypeString(val) === '[object Object]'\n\nexport const isReservedProp = (key: string): boolean =>\n  key === 'key' || key === 'ref' || key === '$once' || key.startsWith(`onVnode`)\n\nconst camelizeRE = /-(\\w)/g\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\n}\n\nconst hyphenateRE = /\\B([A-Z])/g\nexport const hyphenate = (str: string): string => {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n}\n\nexport const capitalize = (str: string): string => {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n","import { SourceLocation } from './ast'\n\nexport interface CompilerError extends SyntaxError {\n  code: number\n  loc?: SourceLocation\n}\n\nexport interface CoreCompilerError extends CompilerError {\n  code: ErrorCodes\n}\n\nexport function defaultOnError(error: CompilerError) {\n  throw error\n}\n\nexport function createCompilerError<T extends number>(\n  code: T,\n  loc?: SourceLocation,\n  messages?: { [code: number]: string }\n): T extends ErrorCodes ? CoreCompilerError : CompilerError {\n  const msg = __DEV__ || !__BROWSER__ ? (messages || errorMessages)[code] : code\n  const locInfo = loc ? ` (${loc.start.line}:${loc.start.column})` : ``\n  const error = new SyntaxError(msg + locInfo) as CompilerError\n  error.code = code\n  error.loc = loc\n  return error as any\n}\n\nexport const enum ErrorCodes {\n  // parse errors\n  ABRUPT_CLOSING_OF_EMPTY_COMMENT,\n  ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE,\n  CDATA_IN_HTML_CONTENT,\n  CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE,\n  CONTROL_CHARACTER_REFERENCE,\n  DUPLICATE_ATTRIBUTE,\n  END_TAG_WITH_ATTRIBUTES,\n  END_TAG_WITH_TRAILING_SOLIDUS,\n  EOF_BEFORE_TAG_NAME,\n  EOF_IN_CDATA,\n  EOF_IN_COMMENT,\n  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT,\n  EOF_IN_TAG,\n  INCORRECTLY_CLOSED_COMMENT,\n  INCORRECTLY_OPENED_COMMENT,\n  INVALID_FIRST_CHARACTER_OF_TAG_NAME,\n  MISSING_ATTRIBUTE_VALUE,\n  MISSING_END_TAG_NAME,\n  MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE,\n  MISSING_WHITESPACE_BETWEEN_ATTRIBUTES,\n  NESTED_COMMENT,\n  NONCHARACTER_CHARACTER_REFERENCE,\n  NULL_CHARACTER_REFERENCE,\n  SURROGATE_CHARACTER_REFERENCE,\n  UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\n  UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\n  UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME,\n  UNEXPECTED_NULL_CHARACTER,\n  UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\n  UNEXPECTED_SOLIDUS_IN_TAG,\n  UNKNOWN_NAMED_CHARACTER_REFERENCE,\n\n  // Vue-specific parse errors\n  X_INVALID_END_TAG,\n  X_MISSING_END_TAG,\n  X_MISSING_INTERPOLATION_END,\n  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END,\n\n  // transform errors\n  X_V_IF_NO_EXPRESSION,\n  X_V_ELSE_NO_ADJACENT_IF,\n  X_V_FOR_NO_EXPRESSION,\n  X_V_FOR_MALFORMED_EXPRESSION,\n  X_V_BIND_NO_EXPRESSION,\n  X_V_ON_NO_EXPRESSION,\n  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\n  X_V_SLOT_NAMED_SLOT_ON_COMPONENT,\n  X_V_SLOT_MIXED_SLOT_USAGE,\n  X_V_SLOT_DUPLICATE_SLOT_NAMES,\n  X_V_SLOT_EXTRANEOUS_NON_SLOT_CHILDREN,\n  X_V_SLOT_MISPLACED,\n  X_V_MODEL_NO_EXPRESSION,\n  X_V_MODEL_MALFORMED_EXPRESSION,\n  X_V_MODEL_ON_SCOPE_VARIABLE,\n  X_INVALID_EXPRESSION,\n\n  // generic errors\n  X_PREFIX_ID_NOT_SUPPORTED,\n  X_MODULE_MODE_NOT_SUPPORTED,\n\n  // Special value for higher-order compilers to pick up the last code\n  // to avoid collision of error codes. This should always be kept as the last\n  // item.\n  __EXTEND_POINT__\n}\n\nexport const errorMessages: { [code: number]: string } = {\n  // parse errors\n  [ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT]: 'Illegal comment.',\n  [ErrorCodes.ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: invalid character.',\n  [ErrorCodes.CDATA_IN_HTML_CONTENT]:\n    'CDATA section is allowed only in XML context.',\n  [ErrorCodes.CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE]:\n    'Illegal numeric character reference: too big.',\n  [ErrorCodes.CONTROL_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: control character.',\n  [ErrorCodes.DUPLICATE_ATTRIBUTE]: 'Duplicate attribute.',\n  [ErrorCodes.END_TAG_WITH_ATTRIBUTES]: 'End tag cannot have attributes.',\n  [ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS]: \"Illegal '/' in tags.\",\n  [ErrorCodes.EOF_BEFORE_TAG_NAME]: 'Unexpected EOF in tag.',\n  [ErrorCodes.EOF_IN_CDATA]: 'Unexpected EOF in CDATA section.',\n  [ErrorCodes.EOF_IN_COMMENT]: 'Unexpected EOF in comment.',\n  [ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT]:\n    'Unexpected EOF in script.',\n  [ErrorCodes.EOF_IN_TAG]: 'Unexpected EOF in tag.',\n  [ErrorCodes.INCORRECTLY_CLOSED_COMMENT]: 'Incorrectly closed comment.',\n  [ErrorCodes.INCORRECTLY_OPENED_COMMENT]: 'Incorrectly opened comment.',\n  [ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME]:\n    \"Illegal tag name. Use '&lt;' to print '<'.\",\n  [ErrorCodes.MISSING_ATTRIBUTE_VALUE]: 'Attribute value was expected.',\n  [ErrorCodes.MISSING_END_TAG_NAME]: 'End tag name was expected.',\n  [ErrorCodes.MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE]:\n    'Semicolon was expected.',\n  [ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES]:\n    'Whitespace was expected.',\n  [ErrorCodes.NESTED_COMMENT]: \"Unexpected '<!--' in comment.\",\n  [ErrorCodes.NONCHARACTER_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: non character.',\n  [ErrorCodes.NULL_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: null character.',\n  [ErrorCodes.SURROGATE_CHARACTER_REFERENCE]:\n    'Illegal numeric character reference: non-pair surrogate.',\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME]:\n    'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE]:\n    'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\n  [ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME]:\n    \"Attribute name cannot start with '='.\",\n  [ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME]:\n    \"'<?' is allowed only in XML context.\",\n  [ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG]: \"Illegal '/' in tags.\",\n  [ErrorCodes.UNKNOWN_NAMED_CHARACTER_REFERENCE]: 'Unknown entity name.',\n\n  // Vue-specific parse errors\n  [ErrorCodes.X_INVALID_END_TAG]: 'Invalid end tag.',\n  [ErrorCodes.X_MISSING_END_TAG]: 'End tag was not found.',\n  [ErrorCodes.X_MISSING_INTERPOLATION_END]:\n    'Interpolation end sign was not found.',\n  [ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END]:\n    'End bracket for dynamic directive argument was not found. ' +\n    'Note that dynamic directive argument cannot contain spaces.',\n\n  // transform errors\n  [ErrorCodes.X_V_IF_NO_EXPRESSION]: `v-if/v-else-if is missing expression.`,\n  [ErrorCodes.X_V_ELSE_NO_ADJACENT_IF]: `v-else/v-else-if has no adjacent v-if.`,\n  [ErrorCodes.X_V_FOR_NO_EXPRESSION]: `v-for is missing expression.`,\n  [ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION]: `v-for has invalid expression.`,\n  [ErrorCodes.X_V_BIND_NO_EXPRESSION]: `v-bind is missing expression.`,\n  [ErrorCodes.X_V_ON_NO_EXPRESSION]: `v-on is missing expression.`,\n  [ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET]: `Unexpected custom directive on <slot> outlet.`,\n  [ErrorCodes.X_V_SLOT_NAMED_SLOT_ON_COMPONENT]:\n    `Named v-slot on component. ` +\n    `Named slots should use <template v-slot> syntax nested inside the component.`,\n  [ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE]:\n    `Mixed v-slot usage on both the component and nested <template>.` +\n    `The default slot should also use <template> syntax when there are other ` +\n    `named slots to avoid scope ambiguity.`,\n  [ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES]: `Duplicate slot names found. `,\n  [ErrorCodes.X_V_SLOT_EXTRANEOUS_NON_SLOT_CHILDREN]:\n    `Extraneous children found when component has explicit slots. ` +\n    `These children will be ignored.`,\n  [ErrorCodes.X_V_SLOT_MISPLACED]: `v-slot can only be used on components or <template> tags.`,\n  [ErrorCodes.X_V_MODEL_NO_EXPRESSION]: `v-model is missing expression.`,\n  [ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION]: `v-model value must be a valid JavaScript member expression.`,\n  [ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\n  [ErrorCodes.X_INVALID_EXPRESSION]: `Invalid JavaScript expression.`,\n\n  // generic errors\n  [ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\n  [ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED]: `ES module mode is not supported in this build of compiler.`\n}\n","import { isString } from '@vue/shared'\nimport { ForParseResult } from './transforms/vFor'\nimport {\n  CREATE_VNODE,\n  WITH_DIRECTIVES,\n  RENDER_SLOT,\n  CREATE_SLOTS,\n  RENDER_LIST,\n  OPEN_BLOCK,\n  CREATE_BLOCK,\n  FRAGMENT\n} from './runtimeHelpers'\nimport { PropsExpression } from './transforms/transformElement'\n\n// Vue template is a platform-agnostic superset of HTML (syntax only).\n// More namespaces like SVG and MathML are declared by platform specific\n// compilers.\nexport type Namespace = number\n\nexport const enum Namespaces {\n  HTML\n}\n\nexport const enum NodeTypes {\n  ROOT,\n  ELEMENT,\n  TEXT,\n  COMMENT,\n  SIMPLE_EXPRESSION,\n  INTERPOLATION,\n  ATTRIBUTE,\n  DIRECTIVE,\n  // containers\n  COMPOUND_EXPRESSION,\n  IF,\n  IF_BRANCH,\n  FOR,\n  TEXT_CALL,\n  // codegen\n  JS_CALL_EXPRESSION,\n  JS_OBJECT_EXPRESSION,\n  JS_PROPERTY,\n  JS_ARRAY_EXPRESSION,\n  JS_FUNCTION_EXPRESSION,\n  JS_SEQUENCE_EXPRESSION,\n  JS_CONDITIONAL_EXPRESSION,\n  JS_CACHE_EXPRESSION\n}\n\nexport const enum ElementTypes {\n  ELEMENT,\n  COMPONENT,\n  SLOT,\n  TEMPLATE,\n  PORTAL,\n  SUSPENSE\n}\n\nexport interface Node {\n  type: NodeTypes\n  loc: SourceLocation\n}\n\n// The node's range. The `start` is inclusive and `end` is exclusive.\n// [start, end)\nexport interface SourceLocation {\n  start: Position\n  end: Position\n  source: string\n}\n\nexport interface Position {\n  offset: number // from start of file\n  line: number\n  column: number\n}\n\nexport type ParentNode = RootNode | ElementNode | IfBranchNode | ForNode\n\nexport type ExpressionNode = SimpleExpressionNode | CompoundExpressionNode\n\nexport type TemplateChildNode =\n  | ElementNode\n  | InterpolationNode\n  | CompoundExpressionNode\n  | TextNode\n  | CommentNode\n  | IfNode\n  | ForNode\n  | TextCallNode\n\nexport interface RootNode extends Node {\n  type: NodeTypes.ROOT\n  children: TemplateChildNode[]\n  helpers: symbol[]\n  components: string[]\n  directives: string[]\n  hoists: JSChildNode[]\n  cached: number\n  codegenNode: TemplateChildNode | JSChildNode | undefined\n}\n\nexport type ElementNode =\n  | PlainElementNode\n  | ComponentNode\n  | SlotOutletNode\n  | TemplateNode\n  | PortalNode\n  | SuspenseNode\n\nexport interface BaseElementNode extends Node {\n  type: NodeTypes.ELEMENT\n  ns: Namespace\n  tag: string\n  tagType: ElementTypes\n  isSelfClosing: boolean\n  props: Array<AttributeNode | DirectiveNode>\n  children: TemplateChildNode[]\n  codegenNode: CallExpression | SimpleExpressionNode | undefined\n}\n\nexport interface PlainElementNode extends BaseElementNode {\n  tagType: ElementTypes.ELEMENT\n  codegenNode: ElementCodegenNode | undefined | SimpleExpressionNode // only when hoisted\n}\n\nexport interface ComponentNode extends BaseElementNode {\n  tagType: ElementTypes.COMPONENT\n  codegenNode: ComponentCodegenNode | undefined\n}\n\nexport interface SlotOutletNode extends BaseElementNode {\n  tagType: ElementTypes.SLOT\n  codegenNode: SlotOutletCodegenNode | undefined\n}\n\nexport interface TemplateNode extends BaseElementNode {\n  tagType: ElementTypes.TEMPLATE\n  codegenNode:\n    | ElementCodegenNode\n    | CodegenNodeWithDirective<ElementCodegenNode>\n    | undefined\n}\n\nexport interface PortalNode extends BaseElementNode {\n  tagType: ElementTypes.PORTAL\n  codegenNode: ElementCodegenNode | undefined\n}\n\nexport interface SuspenseNode extends BaseElementNode {\n  tagType: ElementTypes.SUSPENSE\n  codegenNode: ElementCodegenNode | undefined\n}\n\nexport interface TextNode extends Node {\n  type: NodeTypes.TEXT\n  content: string\n  isEmpty: boolean\n}\n\nexport interface CommentNode extends Node {\n  type: NodeTypes.COMMENT\n  content: string\n}\n\nexport interface AttributeNode extends Node {\n  type: NodeTypes.ATTRIBUTE\n  name: string\n  value: TextNode | undefined\n}\n\nexport interface DirectiveNode extends Node {\n  type: NodeTypes.DIRECTIVE\n  name: string\n  exp: ExpressionNode | undefined\n  arg: ExpressionNode | undefined\n  modifiers: string[]\n  // optional property to cache the expression parse result for v-for\n  parseResult?: ForParseResult\n}\n\nexport interface SimpleExpressionNode extends Node {\n  type: NodeTypes.SIMPLE_EXPRESSION\n  content: string\n  isStatic: boolean\n  isConstant: boolean\n  // an expression parsed as the params of a function will track\n  // the identifiers declared inside the function body.\n  identifiers?: string[]\n}\n\nexport interface InterpolationNode extends Node {\n  type: NodeTypes.INTERPOLATION\n  content: ExpressionNode\n}\n\nexport interface CompoundExpressionNode extends Node {\n  type: NodeTypes.COMPOUND_EXPRESSION\n  children: (\n    | SimpleExpressionNode\n    | InterpolationNode\n    | TextNode\n    | string\n    | symbol)[]\n  // an expression parsed as the params of a function will track\n  // the identifiers declared inside the function body.\n  identifiers?: string[]\n}\n\nexport interface IfNode extends Node {\n  type: NodeTypes.IF\n  branches: IfBranchNode[]\n  codegenNode: IfCodegenNode\n}\n\nexport interface IfBranchNode extends Node {\n  type: NodeTypes.IF_BRANCH\n  condition: ExpressionNode | undefined // else\n  children: TemplateChildNode[]\n}\n\nexport interface ForNode extends Node {\n  type: NodeTypes.FOR\n  source: ExpressionNode\n  valueAlias: ExpressionNode | undefined\n  keyAlias: ExpressionNode | undefined\n  objectIndexAlias: ExpressionNode | undefined\n  children: TemplateChildNode[]\n  codegenNode: ForCodegenNode\n}\n\nexport interface TextCallNode extends Node {\n  type: NodeTypes.TEXT_CALL\n  content: TextNode | InterpolationNode | CompoundExpressionNode\n  codegenNode: CallExpression\n}\n\n// We also include a number of JavaScript AST nodes for code generation.\n// The AST is an intentionally minimal subset just to meet the exact needs of\n// Vue render function generation.\nexport type JSChildNode =\n  | CallExpression\n  | ObjectExpression\n  | ArrayExpression\n  | ExpressionNode\n  | FunctionExpression\n  | ConditionalExpression\n  | SequenceExpression\n  | CacheExpression\n\nexport interface CallExpression extends Node {\n  type: NodeTypes.JS_CALL_EXPRESSION\n  callee: string | symbol\n  arguments: (\n    | string\n    | symbol\n    | JSChildNode\n    | TemplateChildNode\n    | TemplateChildNode[])[]\n}\n\nexport interface ObjectExpression extends Node {\n  type: NodeTypes.JS_OBJECT_EXPRESSION\n  properties: Array<Property>\n}\n\nexport interface Property extends Node {\n  type: NodeTypes.JS_PROPERTY\n  key: ExpressionNode\n  value: JSChildNode\n}\n\nexport interface ArrayExpression extends Node {\n  type: NodeTypes.JS_ARRAY_EXPRESSION\n  elements: Array<string | JSChildNode>\n}\n\nexport interface FunctionExpression extends Node {\n  type: NodeTypes.JS_FUNCTION_EXPRESSION\n  params: ExpressionNode | ExpressionNode[] | undefined\n  returns: TemplateChildNode | TemplateChildNode[] | JSChildNode\n  newline: boolean\n}\n\nexport interface SequenceExpression extends Node {\n  type: NodeTypes.JS_SEQUENCE_EXPRESSION\n  expressions: JSChildNode[]\n}\n\nexport interface ConditionalExpression extends Node {\n  type: NodeTypes.JS_CONDITIONAL_EXPRESSION\n  test: ExpressionNode\n  consequent: JSChildNode\n  alternate: JSChildNode\n}\n\nexport interface CacheExpression extends Node {\n  type: NodeTypes.JS_CACHE_EXPRESSION\n  index: number\n  value: JSChildNode\n}\n\n// Codegen Node Types ----------------------------------------------------------\n\n// createVNode(...)\nexport interface PlainElementCodegenNode extends CallExpression {\n  callee: typeof CREATE_VNODE | typeof CREATE_BLOCK\n  arguments:  // tag, props, children, patchFlag, dynamicProps\n    | [string | symbol]\n    | [string | symbol, PropsExpression]\n    | [string | symbol, 'null' | PropsExpression, TemplateChildNode[]]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | TemplateChildNode[],\n        string\n      ]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | TemplateChildNode[],\n        string,\n        string\n      ]\n}\n\nexport type ElementCodegenNode =\n  | PlainElementCodegenNode\n  | CodegenNodeWithDirective<PlainElementCodegenNode>\n\n// createVNode(...)\nexport interface PlainComponentCodegenNode extends CallExpression {\n  callee: typeof CREATE_VNODE | typeof CREATE_BLOCK\n  arguments:  // Comp, props, slots, patchFlag, dynamicProps\n    | [string | symbol]\n    | [string | symbol, PropsExpression]\n    | [string | symbol, 'null' | PropsExpression, SlotsExpression]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | SlotsExpression,\n        string\n      ]\n    | [\n        string | symbol,\n        'null' | PropsExpression,\n        'null' | SlotsExpression,\n        string,\n        string\n      ]\n}\n\nexport type ComponentCodegenNode =\n  | PlainComponentCodegenNode\n  | CodegenNodeWithDirective<PlainComponentCodegenNode>\n\nexport type SlotsExpression = SlotsObjectExpression | DynamicSlotsExpression\n\n// { foo: () => [...] }\nexport interface SlotsObjectExpression extends ObjectExpression {\n  properties: SlotsObjectProperty[]\n}\n\nexport interface SlotsObjectProperty extends Property {\n  value: SlotFunctionExpression\n}\n\nexport interface SlotFunctionExpression extends FunctionExpression {\n  returns: TemplateChildNode[]\n}\n\n// createSlots({ ... }, [\n//    foo ? () => [] : undefined,\n//    renderList(list, i => () => [i])\n// ])\nexport interface DynamicSlotsExpression extends CallExpression {\n  callee: typeof CREATE_SLOTS\n  arguments: [SlotsObjectExpression, DynamicSlotEntries]\n}\n\nexport interface DynamicSlotEntries extends ArrayExpression {\n  elements: (ConditionalDynamicSlotNode | ListDynamicSlotNode)[]\n}\n\nexport interface ConditionalDynamicSlotNode extends ConditionalExpression {\n  consequent: DynamicSlotNode\n  alternate: DynamicSlotNode | SimpleExpressionNode\n}\n\nexport interface ListDynamicSlotNode extends CallExpression {\n  callee: typeof RENDER_LIST\n  arguments: [ExpressionNode, ListDynamicSlotIterator]\n}\n\nexport interface ListDynamicSlotIterator extends FunctionExpression {\n  returns: DynamicSlotNode\n}\n\nexport interface DynamicSlotNode extends ObjectExpression {\n  properties: [Property, DynamicSlotFnProperty]\n}\n\nexport interface DynamicSlotFnProperty extends Property {\n  value: SlotFunctionExpression\n}\n\n// withDirectives(createVNode(...), [\n//    [_directive_foo, someValue],\n//    [_directive_bar, someValue, \"arg\", { mod: true }]\n// ])\nexport interface CodegenNodeWithDirective<T extends CallExpression>\n  extends CallExpression {\n  callee: typeof WITH_DIRECTIVES\n  arguments: [T, DirectiveArguments]\n}\n\nexport interface DirectiveArguments extends ArrayExpression {\n  elements: DirectiveArgumentNode[]\n}\n\nexport interface DirectiveArgumentNode extends ArrayExpression {\n  elements:  // dir, exp, arg, modifiers\n    | [string]\n    | [string, ExpressionNode]\n    | [string, ExpressionNode, ExpressionNode]\n    | [string, ExpressionNode, ExpressionNode, ObjectExpression]\n}\n\n// renderSlot(...)\nexport interface SlotOutletCodegenNode extends CallExpression {\n  callee: typeof RENDER_SLOT\n  arguments:  // $slots, name, props, fallback\n    | [string, string | ExpressionNode]\n    | [string, string | ExpressionNode, PropsExpression]\n    | [\n        string,\n        string | ExpressionNode,\n        PropsExpression | '{}',\n        TemplateChildNode[]\n      ]\n}\n\nexport type BlockCodegenNode =\n  | ElementCodegenNode\n  | ComponentCodegenNode\n  | SlotOutletCodegenNode\n\nexport interface IfCodegenNode extends SequenceExpression {\n  expressions: [OpenBlockExpression, IfConditionalExpression]\n}\n\nexport interface IfConditionalExpression extends ConditionalExpression {\n  consequent: BlockCodegenNode\n  alternate: BlockCodegenNode | IfConditionalExpression\n}\n\nexport interface ForCodegenNode extends SequenceExpression {\n  expressions: [OpenBlockExpression, ForBlockCodegenNode]\n}\n\nexport interface ForBlockCodegenNode extends CallExpression {\n  callee: typeof CREATE_BLOCK\n  arguments: [typeof FRAGMENT, 'null', ForRenderListExpression, string]\n}\n\nexport interface ForRenderListExpression extends CallExpression {\n  callee: typeof RENDER_LIST\n  arguments: [ExpressionNode, ForIteratorExpression]\n}\n\nexport interface ForIteratorExpression extends FunctionExpression {\n  returns: BlockCodegenNode\n}\n\nexport interface OpenBlockExpression extends CallExpression {\n  callee: typeof OPEN_BLOCK\n  arguments: []\n}\n\n// AST Utilities ---------------------------------------------------------------\n\n// Some expressions, e.g. sequence and conditional expressions, are never\n// associated with template nodes, so their source locations are just a stub.\n// Container types like CompoundExpression also don't need a real location.\nexport const locStub: SourceLocation = {\n  source: '',\n  start: { line: 1, column: 1, offset: 0 },\n  end: { line: 1, column: 1, offset: 0 }\n}\n\nexport function createArrayExpression(\n  elements: ArrayExpression['elements'],\n  loc: SourceLocation = locStub\n): ArrayExpression {\n  return {\n    type: NodeTypes.JS_ARRAY_EXPRESSION,\n    loc,\n    elements\n  }\n}\n\nexport function createObjectExpression(\n  properties: ObjectExpression['properties'],\n  loc: SourceLocation = locStub\n): ObjectExpression {\n  return {\n    type: NodeTypes.JS_OBJECT_EXPRESSION,\n    loc,\n    properties\n  }\n}\n\nexport function createObjectProperty(\n  key: Property['key'] | string,\n  value: Property['value']\n): Property {\n  return {\n    type: NodeTypes.JS_PROPERTY,\n    loc: locStub,\n    key: isString(key) ? createSimpleExpression(key, true) : key,\n    value\n  }\n}\n\nexport function createSimpleExpression(\n  content: SimpleExpressionNode['content'],\n  isStatic: SimpleExpressionNode['isStatic'],\n  loc: SourceLocation = locStub,\n  isConstant: boolean = false\n): SimpleExpressionNode {\n  return {\n    type: NodeTypes.SIMPLE_EXPRESSION,\n    loc,\n    isConstant,\n    content,\n    isStatic\n  }\n}\n\nexport function createInterpolation(\n  content: InterpolationNode['content'] | string,\n  loc: SourceLocation\n): InterpolationNode {\n  return {\n    type: NodeTypes.INTERPOLATION,\n    loc,\n    content: isString(content)\n      ? createSimpleExpression(content, false, loc)\n      : content\n  }\n}\n\nexport function createCompoundExpression(\n  children: CompoundExpressionNode['children'],\n  loc: SourceLocation = locStub\n): CompoundExpressionNode {\n  return {\n    type: NodeTypes.COMPOUND_EXPRESSION,\n    loc,\n    children\n  }\n}\n\ntype InferCodegenNodeType<T> = T extends\n  | typeof CREATE_VNODE\n  | typeof CREATE_BLOCK\n  ? PlainElementCodegenNode | PlainComponentCodegenNode\n  : T extends typeof WITH_DIRECTIVES\n    ?\n        | CodegenNodeWithDirective<PlainElementCodegenNode>\n        | CodegenNodeWithDirective<PlainComponentCodegenNode>\n    : T extends typeof RENDER_SLOT ? SlotOutletCodegenNode : CallExpression\n\nexport function createCallExpression<T extends CallExpression['callee']>(\n  callee: T,\n  args: CallExpression['arguments'] = [],\n  loc: SourceLocation = locStub\n): InferCodegenNodeType<T> {\n  return {\n    type: NodeTypes.JS_CALL_EXPRESSION,\n    loc,\n    callee,\n    arguments: args\n  } as any\n}\n\nexport function createFunctionExpression(\n  params: FunctionExpression['params'],\n  returns: FunctionExpression['returns'],\n  newline: boolean = false,\n  loc: SourceLocation = locStub\n): FunctionExpression {\n  return {\n    type: NodeTypes.JS_FUNCTION_EXPRESSION,\n    params,\n    returns,\n    newline,\n    loc\n  }\n}\n\nexport function createSequenceExpression(\n  expressions: SequenceExpression['expressions']\n): SequenceExpression {\n  return {\n    type: NodeTypes.JS_SEQUENCE_EXPRESSION,\n    expressions,\n    loc: locStub\n  }\n}\n\nexport function createConditionalExpression(\n  test: ConditionalExpression['test'],\n  consequent: ConditionalExpression['consequent'],\n  alternate: ConditionalExpression['alternate']\n): ConditionalExpression {\n  return {\n    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n    test,\n    consequent,\n    alternate,\n    loc: locStub\n  }\n}\n\nexport function createCacheExpression(\n  index: number,\n  value: JSChildNode\n): CacheExpression {\n  return {\n    type: NodeTypes.JS_CACHE_EXPRESSION,\n    index,\n    value,\n    loc: locStub\n  }\n}\n","export const FRAGMENT = Symbol(__DEV__ ? `Fragment` : ``)\nexport const PORTAL = Symbol(__DEV__ ? `Portal` : ``)\nexport const COMMENT = Symbol(__DEV__ ? `Comment` : ``)\nexport const TEXT = Symbol(__DEV__ ? `Text` : ``)\nexport const SUSPENSE = Symbol(__DEV__ ? `Suspense` : ``)\nexport const OPEN_BLOCK = Symbol(__DEV__ ? `openBlock` : ``)\nexport const CREATE_BLOCK = Symbol(__DEV__ ? `createBlock` : ``)\nexport const CREATE_VNODE = Symbol(__DEV__ ? `createVNode` : ``)\nexport const RESOLVE_COMPONENT = Symbol(__DEV__ ? `resolveComponent` : ``)\nexport const RESOLVE_DYNAMIC_COMPONENT = Symbol(\n  __DEV__ ? `resolveDynamicComponent` : ``\n)\nexport const RESOLVE_DIRECTIVE = Symbol(__DEV__ ? `resolveDirective` : ``)\nexport const WITH_DIRECTIVES = Symbol(__DEV__ ? `withDirectives` : ``)\nexport const RENDER_LIST = Symbol(__DEV__ ? `renderList` : ``)\nexport const RENDER_SLOT = Symbol(__DEV__ ? `renderSlot` : ``)\nexport const CREATE_SLOTS = Symbol(__DEV__ ? `createSlots` : ``)\nexport const TO_STRING = Symbol(__DEV__ ? `toString` : ``)\nexport const MERGE_PROPS = Symbol(__DEV__ ? `mergeProps` : ``)\nexport const TO_HANDLERS = Symbol(__DEV__ ? `toHandlers` : ``)\nexport const CAMELIZE = Symbol(__DEV__ ? `camelize` : ``)\n\n// Name mapping for runtime helpers that need to be imported from 'vue' in\n// generated code. Make sure these are correctly exported in the runtime!\n// Using `any` here because TS doesn't allow symbols as index type.\nexport const helperNameMap: any = {\n  [FRAGMENT]: `Fragment`,\n  [PORTAL]: `Portal`,\n  [COMMENT]: `Comment`,\n  [TEXT]: `Text`,\n  [SUSPENSE]: `Suspense`,\n  [OPEN_BLOCK]: `openBlock`,\n  [CREATE_BLOCK]: `createBlock`,\n  [CREATE_VNODE]: `createVNode`,\n  [RESOLVE_COMPONENT]: `resolveComponent`,\n  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\n  [RESOLVE_DIRECTIVE]: `resolveDirective`,\n  [WITH_DIRECTIVES]: `withDirectives`,\n  [RENDER_LIST]: `renderList`,\n  [RENDER_SLOT]: `renderSlot`,\n  [CREATE_SLOTS]: `createSlots`,\n  [TO_STRING]: `toString`,\n  [MERGE_PROPS]: `mergeProps`,\n  [TO_HANDLERS]: `toHandlers`,\n  [CAMELIZE]: `camelize`\n}\n\nexport function registerRuntimeHelpers(helpers: any) {\n  Object.getOwnPropertySymbols(helpers).forEach(s => {\n    helperNameMap[s] = helpers[s]\n  })\n}\n","import {\n  SourceLocation,\n  Position,\n  ElementNode,\n  NodeTypes,\n  CallExpression,\n  SequenceExpression,\n  createSequenceExpression,\n  createCallExpression,\n  DirectiveNode,\n  ElementTypes,\n  TemplateChildNode,\n  RootNode,\n  ObjectExpression,\n  Property,\n  JSChildNode,\n  createObjectExpression,\n  SlotOutletNode,\n  TemplateNode,\n  BlockCodegenNode,\n  ElementCodegenNode,\n  SlotOutletCodegenNode,\n  ComponentCodegenNode,\n  ExpressionNode,\n  IfBranchNode\n} from './ast'\nimport { parse } from 'acorn'\nimport { walk } from 'estree-walker'\nimport { TransformContext } from './transform'\nimport { OPEN_BLOCK, MERGE_PROPS, RENDER_SLOT } from './runtimeHelpers'\nimport { isString, isFunction, isObject } from '@vue/shared'\n\n// cache node requires\n// lazy require dependencies so that they don't end up in rollup's dep graph\n// and thus can be tree-shaken in browser builds.\nlet _parse: typeof parse\nlet _walk: typeof walk\n\nexport function loadDep(name: string) {\n  if (typeof process !== 'undefined' && isFunction(require)) {\n    return require(name)\n  } else {\n    // This is only used when we are building a dev-only build of the compiler\n    // which runs in the browser but also uses Node deps.\n    return (window as any)._deps[name]\n  }\n}\n\nexport const parseJS: typeof parse = (code, options) => {\n  assert(\n    !__BROWSER__,\n    `Expression AST analysis can only be performed in non-browser builds.`\n  )\n  const parse = _parse || (_parse = loadDep('acorn').parse)\n  return parse(code, options)\n}\n\nexport const walkJS: typeof walk = (ast, walker) => {\n  assert(\n    !__BROWSER__,\n    `Expression AST analysis can only be performed in non-browser builds.`\n  )\n  const walk = _walk || (_walk = loadDep('estree-walker').walk)\n  return walk(ast, walker)\n}\n\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/\nexport const isSimpleIdentifier = (name: string): boolean =>\n  !nonIdentifierRE.test(name)\n\nconst memberExpRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\[[^\\]]+\\])*$/\nexport const isMemberExpression = (path: string): boolean =>\n  memberExpRE.test(path)\n\nexport function getInnerRange(\n  loc: SourceLocation,\n  offset: number,\n  length?: number\n): SourceLocation {\n  __DEV__ && assert(offset <= loc.source.length)\n  const source = loc.source.substr(offset, length)\n  const newLoc: SourceLocation = {\n    source,\n    start: advancePositionWithClone(loc.start, loc.source, offset),\n    end: loc.end\n  }\n\n  if (length != null) {\n    __DEV__ && assert(offset + length <= loc.source.length)\n    newLoc.end = advancePositionWithClone(\n      loc.start,\n      loc.source,\n      offset + length\n    )\n  }\n\n  return newLoc\n}\n\nexport function advancePositionWithClone(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number = source.length\n): Position {\n  return advancePositionWithMutation({ ...pos }, source, numberOfCharacters)\n}\n\n// advance by mutation without cloning (for performance reasons), since this\n// gets called a lot in the parser\nexport function advancePositionWithMutation(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number = source.length\n): Position {\n  let linesCount = 0\n  let lastNewLinePos = -1\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10 /* newline char code */) {\n      linesCount++\n      lastNewLinePos = i\n    }\n  }\n\n  pos.offset += numberOfCharacters\n  pos.line += linesCount\n  pos.column =\n    lastNewLinePos === -1\n      ? pos.column + numberOfCharacters\n      : Math.max(1, numberOfCharacters - lastNewLinePos)\n\n  return pos\n}\n\nexport function assert(condition: boolean, msg?: string) {\n  /* istanbul ignore if */\n  if (!condition) {\n    throw new Error(msg || `unexpected compiler condition`)\n  }\n}\n\nexport function findDir(\n  node: ElementNode,\n  name: string | RegExp,\n  allowEmpty: boolean = false\n): DirectiveNode | undefined {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (\n      p.type === NodeTypes.DIRECTIVE &&\n      (allowEmpty || p.exp) &&\n      (isString(name) ? p.name === name : name.test(p.name))\n    ) {\n      return p\n    }\n  }\n}\n\nexport function findProp(\n  node: ElementNode,\n  name: string,\n  dynamicOnly: boolean = false\n): ElementNode['props'][0] | undefined {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (p.type === NodeTypes.ATTRIBUTE) {\n      if (dynamicOnly) continue\n      if (p.name === name && p.value && !p.value.isEmpty) {\n        return p\n      }\n    } else if (\n      p.name === 'bind' &&\n      p.arg &&\n      p.arg.type === NodeTypes.SIMPLE_EXPRESSION &&\n      p.arg.isStatic &&\n      p.arg.content === name &&\n      p.exp\n    ) {\n      return p\n    }\n  }\n}\n\nexport function createBlockExpression(\n  blockExp: BlockCodegenNode,\n  context: TransformContext\n): SequenceExpression {\n  return createSequenceExpression([\n    createCallExpression(context.helper(OPEN_BLOCK)),\n    blockExp\n  ])\n}\n\nexport const isVSlot = (p: ElementNode['props'][0]): p is DirectiveNode =>\n  p.type === NodeTypes.DIRECTIVE && p.name === 'slot'\n\nexport const isTemplateNode = (\n  node: RootNode | TemplateChildNode\n): node is TemplateNode =>\n  node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.TEMPLATE\n\nexport const isSlotOutlet = (\n  node: RootNode | TemplateChildNode\n): node is SlotOutletNode =>\n  node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.SLOT\n\nexport function injectProp(\n  node: ElementCodegenNode | ComponentCodegenNode | SlotOutletCodegenNode,\n  prop: Property,\n  context: TransformContext\n) {\n  let propsWithInjection: ObjectExpression | CallExpression\n  const props =\n    node.callee === RENDER_SLOT ? node.arguments[2] : node.arguments[1]\n  if (props == null || isString(props)) {\n    propsWithInjection = createObjectExpression([prop])\n  } else if (props.type === NodeTypes.JS_CALL_EXPRESSION) {\n    // merged props... add ours\n    // only inject key to object literal if it's the first argument so that\n    // if doesn't override user provided keys\n    const first = props.arguments[0] as string | JSChildNode\n    if (!isString(first) && first.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n      first.properties.unshift(prop)\n    } else {\n      props.arguments.unshift(createObjectExpression([prop]))\n    }\n    propsWithInjection = props\n  } else if (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n    props.properties.unshift(prop)\n    propsWithInjection = props\n  } else {\n    // single v-bind with expression, return a merged replacement\n    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n      createObjectExpression([prop]),\n      props\n    ])\n  }\n  if (node.callee === RENDER_SLOT) {\n    node.arguments[2] = propsWithInjection\n  } else {\n    node.arguments[1] = propsWithInjection\n  }\n}\n\nexport function toValidAssetId(\n  name: string,\n  type: 'component' | 'directive'\n): string {\n  return `_${type}_${name.replace(/[^\\w]/g, '_')}`\n}\n\nexport function isEmptyExpression(node: ExpressionNode) {\n  return node.type === NodeTypes.SIMPLE_EXPRESSION && !node.content.trim()\n}\n\n// Check if a node contains expressions that reference current context scope ids\nexport function hasScopeRef(\n  node: TemplateChildNode | IfBranchNode | ExpressionNode | undefined,\n  ids: TransformContext['identifiers']\n): boolean {\n  if (!node || Object.keys(ids).length === 0) {\n    return false\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n      for (let i = 0; i < node.props.length; i++) {\n        const p = node.props[i]\n        if (\n          p.type === NodeTypes.DIRECTIVE &&\n          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))\n        ) {\n          return true\n        }\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.FOR:\n      if (hasScopeRef(node.source, ids)) {\n        return true\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.IF:\n      return node.branches.some(b => hasScopeRef(b, ids))\n    case NodeTypes.IF_BRANCH:\n      if (hasScopeRef(node.condition, ids)) {\n        return true\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.SIMPLE_EXPRESSION:\n      return (\n        !node.isStatic &&\n        isSimpleIdentifier(node.content) &&\n        !!ids[node.content]\n      )\n    case NodeTypes.COMPOUND_EXPRESSION:\n      return node.children.some(c => isObject(c) && hasScopeRef(c, ids))\n    case NodeTypes.INTERPOLATION:\n    case NodeTypes.TEXT_CALL:\n      return hasScopeRef(node.content, ids)\n    case NodeTypes.TEXT:\n    case NodeTypes.COMMENT:\n      return false\n    default:\n      if (__DEV__) {\n        const exhaustiveCheck: never = node\n        exhaustiveCheck\n      }\n      return false\n  }\n}\n","import { NO } from '@vue/shared'\nimport {\n  ErrorCodes,\n  createCompilerError,\n  defaultOnError,\n  CompilerError\n} from './errors'\nimport {\n  assert,\n  advancePositionWithMutation,\n  advancePositionWithClone\n} from './utils'\nimport {\n  Namespace,\n  Namespaces,\n  AttributeNode,\n  CommentNode,\n  DirectiveNode,\n  ElementNode,\n  ElementTypes,\n  ExpressionNode,\n  NodeTypes,\n  Position,\n  RootNode,\n  SourceLocation,\n  TextNode,\n  TemplateChildNode,\n  InterpolationNode\n} from './ast'\nimport { extend } from '@vue/shared'\n\nexport interface ParserOptions {\n  isVoidTag?: (tag: string) => boolean // e.g. img, br, hr\n  isNativeTag?: (tag: string) => boolean // e.g. loading-indicator in weex\n  isCustomElement?: (tag: string) => boolean\n  getNamespace?: (tag: string, parent: ElementNode | undefined) => Namespace\n  getTextMode?: (tag: string, ns: Namespace) => TextModes\n  delimiters?: [string, string] // ['{{', '}}']\n  ignoreSpaces?: boolean\n\n  // Map to HTML entities. E.g., `{ \"amp;\": \"&\" }`\n  // The full set is https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references\n  namedCharacterReferences?: { [name: string]: string | undefined }\n\n  onError?: (error: CompilerError) => void\n}\n\n// `isNativeTag` is optional, others are required\ntype MergedParserOptions = Omit<Required<ParserOptions>, 'isNativeTag'> &\n  Pick<ParserOptions, 'isNativeTag'>\n\nexport const defaultParserOptions: MergedParserOptions = {\n  delimiters: [`{{`, `}}`],\n  ignoreSpaces: true,\n  getNamespace: () => Namespaces.HTML,\n  getTextMode: () => TextModes.DATA,\n  isVoidTag: NO,\n  isCustomElement: NO,\n  namedCharacterReferences: {\n    'gt;': '>',\n    'lt;': '<',\n    'amp;': '&',\n    'apos;': \"'\",\n    'quot;': '\"'\n  },\n  onError: defaultOnError\n}\n\nexport const enum TextModes {\n  //          | Elements | Entities | End sign              | Inside of\n  DATA, //    | ✔       | ✔       | End tags of ancestors |\n  RCDATA, //  | ✘       | ✔       | End tag of the parent | <textarea>\n  RAWTEXT, // | ✘       | ✘       | End tag of the parent | <style>,<script>\n  CDATA,\n  ATTRIBUTE_VALUE\n}\n\ninterface ParserContext {\n  options: MergedParserOptions\n  readonly originalSource: string\n  source: string\n  offset: number\n  line: number\n  column: number\n  maxCRNameLength: number\n  inPre: boolean\n}\n\nexport function parse(content: string, options: ParserOptions = {}): RootNode {\n  const context = createParserContext(content, options)\n  const start = getCursor(context)\n\n  return {\n    type: NodeTypes.ROOT,\n    children: parseChildren(context, TextModes.DATA, []),\n    helpers: [],\n    components: [],\n    directives: [],\n    hoists: [],\n    cached: 0,\n    codegenNode: undefined,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction createParserContext(\n  content: string,\n  options: ParserOptions\n): ParserContext {\n  return {\n    options: {\n      ...defaultParserOptions,\n      ...options\n    },\n    column: 1,\n    line: 1,\n    offset: 0,\n    originalSource: content,\n    source: content,\n    maxCRNameLength: Object.keys(\n      options.namedCharacterReferences ||\n        defaultParserOptions.namedCharacterReferences\n    ).reduce((max, name) => Math.max(max, name.length), 0),\n    inPre: false\n  }\n}\n\nfunction parseChildren(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  const parent = last(ancestors)\n  const ns = parent ? parent.ns : Namespaces.HTML\n  const nodes: TemplateChildNode[] = []\n\n  while (!isEnd(context, mode, ancestors)) {\n    __DEV__ && assert(context.source.length > 0)\n    const s = context.source\n    let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined\n\n    if (!context.inPre && startsWith(s, context.options.delimiters[0])) {\n      // '{{'\n      node = parseInterpolation(context, mode)\n    } else if (mode === TextModes.DATA && s[0] === '<') {\n      // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\n      if (s.length === 1) {\n        emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)\n      } else if (s[1] === '!') {\n        // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\n        if (startsWith(s, '<!--')) {\n          node = parseComment(context)\n        } else if (startsWith(s, '<!DOCTYPE')) {\n          // Ignore DOCTYPE by a limitation.\n          node = parseBogusComment(context)\n        } else if (startsWith(s, '<![CDATA[')) {\n          if (ns !== Namespaces.HTML) {\n            node = parseCDATA(context, ancestors)\n          } else {\n            emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)\n            node = parseBogusComment(context)\n          }\n        } else {\n          emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)\n          node = parseBogusComment(context)\n        }\n      } else if (s[1] === '/') {\n        // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\n        if (s.length === 2) {\n          emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)\n        } else if (s[2] === '>') {\n          emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)\n          advanceBy(context, 3)\n          continue\n        } else if (/[a-z]/i.test(s[2])) {\n          emitError(context, ErrorCodes.X_INVALID_END_TAG)\n          parseTag(context, TagType.End, parent)\n          continue\n        } else {\n          emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 2)\n          node = parseBogusComment(context)\n        }\n      } else if (/[a-z]/i.test(s[1])) {\n        node = parseElement(context, ancestors)\n      } else if (s[1] === '?') {\n        emitError(\n          context,\n          ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\n          1\n        )\n        node = parseBogusComment(context)\n      } else {\n        emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)\n      }\n    }\n    if (!node) {\n      node = parseText(context, mode)\n    }\n\n    if (Array.isArray(node)) {\n      for (let i = 0; i < node.length; i++) {\n        pushNode(context, nodes, node[i])\n      }\n    } else {\n      pushNode(context, nodes, node)\n    }\n  }\n\n  return nodes\n}\n\nfunction pushNode(\n  context: ParserContext,\n  nodes: TemplateChildNode[],\n  node: TemplateChildNode\n): void {\n  // ignore comments in production\n  /* istanbul ignore next */\n  if (!__DEV__ && node.type === NodeTypes.COMMENT) {\n    return\n  }\n  if (\n    context.options.ignoreSpaces &&\n    node.type === NodeTypes.TEXT &&\n    node.isEmpty\n  ) {\n    return\n  }\n\n  // Merge if both this and the previous node are text and those are consecutive.\n  // This happens on \"a < b\" or something like.\n  const prev = last(nodes)\n  if (\n    prev &&\n    prev.type === NodeTypes.TEXT &&\n    node.type === NodeTypes.TEXT &&\n    prev.loc.end.offset === node.loc.start.offset\n  ) {\n    prev.content += node.content\n    prev.isEmpty = prev.content.trim().length === 0\n    prev.loc.end = node.loc.end\n    prev.loc.source += node.loc.source\n  } else {\n    nodes.push(node)\n  }\n}\n\nfunction parseCDATA(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  __DEV__ &&\n    assert(last(ancestors) == null || last(ancestors)!.ns !== Namespaces.HTML)\n  __DEV__ && assert(startsWith(context.source, '<![CDATA['))\n\n  advanceBy(context, 9)\n  const nodes = parseChildren(context, TextModes.CDATA, ancestors)\n  if (context.source.length === 0) {\n    emitError(context, ErrorCodes.EOF_IN_CDATA)\n  } else {\n    __DEV__ && assert(startsWith(context.source, ']]>'))\n    advanceBy(context, 3)\n  }\n\n  return nodes\n}\n\nfunction parseComment(context: ParserContext): CommentNode {\n  __DEV__ && assert(startsWith(context.source, '<!--'))\n\n  const start = getCursor(context)\n  let content: string\n\n  // Regular comment.\n  const match = /--(\\!)?>/.exec(context.source)\n  if (!match) {\n    content = context.source.slice(4)\n    advanceBy(context, context.source.length)\n    emitError(context, ErrorCodes.EOF_IN_COMMENT)\n  } else {\n    if (match.index <= 3) {\n      emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)\n    }\n    if (match[1]) {\n      emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)\n    }\n    content = context.source.slice(4, match.index)\n\n    // Advancing with reporting nested comments.\n    const s = context.source.slice(0, match.index)\n    let prevIndex = 1,\n      nestedIndex = 0\n    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\n      advanceBy(context, nestedIndex - prevIndex + 1)\n      if (nestedIndex + 4 < s.length) {\n        emitError(context, ErrorCodes.NESTED_COMMENT)\n      }\n      prevIndex = nestedIndex + 1\n    }\n    advanceBy(context, match.index + match[0].length - prevIndex + 1)\n  }\n\n  return {\n    type: NodeTypes.COMMENT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseBogusComment(context: ParserContext): CommentNode | undefined {\n  __DEV__ && assert(/^<(?:[\\!\\?]|\\/[^a-z>])/i.test(context.source))\n\n  const start = getCursor(context)\n  const contentStart = context.source[1] === '?' ? 1 : 2\n  let content: string\n\n  const closeIndex = context.source.indexOf('>')\n  if (closeIndex === -1) {\n    content = context.source.slice(contentStart)\n    advanceBy(context, context.source.length)\n  } else {\n    content = context.source.slice(contentStart, closeIndex)\n    advanceBy(context, closeIndex + 1)\n  }\n\n  return {\n    type: NodeTypes.COMMENT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseElement(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): ElementNode | undefined {\n  __DEV__ && assert(/^<[a-z]/i.test(context.source))\n\n  // Start tag.\n  const wasInPre = context.inPre\n  const parent = last(ancestors)\n  const element = parseTag(context, TagType.Start, parent)\n  const isPreBoundary = context.inPre && !wasInPre\n\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n    return element\n  }\n\n  // Children.\n  ancestors.push(element)\n  const mode = context.options.getTextMode(element.tag, element.ns)\n  const children = parseChildren(context, mode, ancestors)\n  ancestors.pop()\n\n  element.children = children\n\n  // End tag.\n  if (startsWithEndTagOpen(context.source, element.tag)) {\n    parseTag(context, TagType.End, parent)\n  } else {\n    emitError(context, ErrorCodes.X_MISSING_END_TAG)\n    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\n      const first = children[0]\n      if (first && startsWith(first.loc.source, '<!--')) {\n        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)\n      }\n    }\n  }\n\n  element.loc = getSelection(context, element.loc.start)\n\n  if (isPreBoundary) {\n    context.inPre = false\n  }\n  return element\n}\n\nconst enum TagType {\n  Start,\n  End\n}\n\n/**\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\n */\nfunction parseTag(\n  context: ParserContext,\n  type: TagType,\n  parent: ElementNode | undefined\n): ElementNode {\n  __DEV__ && assert(/^<\\/?[a-z]/i.test(context.source))\n  __DEV__ &&\n    assert(\n      type === (startsWith(context.source, '</') ? TagType.End : TagType.Start)\n    )\n\n  // Tag open.\n  const start = getCursor(context)\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source)!\n  const tag = match[1]\n  const ns = context.options.getNamespace(tag, parent)\n\n  advanceBy(context, match[0].length)\n  advanceSpaces(context)\n\n  // save current state in case we need to re-parse attributes with v-pre\n  const cursor = getCursor(context)\n  const currentSource = context.source\n\n  // Attributes.\n  let props = parseAttributes(context, type)\n\n  // check v-pre\n  if (\n    !context.inPre &&\n    props.some(p => p.type === NodeTypes.DIRECTIVE && p.name === 'pre')\n  ) {\n    context.inPre = true\n    // reset context\n    extend(context, cursor)\n    context.source = currentSource\n    // re-parse attrs and filter out v-pre itself\n    props = parseAttributes(context, type).filter(p => p.name !== 'v-pre')\n  }\n\n  // Tag close.\n  let isSelfClosing = false\n  if (context.source.length === 0) {\n    emitError(context, ErrorCodes.EOF_IN_TAG)\n  } else {\n    isSelfClosing = startsWith(context.source, '/>')\n    if (type === TagType.End && isSelfClosing) {\n      emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)\n    }\n    advanceBy(context, isSelfClosing ? 2 : 1)\n  }\n\n  let tagType = ElementTypes.ELEMENT\n  if (!context.inPre && !context.options.isCustomElement(tag)) {\n    if (context.options.isNativeTag) {\n      if (!context.options.isNativeTag(tag)) tagType = ElementTypes.COMPONENT\n    } else {\n      if (/^[A-Z]/.test(tag)) tagType = ElementTypes.COMPONENT\n    }\n\n    if (tag === 'slot') tagType = ElementTypes.SLOT\n    else if (tag === 'template') tagType = ElementTypes.TEMPLATE\n    else if (tag === 'portal' || tag === 'Portal') tagType = ElementTypes.PORTAL\n    else if (tag === 'suspense' || tag === 'Suspense')\n      tagType = ElementTypes.SUSPENSE\n  }\n\n  return {\n    type: NodeTypes.ELEMENT,\n    ns,\n    tag,\n    tagType,\n    props,\n    isSelfClosing,\n    children: [],\n    loc: getSelection(context, start),\n    codegenNode: undefined // to be created during transform phase\n  }\n}\n\nfunction parseAttributes(\n  context: ParserContext,\n  type: TagType\n): (AttributeNode | DirectiveNode)[] {\n  const props = []\n  const attributeNames = new Set<string>()\n  while (\n    context.source.length > 0 &&\n    !startsWith(context.source, '>') &&\n    !startsWith(context.source, '/>')\n  ) {\n    if (startsWith(context.source, '/')) {\n      emitError(context, ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG)\n      advanceBy(context, 1)\n      advanceSpaces(context)\n      continue\n    }\n    if (type === TagType.End) {\n      emitError(context, ErrorCodes.END_TAG_WITH_ATTRIBUTES)\n    }\n\n    const attr = parseAttribute(context, attributeNames)\n    if (type === TagType.Start) {\n      props.push(attr)\n    }\n\n    if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\n      emitError(context, ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES)\n    }\n    advanceSpaces(context)\n  }\n  return props\n}\n\nfunction parseAttribute(\n  context: ParserContext,\n  nameSet: Set<string>\n): AttributeNode | DirectiveNode {\n  __DEV__ && assert(/^[^\\t\\r\\n\\f />]/.test(context.source))\n\n  // Name.\n  const start = getCursor(context)\n  const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source)!\n  const name = match[0]\n\n  if (nameSet.has(name)) {\n    emitError(context, ErrorCodes.DUPLICATE_ATTRIBUTE)\n  }\n  nameSet.add(name)\n\n  if (name[0] === '=') {\n    emitError(context, ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME)\n  }\n  {\n    const pattern = /[\"'<]/g\n    let m: RegExpExecArray | null\n    while ((m = pattern.exec(name)) !== null) {\n      emitError(\n        context,\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\n        m.index\n      )\n    }\n  }\n\n  advanceBy(context, name.length)\n\n  // Value\n  let value:\n    | {\n        content: string\n        isQuoted: boolean\n        loc: SourceLocation\n      }\n    | undefined = undefined\n\n  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\n    advanceSpaces(context)\n    advanceBy(context, 1)\n    advanceSpaces(context)\n    value = parseAttributeValue(context)\n    if (!value) {\n      emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE)\n    }\n  }\n  const loc = getSelection(context, start)\n\n  if (!context.inPre && /^(v-|:|@|#)/.test(name)) {\n    const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\\.]+))?(.+)?$/i.exec(\n      name\n    )!\n\n    let arg: ExpressionNode | undefined\n\n    if (match[2]) {\n      const startOffset = name.split(match[2], 2)!.shift()!.length\n      const loc = getSelection(\n        context,\n        getNewPosition(context, start, startOffset),\n        getNewPosition(context, start, startOffset + match[2].length)\n      )\n      let content = match[2]\n      let isStatic = true\n\n      if (content.startsWith('[')) {\n        isStatic = false\n\n        if (!content.endsWith(']')) {\n          emitError(\n            context,\n            ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END\n          )\n        }\n\n        content = content.substr(1, content.length - 2)\n      }\n\n      arg = {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content,\n        isStatic,\n        isConstant: isStatic,\n        loc\n      }\n    }\n\n    if (value && value.isQuoted) {\n      const valueLoc = value.loc\n      valueLoc.start.offset++\n      valueLoc.start.column++\n      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)\n      valueLoc.source = valueLoc.source.slice(1, -1)\n    }\n\n    return {\n      type: NodeTypes.DIRECTIVE,\n      name:\n        match[1] ||\n        (startsWith(name, ':')\n          ? 'bind'\n          : startsWith(name, '@')\n            ? 'on'\n            : 'slot'),\n      exp: value && {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: value.content,\n        isStatic: false,\n        // Treat as non-constant by default. This can be potentially set to\n        // true by `transformExpression` to make it eligible for hoisting.\n        isConstant: false,\n        loc: value.loc\n      },\n      arg,\n      modifiers: match[3] ? match[3].substr(1).split('.') : [],\n      loc\n    }\n  }\n\n  return {\n    type: NodeTypes.ATTRIBUTE,\n    name,\n    value: value && {\n      type: NodeTypes.TEXT,\n      content: value.content,\n      isEmpty: value.content.trim().length === 0,\n      loc: value.loc\n    },\n    loc\n  }\n}\n\nfunction parseAttributeValue(\n  context: ParserContext\n):\n  | {\n      content: string\n      isQuoted: boolean\n      loc: SourceLocation\n    }\n  | undefined {\n  const start = getCursor(context)\n  let content: string\n\n  const quote = context.source[0]\n  const isQuoted = quote === `\"` || quote === `'`\n  if (isQuoted) {\n    // Quoted value.\n    advanceBy(context, 1)\n\n    const endIndex = context.source.indexOf(quote)\n    if (endIndex === -1) {\n      content = parseTextData(\n        context,\n        context.source.length,\n        TextModes.ATTRIBUTE_VALUE\n      )\n    } else {\n      content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)\n      advanceBy(context, 1)\n    }\n  } else {\n    // Unquoted\n    const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source)\n    if (!match) {\n      return undefined\n    }\n    let unexpectedChars = /[\"'<=`]/g\n    let m: RegExpExecArray | null\n    while ((m = unexpectedChars.exec(match[0])) !== null) {\n      emitError(\n        context,\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\n        m.index\n      )\n    }\n    content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)\n  }\n\n  return { content, isQuoted, loc: getSelection(context, start) }\n}\n\nfunction parseInterpolation(\n  context: ParserContext,\n  mode: TextModes\n): InterpolationNode | undefined {\n  const [open, close] = context.options.delimiters\n  __DEV__ && assert(startsWith(context.source, open))\n\n  const closeIndex = context.source.indexOf(close, open.length)\n  if (closeIndex === -1) {\n    emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)\n    return undefined\n  }\n\n  const start = getCursor(context)\n  advanceBy(context, open.length)\n  const innerStart = getCursor(context)\n  const innerEnd = getCursor(context)\n  const rawContentLength = closeIndex - open.length\n  const rawContent = context.source.slice(0, rawContentLength)\n  const preTrimContent = parseTextData(context, rawContentLength, mode)\n  const content = preTrimContent.trim()\n  const startOffset = preTrimContent.indexOf(content)\n  if (startOffset > 0) {\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\n  }\n  const endOffset =\n    rawContentLength - (preTrimContent.length - content.length - startOffset)\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\n  advanceBy(context, close.length)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      isStatic: false,\n      // Set `isConstant` to false by default and will decide in transformExpression\n      isConstant: false,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseText(context: ParserContext, mode: TextModes): TextNode {\n  __DEV__ && assert(context.source.length > 0)\n\n  const [open] = context.options.delimiters\n  const endIndex = Math.min(\n    ...[\n      context.source.indexOf('<', 1),\n      context.source.indexOf(open, 1),\n      mode === TextModes.CDATA ? context.source.indexOf(']]>') : -1,\n      context.source.length\n    ].filter(n => n !== -1)\n  )\n  __DEV__ && assert(endIndex > 0)\n\n  const start = getCursor(context)\n  const content = parseTextData(context, endIndex, mode)\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n    loc: getSelection(context, start),\n    isEmpty: !content.trim()\n  }\n}\n\n/**\n * Get text data with a given length from the current location.\n * This translates HTML entities in the text data.\n */\nfunction parseTextData(\n  context: ParserContext,\n  length: number,\n  mode: TextModes\n): string {\n  if (mode === TextModes.RAWTEXT || mode === TextModes.CDATA) {\n    const text = context.source.slice(0, length)\n    advanceBy(context, length)\n    return text\n  }\n\n  // DATA or RCDATA. Entity decoding required.\n  const end = context.offset + length\n  let text: string = ''\n\n  while (context.offset < end) {\n    const head = /&(?:#x?)?/i.exec(context.source)\n    if (!head || context.offset + head.index >= end) {\n      const remaining = end - context.offset\n      text += context.source.slice(0, remaining)\n      advanceBy(context, remaining)\n      break\n    }\n\n    // Advance to the \"&\".\n    text += context.source.slice(0, head.index)\n    advanceBy(context, head.index)\n\n    if (head[0] === '&') {\n      // Named character reference.\n      let name = '',\n        value: string | undefined = undefined\n      if (/[0-9a-z]/i.test(context.source[1])) {\n        for (\n          let length = context.maxCRNameLength;\n          !value && length > 0;\n          --length\n        ) {\n          name = context.source.substr(1, length)\n          value = context.options.namedCharacterReferences[name]\n        }\n        if (value) {\n          const semi = name.endsWith(';')\n          if (\n            mode === TextModes.ATTRIBUTE_VALUE &&\n            !semi &&\n            /[=a-z0-9]/i.test(context.source[1 + name.length] || '')\n          ) {\n            text += '&'\n            text += name\n            advanceBy(context, 1 + name.length)\n          } else {\n            text += value\n            advanceBy(context, 1 + name.length)\n            if (!semi) {\n              emitError(\n                context,\n                ErrorCodes.MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE\n              )\n            }\n          }\n        } else {\n          emitError(context, ErrorCodes.UNKNOWN_NAMED_CHARACTER_REFERENCE)\n          text += '&'\n          text += name\n          advanceBy(context, 1 + name.length)\n        }\n      } else {\n        text += '&'\n        advanceBy(context, 1)\n      }\n    } else {\n      // Numeric character reference.\n      const hex = head[0] === '&#x'\n      const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/\n      const body = pattern.exec(context.source)\n      if (!body) {\n        text += head[0]\n        emitError(\n          context,\n          ErrorCodes.ABSENCE_OF_DIGITS_IN_NUMERIC_CHARACTER_REFERENCE\n        )\n        advanceBy(context, head[0].length)\n      } else {\n        // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\n        let cp = Number.parseInt(body[1], hex ? 16 : 10)\n        if (cp === 0) {\n          emitError(context, ErrorCodes.NULL_CHARACTER_REFERENCE)\n          cp = 0xfffd\n        } else if (cp > 0x10ffff) {\n          emitError(\n            context,\n            ErrorCodes.CHARACTER_REFERENCE_OUTSIDE_UNICODE_RANGE\n          )\n          cp = 0xfffd\n        } else if (cp >= 0xd800 && cp <= 0xdfff) {\n          emitError(context, ErrorCodes.SURROGATE_CHARACTER_REFERENCE)\n          cp = 0xfffd\n        } else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) {\n          emitError(context, ErrorCodes.NONCHARACTER_CHARACTER_REFERENCE)\n        } else if (\n          (cp >= 0x01 && cp <= 0x08) ||\n          cp === 0x0b ||\n          (cp >= 0x0d && cp <= 0x1f) ||\n          (cp >= 0x7f && cp <= 0x9f)\n        ) {\n          emitError(context, ErrorCodes.CONTROL_CHARACTER_REFERENCE)\n          cp = CCR_REPLACEMENTS[cp] || cp\n        }\n        text += String.fromCodePoint(cp)\n        advanceBy(context, body[0].length)\n        if (!body![0].endsWith(';')) {\n          emitError(\n            context,\n            ErrorCodes.MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE\n          )\n        }\n      }\n    }\n  }\n  return text\n}\n\nfunction getCursor(context: ParserContext): Position {\n  const { column, line, offset } = context\n  return { column, line, offset }\n}\n\nfunction getSelection(\n  context: ParserContext,\n  start: Position,\n  end?: Position\n): SourceLocation {\n  end = end || getCursor(context)\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset)\n  }\n}\n\nfunction last<T>(xs: T[]): T | undefined {\n  return xs[xs.length - 1]\n}\n\nfunction startsWith(source: string, searchString: string): boolean {\n  return source.startsWith(searchString)\n}\n\nfunction advanceBy(context: ParserContext, numberOfCharacters: number): void {\n  const { source } = context\n  __DEV__ && assert(numberOfCharacters <= source.length)\n  advancePositionWithMutation(context, source, numberOfCharacters)\n  context.source = source.slice(numberOfCharacters)\n}\n\nfunction advanceSpaces(context: ParserContext): void {\n  const match = /^[\\t\\r\\n\\f ]+/.exec(context.source)\n  if (match) {\n    advanceBy(context, match[0].length)\n  }\n}\n\nfunction getNewPosition(\n  context: ParserContext,\n  start: Position,\n  numberOfCharacters: number\n): Position {\n  return advancePositionWithClone(\n    start,\n    context.originalSource.slice(start.offset, numberOfCharacters),\n    numberOfCharacters\n  )\n}\n\nfunction emitError(\n  context: ParserContext,\n  code: ErrorCodes,\n  offset?: number\n): void {\n  const loc = getCursor(context)\n  if (offset) {\n    loc.offset += offset\n    loc.column += offset\n  }\n  context.options.onError(\n    createCompilerError(code, {\n      start: loc,\n      end: loc,\n      source: ''\n    })\n  )\n}\n\nfunction isEnd(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): boolean {\n  const s = context.source\n\n  switch (mode) {\n    case TextModes.DATA:\n      if (startsWith(s, '</')) {\n        //TODO: probably bad performance\n        for (let i = ancestors.length - 1; i >= 0; --i) {\n          if (startsWithEndTagOpen(s, ancestors[i].tag)) {\n            return true\n          }\n        }\n      }\n      break\n\n    case TextModes.RCDATA:\n    case TextModes.RAWTEXT: {\n      const parent = last(ancestors)\n      if (parent && startsWithEndTagOpen(s, parent.tag)) {\n        return true\n      }\n      break\n    }\n\n    case TextModes.CDATA:\n      if (startsWith(s, ']]>')) {\n        return true\n      }\n      break\n  }\n\n  return !s\n}\n\nfunction startsWithEndTagOpen(source: string, tag: string): boolean {\n  return (\n    startsWith(source, '</') &&\n    source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&\n    /[\\t\\n\\f />]/.test(source[2 + tag.length] || '>')\n  )\n}\n\n// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\nconst CCR_REPLACEMENTS: { [key: number]: number | undefined } = {\n  0x80: 0x20ac,\n  0x82: 0x201a,\n  0x83: 0x0192,\n  0x84: 0x201e,\n  0x85: 0x2026,\n  0x86: 0x2020,\n  0x87: 0x2021,\n  0x88: 0x02c6,\n  0x89: 0x2030,\n  0x8a: 0x0160,\n  0x8b: 0x2039,\n  0x8c: 0x0152,\n  0x8e: 0x017d,\n  0x91: 0x2018,\n  0x92: 0x2019,\n  0x93: 0x201c,\n  0x94: 0x201d,\n  0x95: 0x2022,\n  0x96: 0x2013,\n  0x97: 0x2014,\n  0x98: 0x02dc,\n  0x99: 0x2122,\n  0x9a: 0x0161,\n  0x9b: 0x203a,\n  0x9c: 0x0153,\n  0x9e: 0x017e,\n  0x9f: 0x0178\n}\n","import {\n  RootNode,\n  NodeTypes,\n  TemplateChildNode,\n  SimpleExpressionNode,\n  ElementTypes,\n  ElementCodegenNode,\n  PlainElementNode,\n  ComponentNode,\n  TemplateNode,\n  ElementNode,\n  PlainElementCodegenNode\n} from '../ast'\nimport { TransformContext } from '../transform'\nimport { WITH_DIRECTIVES } from '../runtimeHelpers'\nimport { PatchFlags, isString, isSymbol } from '@vue/shared'\nimport { isSlotOutlet, findProp } from '../utils'\n\nexport function hoistStatic(root: RootNode, context: TransformContext) {\n  walk(\n    root.children,\n    context,\n    new Map(),\n    isSingleElementRoot(root, root.children[0])\n  )\n}\n\nexport function isSingleElementRoot(\n  root: RootNode,\n  child: TemplateChildNode\n): child is PlainElementNode | ComponentNode | TemplateNode {\n  const { children } = root\n  return (\n    children.length === 1 &&\n    child.type === NodeTypes.ELEMENT &&\n    !isSlotOutlet(child)\n  )\n}\n\nfunction walk(\n  children: TemplateChildNode[],\n  context: TransformContext,\n  resultCache: Map<TemplateChildNode, boolean>,\n  doNotHoistNode: boolean = false\n) {\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    // only plain elements are eligible for hoisting.\n    if (\n      child.type === NodeTypes.ELEMENT &&\n      child.tagType === ElementTypes.ELEMENT\n    ) {\n      if (!doNotHoistNode && isStaticNode(child, resultCache)) {\n        // whole tree is static\n        child.codegenNode = context.hoist(child.codegenNode!)\n        continue\n      } else {\n        // node may contain dynamic children, but its props may be eligible for\n        // hoisting.\n        const flag = getPatchFlag(child)\n        if (\n          (!flag ||\n            flag === PatchFlags.NEED_PATCH ||\n            flag === PatchFlags.TEXT) &&\n          !hasDynamicKeyOrRef(child) &&\n          !hasCachedProps(child)\n        ) {\n          const props = getNodeProps(child)\n          if (props && props !== `null`) {\n            getVNodeCall(child).arguments[1] = context.hoist(props)\n          }\n        }\n      }\n    }\n    if (child.type === NodeTypes.ELEMENT) {\n      walk(child.children, context, resultCache)\n    } else if (child.type === NodeTypes.FOR) {\n      // Do not hoist v-for single child because it has to be a block\n      walk(child.children, context, resultCache, child.children.length === 1)\n    } else if (child.type === NodeTypes.IF) {\n      for (let i = 0; i < child.branches.length; i++) {\n        const branchChildren = child.branches[i].children\n        // Do not hoist v-if single child because it has to be a block\n        walk(branchChildren, context, resultCache, branchChildren.length === 1)\n      }\n    }\n  }\n}\n\nexport function isStaticNode(\n  node: TemplateChildNode | SimpleExpressionNode,\n  resultCache: Map<TemplateChildNode, boolean> = new Map()\n): boolean {\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n      if (node.tagType !== ElementTypes.ELEMENT) {\n        return false\n      }\n      const cached = resultCache.get(node)\n      if (cached !== undefined) {\n        return cached\n      }\n      const flag = getPatchFlag(node)\n      if (!flag && !hasDynamicKeyOrRef(node) && !hasCachedProps(node)) {\n        // element self is static. check its children.\n        for (let i = 0; i < node.children.length; i++) {\n          if (!isStaticNode(node.children[i], resultCache)) {\n            resultCache.set(node, false)\n            return false\n          }\n        }\n        resultCache.set(node, true)\n        return true\n      } else {\n        resultCache.set(node, false)\n        return false\n      }\n    case NodeTypes.TEXT:\n    case NodeTypes.COMMENT:\n      return true\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n      return false\n    case NodeTypes.INTERPOLATION:\n    case NodeTypes.TEXT_CALL:\n      return isStaticNode(node.content, resultCache)\n    case NodeTypes.SIMPLE_EXPRESSION:\n      return node.isConstant\n    case NodeTypes.COMPOUND_EXPRESSION:\n      return node.children.every(child => {\n        return (\n          isString(child) || isSymbol(child) || isStaticNode(child, resultCache)\n        )\n      })\n    default:\n      if (__DEV__) {\n        const exhaustiveCheck: never = node\n        exhaustiveCheck\n      }\n      return false\n  }\n}\n\nfunction hasDynamicKeyOrRef(node: ElementNode): boolean {\n  return !!(findProp(node, 'key', true) || findProp(node, 'ref', true))\n}\n\nfunction hasCachedProps(node: PlainElementNode): boolean {\n  if (__BROWSER__) {\n    return false\n  }\n  const props = getNodeProps(node)\n  if (\n    props &&\n    props !== 'null' &&\n    props.type === NodeTypes.JS_OBJECT_EXPRESSION\n  ) {\n    const { properties } = props\n    for (let i = 0; i < properties.length; i++) {\n      if (properties[i].value.type === NodeTypes.JS_CACHE_EXPRESSION) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction getVNodeCall(node: PlainElementNode) {\n  let codegenNode = node.codegenNode as ElementCodegenNode\n  if (codegenNode.callee === WITH_DIRECTIVES) {\n    codegenNode = codegenNode.arguments[0]\n  }\n  return codegenNode\n}\n\nfunction getVNodeArgAt(\n  node: PlainElementNode,\n  index: number\n): PlainElementCodegenNode['arguments'][number] {\n  return getVNodeCall(node).arguments[index]\n}\n\nfunction getPatchFlag(node: PlainElementNode): number | undefined {\n  const flag = getVNodeArgAt(node, 3) as string\n  return flag ? parseInt(flag, 10) : undefined\n}\n\nfunction getNodeProps(node: PlainElementNode) {\n  return getVNodeArgAt(node, 1) as PlainElementCodegenNode['arguments'][1]\n}\n","import {\n  RootNode,\n  NodeTypes,\n  ParentNode,\n  TemplateChildNode,\n  ElementNode,\n  DirectiveNode,\n  Property,\n  ExpressionNode,\n  createSimpleExpression,\n  JSChildNode,\n  SimpleExpressionNode,\n  ElementTypes,\n  ElementCodegenNode,\n  ComponentCodegenNode,\n  createCallExpression,\n  CacheExpression,\n  createCacheExpression\n} from './ast'\nimport { isString, isArray } from '@vue/shared'\nimport { CompilerError, defaultOnError } from './errors'\nimport {\n  TO_STRING,\n  COMMENT,\n  CREATE_VNODE,\n  FRAGMENT,\n  helperNameMap,\n  WITH_DIRECTIVES,\n  CREATE_BLOCK\n} from './runtimeHelpers'\nimport { isVSlot, createBlockExpression } from './utils'\nimport { hoistStatic, isSingleElementRoot } from './transforms/hoistStatic'\n\n// There are two types of transforms:\n//\n// - NodeTransform:\n//   Transforms that operate directly on a ChildNode. NodeTransforms may mutate,\n//   replace or remove the node being processed.\nexport type NodeTransform = (\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) => void | (() => void) | (() => void)[]\n\n// - DirectiveTransform:\n//   Transforms that handles a single directive attribute on an element.\n//   It translates the raw directive into actual props for the VNode.\nexport type DirectiveTransform = (\n  dir: DirectiveNode,\n  node: ElementNode,\n  context: TransformContext,\n  // a platform specific compiler can import the base transform and augment\n  // it by passing in this optional argument.\n  augmentor?: (ret: DirectiveTransformResult) => DirectiveTransformResult\n) => DirectiveTransformResult\n\nexport interface DirectiveTransformResult {\n  props: Property[]\n  needRuntime: boolean | symbol\n}\n\n// A structural directive transform is a technically a NodeTransform;\n// Only v-if and v-for fall into this category.\nexport type StructuralDirectiveTransform = (\n  node: ElementNode,\n  dir: DirectiveNode,\n  context: TransformContext\n) => void | (() => void)\n\nexport interface TransformOptions {\n  nodeTransforms?: NodeTransform[]\n  directiveTransforms?: { [name: string]: DirectiveTransform }\n  prefixIdentifiers?: boolean\n  hoistStatic?: boolean\n  cacheHandlers?: boolean\n  onError?: (error: CompilerError) => void\n}\n\nexport interface TransformContext extends Required<TransformOptions> {\n  root: RootNode\n  helpers: Set<symbol>\n  components: Set<string>\n  directives: Set<string>\n  hoists: JSChildNode[]\n  cached: number\n  identifiers: { [name: string]: number | undefined }\n  scopes: {\n    vFor: number\n    vSlot: number\n    vPre: number\n    vOnce: number\n  }\n  parent: ParentNode | null\n  childIndex: number\n  currentNode: RootNode | TemplateChildNode | null\n  helper<T extends symbol>(name: T): T\n  helperString(name: symbol): string\n  replaceNode(node: TemplateChildNode): void\n  removeNode(node?: TemplateChildNode): void\n  onNodeRemoved(): void\n  addIdentifiers(exp: ExpressionNode | string): void\n  removeIdentifiers(exp: ExpressionNode | string): void\n  hoist(exp: JSChildNode): SimpleExpressionNode\n  cache<T extends JSChildNode>(exp: T): CacheExpression | T\n}\n\nfunction createTransformContext(\n  root: RootNode,\n  {\n    prefixIdentifiers = false,\n    hoistStatic = false,\n    cacheHandlers = false,\n    nodeTransforms = [],\n    directiveTransforms = {},\n    onError = defaultOnError\n  }: TransformOptions\n): TransformContext {\n  const context: TransformContext = {\n    root,\n    helpers: new Set(),\n    components: new Set(),\n    directives: new Set(),\n    hoists: [],\n    cached: 0,\n    identifiers: {},\n    scopes: {\n      vFor: 0,\n      vSlot: 0,\n      vPre: 0,\n      vOnce: 0\n    },\n    prefixIdentifiers,\n    hoistStatic,\n    cacheHandlers,\n    nodeTransforms,\n    directiveTransforms,\n    onError,\n    parent: null,\n    currentNode: root,\n    childIndex: 0,\n    helper(name) {\n      context.helpers.add(name)\n      return name\n    },\n    helperString(name) {\n      return (\n        (context.prefixIdentifiers ? `` : `_`) +\n        helperNameMap[context.helper(name)]\n      )\n    },\n    replaceNode(node) {\n      /* istanbul ignore if */\n      if (__DEV__) {\n        if (!context.currentNode) {\n          throw new Error(`Node being replaced is already removed.`)\n        }\n        if (!context.parent) {\n          throw new Error(`Cannot replace root node.`)\n        }\n      }\n      context.parent!.children[context.childIndex] = context.currentNode = node\n    },\n    removeNode(node) {\n      if (__DEV__ && !context.parent) {\n        throw new Error(`Cannot remove root node.`)\n      }\n      const list = context.parent!.children\n      const removalIndex = node\n        ? list.indexOf(node)\n        : context.currentNode\n          ? context.childIndex\n          : -1\n      /* istanbul ignore if */\n      if (__DEV__ && removalIndex < 0) {\n        throw new Error(`node being removed is not a child of current parent`)\n      }\n      if (!node || node === context.currentNode) {\n        // current node removed\n        context.currentNode = null\n        context.onNodeRemoved()\n      } else {\n        // sibling node removed\n        if (context.childIndex > removalIndex) {\n          context.childIndex--\n          context.onNodeRemoved()\n        }\n      }\n      context.parent!.children.splice(removalIndex, 1)\n    },\n    onNodeRemoved: () => {},\n    addIdentifiers(exp) {\n      // identifier tracking only happens in non-browser builds.\n      if (!__BROWSER__) {\n        if (isString(exp)) {\n          addId(exp)\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(addId)\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          addId(exp.content)\n        }\n      }\n    },\n    removeIdentifiers(exp) {\n      if (!__BROWSER__) {\n        if (isString(exp)) {\n          removeId(exp)\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(removeId)\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          removeId(exp.content)\n        }\n      }\n    },\n    hoist(exp) {\n      context.hoists.push(exp)\n      return createSimpleExpression(\n        `_hoisted_${context.hoists.length}`,\n        false,\n        exp.loc\n      )\n    },\n    cache(exp) {\n      return cacheHandlers ? createCacheExpression(++context.cached, exp) : exp\n    }\n  }\n\n  function addId(id: string) {\n    const { identifiers } = context\n    if (identifiers[id] === undefined) {\n      identifiers[id] = 0\n    }\n    identifiers[id]!++\n  }\n\n  function removeId(id: string) {\n    context.identifiers[id]!--\n  }\n\n  return context\n}\n\nexport function transform(root: RootNode, options: TransformOptions) {\n  const context = createTransformContext(root, options)\n  traverseNode(root, context)\n  if (options.hoistStatic) {\n    hoistStatic(root, context)\n  }\n  finalizeRoot(root, context)\n}\n\nfunction finalizeRoot(root: RootNode, context: TransformContext) {\n  const { helper } = context\n  const { children } = root\n  const child = children[0]\n  if (children.length === 1) {\n    // if the single child is an element, turn it into a block.\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\n      // single element root is never hoisted so codegenNode will never be\n      // SimpleExpressionNode\n      const codegenNode = child.codegenNode as\n        | ElementCodegenNode\n        | ComponentCodegenNode\n      if (codegenNode.callee === WITH_DIRECTIVES) {\n        codegenNode.arguments[0].callee = helper(CREATE_BLOCK)\n      } else {\n        codegenNode.callee = helper(CREATE_BLOCK)\n      }\n      root.codegenNode = createBlockExpression(codegenNode, context)\n    } else {\n      // - single <slot/>, IfNode, ForNode: already blocks.\n      // - single text node: always patched.\n      // root codegen falls through via genNode()\n      root.codegenNode = child\n    }\n  } else if (children.length > 1) {\n    // root has multiple nodes - return a fragment block.\n    root.codegenNode = createBlockExpression(\n      createCallExpression(helper(CREATE_BLOCK), [\n        helper(FRAGMENT),\n        `null`,\n        root.children\n      ]),\n      context\n    )\n  } else {\n    // no children = noop. codegen will return null.\n  }\n  // finalize meta information\n  root.helpers = [...context.helpers]\n  root.components = [...context.components]\n  root.directives = [...context.directives]\n  root.hoists = context.hoists\n  root.cached = context.cached\n}\n\nexport function traverseChildren(\n  parent: ParentNode,\n  context: TransformContext\n) {\n  let i = 0\n  const nodeRemoved = () => {\n    i--\n  }\n  for (; i < parent.children.length; i++) {\n    const child = parent.children[i]\n    if (isString(child)) continue\n    context.currentNode = child\n    context.parent = parent\n    context.childIndex = i\n    context.onNodeRemoved = nodeRemoved\n    traverseNode(child, context)\n  }\n}\n\nexport function traverseNode(\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) {\n  // apply transform plugins\n  const { nodeTransforms } = context\n  const exitFns = []\n  for (let i = 0; i < nodeTransforms.length; i++) {\n    const onExit = nodeTransforms[i](node, context)\n    if (onExit) {\n      if (isArray(onExit)) {\n        exitFns.push(...onExit)\n      } else {\n        exitFns.push(onExit)\n      }\n    }\n    if (!context.currentNode) {\n      // node was removed\n      return\n    } else {\n      // node may have been replaced\n      node = context.currentNode\n    }\n  }\n\n  switch (node.type) {\n    case NodeTypes.COMMENT:\n      // inject import for the Comment symbol, which is needed for creating\n      // comment nodes with `createVNode`\n      context.helper(CREATE_VNODE)\n      context.helper(COMMENT)\n      break\n    case NodeTypes.INTERPOLATION:\n      // no need to traverse, but we need to inject toString helper\n      context.helper(TO_STRING)\n      break\n\n    // for container types, further traverse downwards\n    case NodeTypes.IF:\n      for (let i = 0; i < node.branches.length; i++) {\n        traverseChildren(node.branches[i], context)\n      }\n      break\n    case NodeTypes.FOR:\n    case NodeTypes.ELEMENT:\n    case NodeTypes.ROOT:\n      traverseChildren(node, context)\n      break\n  }\n\n  // exit transforms\n  let i = exitFns.length\n  while (i--) {\n    exitFns[i]()\n  }\n}\n\nexport function createStructuralDirectiveTransform(\n  name: string | RegExp,\n  fn: StructuralDirectiveTransform\n): NodeTransform {\n  const matches = isString(name)\n    ? (n: string) => n === name\n    : (n: string) => name.test(n)\n\n  return (node, context) => {\n    if (node.type === NodeTypes.ELEMENT) {\n      const { props } = node\n      // structural directive transforms are not concerned with slots\n      // as they are handled separately in vSlot.ts\n      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {\n        return\n      }\n      const exitFns = []\n      for (let i = 0; i < props.length; i++) {\n        const prop = props[i]\n        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {\n          // structural directives are removed to avoid infinite recursion\n          // also we remove them *before* applying so that it can further\n          // traverse itself in case it moves the node around\n          props.splice(i, 1)\n          i--\n          const onExit = fn(node, prop, context)\n          if (onExit) exitFns.push(onExit)\n        }\n      }\n      return exitFns\n    }\n  }\n}\n","import {\n  RootNode,\n  TemplateChildNode,\n  TextNode,\n  CommentNode,\n  ExpressionNode,\n  NodeTypes,\n  JSChildNode,\n  CallExpression,\n  ArrayExpression,\n  ObjectExpression,\n  SourceLocation,\n  Position,\n  InterpolationNode,\n  CompoundExpressionNode,\n  SimpleExpressionNode,\n  FunctionExpression,\n  SequenceExpression,\n  ConditionalExpression,\n  CacheExpression\n} from './ast'\nimport { SourceMapGenerator, RawSourceMap } from 'source-map'\nimport {\n  advancePositionWithMutation,\n  assert,\n  isSimpleIdentifier,\n  loadDep,\n  toValidAssetId\n} from './utils'\nimport { isString, isArray, isSymbol } from '@vue/shared'\nimport {\n  TO_STRING,\n  CREATE_VNODE,\n  COMMENT,\n  helperNameMap,\n  RESOLVE_COMPONENT,\n  RESOLVE_DIRECTIVE\n} from './runtimeHelpers'\n\ntype CodegenNode = TemplateChildNode | JSChildNode\n\nexport interface CodegenOptions {\n  // - Module mode will generate ES module import statements for helpers\n  //   and export the render function as the default export.\n  // - Function mode will generate a single `const { helpers... } = Vue`\n  //   statement and return the render function. It is meant to be used with\n  //   `new Function(code)()` to generate a render function at runtime.\n  // Default: 'function'\n  mode?: 'module' | 'function'\n  // Prefix suitable identifiers with _ctx.\n  // If this option is false, the generated code will be wrapped in a\n  // `with (this) { ... }` block.\n  // Default: false\n  prefixIdentifiers?: boolean\n  // Generate source map?\n  // Default: false\n  sourceMap?: boolean\n  // Filename for source map generation.\n  // Default: `template.vue.html`\n  filename?: string\n}\n\nexport interface CodegenResult {\n  code: string\n  ast: RootNode\n  map?: RawSourceMap\n}\n\nexport interface CodegenContext extends Required<CodegenOptions> {\n  source: string\n  code: string\n  line: number\n  column: number\n  offset: number\n  indentLevel: number\n  map?: SourceMapGenerator\n  helper(key: symbol): string\n  push(code: string, node?: CodegenNode, openOnly?: boolean): void\n  resetMapping(loc: SourceLocation): void\n  indent(): void\n  deindent(withoutNewLine?: boolean): void\n  newline(): void\n}\n\nfunction createCodegenContext(\n  ast: RootNode,\n  {\n    mode = 'function',\n    prefixIdentifiers = mode === 'module',\n    sourceMap = false,\n    filename = `template.vue.html`\n  }: CodegenOptions\n): CodegenContext {\n  const context: CodegenContext = {\n    mode,\n    prefixIdentifiers,\n    sourceMap,\n    filename,\n    source: ast.loc.source,\n    code: ``,\n    column: 1,\n    line: 1,\n    offset: 0,\n    indentLevel: 0,\n\n    // lazy require source-map implementation, only in non-browser builds!\n    map:\n      __BROWSER__ || !sourceMap\n        ? undefined\n        : new (loadDep('source-map')).SourceMapGenerator(),\n\n    helper(key) {\n      const name = helperNameMap[key]\n      return prefixIdentifiers ? name : `_${name}`\n    },\n    push(code, node, openOnly) {\n      context.code += code\n      if (!__BROWSER__ && context.map) {\n        if (node) {\n          let name\n          if (node.type === NodeTypes.SIMPLE_EXPRESSION && !node.isStatic) {\n            const content = node.content.replace(/^_ctx\\./, '')\n            if (content !== node.content && isSimpleIdentifier(content)) {\n              name = content\n            }\n          }\n          addMapping(node.loc.start, name)\n        }\n        advancePositionWithMutation(context, code)\n        if (node && !openOnly) {\n          addMapping(node.loc.end)\n        }\n      }\n    },\n    resetMapping(loc: SourceLocation) {\n      if (!__BROWSER__ && context.map) {\n        addMapping(loc.start)\n      }\n    },\n    indent() {\n      newline(++context.indentLevel)\n    },\n    deindent(withoutNewLine = false) {\n      if (withoutNewLine) {\n        --context.indentLevel\n      } else {\n        newline(--context.indentLevel)\n      }\n    },\n    newline() {\n      newline(context.indentLevel)\n    }\n  }\n\n  function newline(n: number) {\n    context.push('\\n' + `  `.repeat(n))\n  }\n\n  function addMapping(loc: Position, name?: string) {\n    context.map!.addMapping({\n      name,\n      source: context.filename,\n      original: {\n        line: loc.line,\n        column: loc.column - 1 // source-map column is 0 based\n      },\n      generated: {\n        line: context.line,\n        column: context.column - 1\n      }\n    })\n  }\n\n  if (!__BROWSER__ && context.map) {\n    context.map.setSourceContent(filename, context.source)\n  }\n  return context\n}\n\nexport function generate(\n  ast: RootNode,\n  options: CodegenOptions = {}\n): CodegenResult {\n  const context = createCodegenContext(ast, options)\n  const {\n    mode,\n    push,\n    helper,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline\n  } = context\n  const hasHelpers = ast.helpers.length > 0\n  const useWithBlock = !prefixIdentifiers && mode !== 'module'\n\n  // preambles\n  if (mode === 'function') {\n    // Generate const declaration for helpers\n    // In prefix mode, we place the const declaration at top so it's done\n    // only once; But if we not prefixing, we place the declaration inside the\n    // with block so it doesn't incur the `in` check cost for every helper access.\n    if (hasHelpers) {\n      if (prefixIdentifiers) {\n        push(`const { ${ast.helpers.map(helper).join(', ')} } = Vue\\n`)\n      } else {\n        // \"with\" mode.\n        // save Vue in a separate variable to avoid collision\n        push(`const _Vue = Vue\\n`)\n        // in \"with\" mode, helpers are declared inside the with block to avoid\n        // has check cost, but hoists are lifted out of the function - we need\n        // to provide the helper here.\n        if (ast.hoists.length) {\n          push(`const _${helperNameMap[CREATE_VNODE]} = Vue.createVNode\\n`)\n          if (ast.helpers.includes(COMMENT)) {\n            push(`const _${helperNameMap[COMMENT]} = Vue.Comment\\n`)\n          }\n        }\n      }\n    }\n    genHoists(ast.hoists, context)\n    newline()\n    push(`return `)\n  } else {\n    // generate import statements for helpers\n    if (hasHelpers) {\n      push(`import { ${ast.helpers.map(helper).join(', ')} } from \"vue\"\\n`)\n    }\n    genHoists(ast.hoists, context)\n    newline()\n    push(`export default `)\n  }\n\n  // enter render function\n  push(`function render() {`)\n  indent()\n\n  if (useWithBlock) {\n    push(`with (this) {`)\n    indent()\n    // function mode const declarations should be inside with block\n    // also they should be renamed to avoid collision with user properties\n    if (hasHelpers) {\n      push(\n        `const { ${ast.helpers\n          .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)\n          .join(', ')} } = _Vue`\n      )\n      newline()\n      newline()\n    }\n  } else {\n    push(`const _ctx = this`)\n    if (ast.cached > 0) {\n      newline()\n      push(`const _cache = _ctx.$cache`)\n    }\n    newline()\n  }\n\n  // generate asset resolution statements\n  if (ast.components.length) {\n    genAssets(ast.components, 'component', context)\n  }\n  if (ast.directives.length) {\n    genAssets(ast.directives, 'directive', context)\n  }\n  if (ast.components.length || ast.directives.length) {\n    newline()\n  }\n\n  // generate the VNode tree expression\n  push(`return `)\n  if (ast.codegenNode) {\n    genNode(ast.codegenNode, context)\n  } else {\n    push(`null`)\n  }\n\n  if (useWithBlock) {\n    deindent()\n    push(`}`)\n  }\n\n  deindent()\n  push(`}`)\n  return {\n    ast,\n    code: context.code,\n    map: context.map ? context.map.toJSON() : undefined\n  }\n}\n\nfunction genAssets(\n  assets: string[],\n  type: 'component' | 'directive',\n  context: CodegenContext\n) {\n  const resolver = context.helper(\n    type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE\n  )\n  for (let i = 0; i < assets.length; i++) {\n    const id = assets[i]\n    context.push(\n      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`\n    )\n    context.newline()\n  }\n}\n\nfunction genHoists(hoists: JSChildNode[], context: CodegenContext) {\n  if (!hoists.length) {\n    return\n  }\n  context.newline()\n  hoists.forEach((exp, i) => {\n    context.push(`const _hoisted_${i + 1} = `)\n    genNode(exp, context)\n    context.newline()\n  })\n}\n\nfunction isText(n: string | CodegenNode) {\n  return (\n    isString(n) ||\n    n.type === NodeTypes.SIMPLE_EXPRESSION ||\n    n.type === NodeTypes.TEXT ||\n    n.type === NodeTypes.INTERPOLATION ||\n    n.type === NodeTypes.COMPOUND_EXPRESSION\n  )\n}\n\nfunction genNodeListAsArray(\n  nodes: (string | CodegenNode | TemplateChildNode[])[],\n  context: CodegenContext\n) {\n  const multilines =\n    nodes.length > 3 ||\n    ((!__BROWSER__ || __DEV__) && nodes.some(n => isArray(n) || !isText(n)))\n  context.push(`[`)\n  multilines && context.indent()\n  genNodeList(nodes, context, multilines)\n  multilines && context.deindent()\n  context.push(`]`)\n}\n\nfunction genNodeList(\n  nodes: (string | symbol | CodegenNode | TemplateChildNode[])[],\n  context: CodegenContext,\n  multilines: boolean = false\n) {\n  const { push, newline } = context\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]\n    if (isString(node)) {\n      push(node)\n    } else if (isArray(node)) {\n      genNodeListAsArray(node, context)\n    } else {\n      genNode(node, context)\n    }\n    if (i < nodes.length - 1) {\n      if (multilines) {\n        push(',')\n        newline()\n      } else {\n        push(', ')\n      }\n    }\n  }\n}\n\nfunction genNode(node: CodegenNode | symbol | string, context: CodegenContext) {\n  if (isString(node)) {\n    context.push(node)\n    return\n  }\n  if (isSymbol(node)) {\n    context.push(context.helper(node))\n    return\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n      __DEV__ &&\n        assert(\n          node.codegenNode != null,\n          `Codegen node is missing for element/if/for node. ` +\n            `Apply appropriate transforms first.`\n        )\n      genNode(node.codegenNode!, context)\n      break\n    case NodeTypes.TEXT:\n      genText(node, context)\n      break\n    case NodeTypes.SIMPLE_EXPRESSION:\n      genExpression(node, context)\n      break\n    case NodeTypes.INTERPOLATION:\n      genInterpolation(node, context)\n      break\n    case NodeTypes.TEXT_CALL:\n      genNode(node.codegenNode, context)\n      break\n    case NodeTypes.COMPOUND_EXPRESSION:\n      genCompoundExpression(node, context)\n      break\n    case NodeTypes.COMMENT:\n      genComment(node, context)\n      break\n    case NodeTypes.JS_CALL_EXPRESSION:\n      genCallExpression(node, context)\n      break\n    case NodeTypes.JS_OBJECT_EXPRESSION:\n      genObjectExpression(node, context)\n      break\n    case NodeTypes.JS_ARRAY_EXPRESSION:\n      genArrayExpression(node, context)\n      break\n    case NodeTypes.JS_FUNCTION_EXPRESSION:\n      genFunctionExpression(node, context)\n      break\n    case NodeTypes.JS_SEQUENCE_EXPRESSION:\n      genSequenceExpression(node, context)\n      break\n    case NodeTypes.JS_CONDITIONAL_EXPRESSION:\n      genConditionalExpression(node, context)\n      break\n    case NodeTypes.JS_CACHE_EXPRESSION:\n      genCacheExpression(node, context)\n      break\n    /* istanbul ignore next */\n    default:\n      if (__DEV__) {\n        assert(false, `unhandled codegen node type: ${(node as any).type}`)\n        // make sure we exhaust all possible types\n        const exhaustiveCheck: never = node\n        return exhaustiveCheck\n      }\n  }\n}\n\nfunction genText(\n  node: TextNode | SimpleExpressionNode,\n  context: CodegenContext\n) {\n  context.push(JSON.stringify(node.content), node)\n}\n\nfunction genExpression(node: SimpleExpressionNode, context: CodegenContext) {\n  const { content, isStatic } = node\n  context.push(isStatic ? JSON.stringify(content) : content, node)\n}\n\nfunction genInterpolation(node: InterpolationNode, context: CodegenContext) {\n  const { push, helper } = context\n  push(`${helper(TO_STRING)}(`)\n  genNode(node.content, context)\n  push(`)`)\n}\n\nfunction genCompoundExpression(\n  node: CompoundExpressionNode,\n  context: CodegenContext\n) {\n  for (let i = 0; i < node.children!.length; i++) {\n    const child = node.children![i]\n    if (isString(child)) {\n      context.push(child)\n    } else {\n      genNode(child, context)\n    }\n  }\n}\n\nfunction genExpressionAsPropertyKey(\n  node: ExpressionNode,\n  context: CodegenContext\n) {\n  const { push } = context\n  if (node.type === NodeTypes.COMPOUND_EXPRESSION) {\n    push(`[`)\n    genCompoundExpression(node, context)\n    push(`]`)\n  } else if (node.isStatic) {\n    // only quote keys if necessary\n    const text = isSimpleIdentifier(node.content)\n      ? node.content\n      : JSON.stringify(node.content)\n    push(text, node)\n  } else {\n    push(`[${node.content}]`, node)\n  }\n}\n\nfunction genComment(node: CommentNode, context: CodegenContext) {\n  if (__DEV__) {\n    const { push, helper } = context\n    push(\n      `${helper(CREATE_VNODE)}(${helper(COMMENT)}, null, ${JSON.stringify(\n        node.content\n      )})`,\n      node\n    )\n  }\n}\n\n// JavaScript\nfunction genCallExpression(node: CallExpression, context: CodegenContext) {\n  const callee = isString(node.callee)\n    ? node.callee\n    : context.helper(node.callee)\n  context.push(callee + `(`, node, true)\n  genNodeList(node.arguments, context)\n  context.push(`)`)\n}\n\nfunction genObjectExpression(node: ObjectExpression, context: CodegenContext) {\n  const { push, indent, deindent, newline, resetMapping } = context\n  const { properties } = node\n  if (!properties.length) {\n    push(`{}`, node)\n    return\n  }\n  const multilines =\n    properties.length > 1 ||\n    ((!__BROWSER__ || __DEV__) &&\n      properties.some(p => p.value.type !== NodeTypes.SIMPLE_EXPRESSION))\n  push(multilines ? `{` : `{ `)\n  multilines && indent()\n  for (let i = 0; i < properties.length; i++) {\n    const { key, value, loc } = properties[i]\n    resetMapping(loc) // reset source mapping for every property.\n    // key\n    genExpressionAsPropertyKey(key, context)\n    push(`: `)\n    // value\n    genNode(value, context)\n    if (i < properties.length - 1) {\n      // will only reach this if it's multilines\n      push(`,`)\n      newline()\n    }\n  }\n  multilines && deindent()\n  const lastChar = context.code[context.code.length - 1]\n  push(multilines || /[\\])}]/.test(lastChar) ? `}` : ` }`)\n}\n\nfunction genArrayExpression(node: ArrayExpression, context: CodegenContext) {\n  genNodeListAsArray(node.elements, context)\n}\n\nfunction genFunctionExpression(\n  node: FunctionExpression,\n  context: CodegenContext\n) {\n  const { push, indent, deindent } = context\n  const { params, returns, newline } = node\n  push(`(`, node)\n  if (isArray(params)) {\n    genNodeList(params, context)\n  } else if (params) {\n    genNode(params, context)\n  }\n  push(`) => `)\n  if (newline) {\n    push(`{`)\n    indent()\n    push(`return `)\n  }\n  if (isArray(returns)) {\n    genNodeListAsArray(returns, context)\n  } else {\n    genNode(returns, context)\n  }\n  if (newline) {\n    deindent()\n    push(`}`)\n  }\n}\n\nfunction genConditionalExpression(\n  node: ConditionalExpression,\n  context: CodegenContext\n) {\n  const { test, consequent, alternate } = node\n  const { push, indent, deindent, newline } = context\n  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {\n    const needsParens = !isSimpleIdentifier(test.content)\n    needsParens && push(`(`)\n    genExpression(test, context)\n    needsParens && push(`)`)\n  } else {\n    push(`(`)\n    genCompoundExpression(test, context)\n    push(`)`)\n  }\n  indent()\n  context.indentLevel++\n  push(`? `)\n  genNode(consequent, context)\n  context.indentLevel--\n  newline()\n  push(`: `)\n  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\n  if (!isNested) {\n    context.indentLevel++\n  }\n  genNode(alternate, context)\n  if (!isNested) {\n    context.indentLevel--\n  }\n  deindent(true /* without newline */)\n}\n\nfunction genSequenceExpression(\n  node: SequenceExpression,\n  context: CodegenContext\n) {\n  context.push(`(`)\n  genNodeList(node.expressions, context)\n  context.push(`)`)\n}\n\nfunction genCacheExpression(node: CacheExpression, context: CodegenContext) {\n  context.push(`_cache[${node.index}] || (_cache[${node.index}] = `)\n  genNode(node.value, context)\n  context.push(`)`)\n}\n","import {\n  createStructuralDirectiveTransform,\n  traverseChildren,\n  TransformContext\n} from '../transform'\nimport {\n  NodeTypes,\n  ElementTypes,\n  ElementNode,\n  DirectiveNode,\n  IfBranchNode,\n  SimpleExpressionNode,\n  createSequenceExpression,\n  createCallExpression,\n  createConditionalExpression,\n  ConditionalExpression,\n  CallExpression,\n  createSimpleExpression,\n  createObjectProperty,\n  createObjectExpression,\n  IfCodegenNode,\n  IfConditionalExpression,\n  BlockCodegenNode,\n  SlotOutletCodegenNode,\n  ElementCodegenNode,\n  ComponentCodegenNode\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { processExpression } from './transformExpression'\nimport {\n  OPEN_BLOCK,\n  CREATE_BLOCK,\n  COMMENT,\n  FRAGMENT,\n  WITH_DIRECTIVES,\n  CREATE_VNODE\n} from '../runtimeHelpers'\nimport { injectProp } from '../utils'\n\nexport const transformIf = createStructuralDirectiveTransform(\n  /^(if|else|else-if)$/,\n  (node, dir, context) => {\n    if (\n      dir.name !== 'else' &&\n      (!dir.exp || !(dir.exp as SimpleExpressionNode).content.trim())\n    ) {\n      const loc = dir.exp ? dir.exp.loc : node.loc\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_IF_NO_EXPRESSION, dir.loc)\n      )\n      dir.exp = createSimpleExpression(`true`, false, loc)\n    }\n\n    if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {\n      // dir.exp can only be simple expression because vIf transform is applied\n      // before expression transform.\n      dir.exp = processExpression(dir.exp as SimpleExpressionNode, context)\n    }\n\n    if (dir.name === 'if') {\n      const branch = createIfBranch(node, dir)\n      const codegenNode = createSequenceExpression([\n        createCallExpression(context.helper(OPEN_BLOCK))\n      ]) as IfCodegenNode\n\n      context.replaceNode({\n        type: NodeTypes.IF,\n        loc: node.loc,\n        branches: [branch],\n        codegenNode\n      })\n\n      // Exit callback. Complete the codegenNode when all children have been\n      // transformed.\n      return () => {\n        codegenNode.expressions.push(createCodegenNodeForBranch(\n          branch,\n          0,\n          context\n        ) as IfConditionalExpression)\n      }\n    } else {\n      // locate the adjacent v-if\n      const siblings = context.parent!.children\n      const comments = []\n      let i = siblings.indexOf(node)\n      while (i-- >= -1) {\n        const sibling = siblings[i]\n        if (__DEV__ && sibling && sibling.type === NodeTypes.COMMENT) {\n          context.removeNode(sibling)\n          comments.unshift(sibling)\n          continue\n        }\n        if (sibling && sibling.type === NodeTypes.IF) {\n          // move the node to the if node's branches\n          context.removeNode()\n          const branch = createIfBranch(node, dir)\n          if (__DEV__ && comments.length) {\n            branch.children = [...comments, ...branch.children]\n          }\n          sibling.branches.push(branch)\n          // since the branch was removed, it will not be traversed.\n          // make sure to traverse here.\n          traverseChildren(branch, context)\n          // make sure to reset currentNode after traversal to indicate this\n          // node has been removed.\n          context.currentNode = null\n          // attach this branch's codegen node to the v-if root.\n          let parentCondition = sibling.codegenNode\n            .expressions[1] as ConditionalExpression\n          while (true) {\n            if (\n              parentCondition.alternate.type ===\n              NodeTypes.JS_CONDITIONAL_EXPRESSION\n            ) {\n              parentCondition = parentCondition.alternate\n            } else {\n              parentCondition.alternate = createCodegenNodeForBranch(\n                branch,\n                sibling.branches.length - 1,\n                context\n              )\n              break\n            }\n          }\n        } else {\n          context.onError(\n            createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc)\n          )\n        }\n        break\n      }\n    }\n  }\n)\n\nfunction createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode {\n  return {\n    type: NodeTypes.IF_BRANCH,\n    loc: node.loc,\n    condition: dir.name === 'else' ? undefined : dir.exp,\n    children: node.tagType === ElementTypes.TEMPLATE ? node.children : [node]\n  }\n}\n\nfunction createCodegenNodeForBranch(\n  branch: IfBranchNode,\n  index: number,\n  context: TransformContext\n): IfConditionalExpression | BlockCodegenNode {\n  if (branch.condition) {\n    return createConditionalExpression(\n      branch.condition,\n      createChildrenCodegenNode(branch, index, context),\n      createCallExpression(context.helper(CREATE_BLOCK), [\n        context.helper(COMMENT)\n      ])\n    ) as IfConditionalExpression\n  } else {\n    return createChildrenCodegenNode(branch, index, context) as BlockCodegenNode\n  }\n}\n\nfunction createChildrenCodegenNode(\n  branch: IfBranchNode,\n  index: number,\n  context: TransformContext\n): CallExpression {\n  const { helper } = context\n  const keyProperty = createObjectProperty(\n    `key`,\n    createSimpleExpression(index + '', false)\n  )\n  const { children } = branch\n  const child = children[0]\n  const needFragmentWrapper =\n    children.length !== 1 || child.type !== NodeTypes.ELEMENT\n  if (needFragmentWrapper) {\n    const blockArgs: CallExpression['arguments'] = [\n      helper(FRAGMENT),\n      createObjectExpression([keyProperty]),\n      children\n    ]\n    if (children.length === 1 && child.type === NodeTypes.FOR) {\n      // optimize away nested fragments when child is a ForNode\n      const forBlockArgs = child.codegenNode.expressions[1].arguments\n      // directly use the for block's children and patchFlag\n      blockArgs[2] = forBlockArgs[2]\n      blockArgs[3] = forBlockArgs[3]\n    }\n    return createCallExpression(helper(CREATE_BLOCK), blockArgs)\n  } else {\n    const childCodegen = (child as ElementNode).codegenNode as\n      | ElementCodegenNode\n      | ComponentCodegenNode\n      | SlotOutletCodegenNode\n    let vnodeCall = childCodegen\n    // Element with custom directives. Locate the actual createVNode() call.\n    if (vnodeCall.callee === WITH_DIRECTIVES) {\n      vnodeCall = vnodeCall.arguments[0]\n    }\n    // Change createVNode to createBlock.\n    if (vnodeCall.callee === CREATE_VNODE) {\n      vnodeCall.callee = helper(CREATE_BLOCK)\n    }\n    // inject branch key\n    injectProp(vnodeCall, keyProperty, context)\n    return childCodegen\n  }\n}\n","import {\n  createStructuralDirectiveTransform,\n  TransformContext\n} from '../transform'\nimport {\n  NodeTypes,\n  ExpressionNode,\n  createSimpleExpression,\n  SourceLocation,\n  SimpleExpressionNode,\n  createSequenceExpression,\n  createCallExpression,\n  createFunctionExpression,\n  ElementTypes,\n  createObjectExpression,\n  createObjectProperty,\n  ForCodegenNode,\n  ElementCodegenNode\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  getInnerRange,\n  findProp,\n  createBlockExpression,\n  isTemplateNode,\n  isSlotOutlet,\n  injectProp\n} from '../utils'\nimport {\n  RENDER_LIST,\n  OPEN_BLOCK,\n  CREATE_BLOCK,\n  FRAGMENT,\n  WITH_DIRECTIVES\n} from '../runtimeHelpers'\nimport { processExpression } from './transformExpression'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\n\nexport const transformFor = createStructuralDirectiveTransform(\n  'for',\n  (node, dir, context) => {\n    if (!dir.exp) {\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_FOR_NO_EXPRESSION, dir.loc)\n      )\n      return\n    }\n\n    const parseResult = parseForExpression(\n      // can only be simple expression because vFor transform is applied\n      // before expression transform.\n      dir.exp as SimpleExpressionNode,\n      context\n    )\n\n    if (!parseResult) {\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, dir.loc)\n      )\n      return\n    }\n\n    const { helper, addIdentifiers, removeIdentifiers, scopes } = context\n    const { source, value, key, index } = parseResult\n\n    // create the loop render function expression now, and add the\n    // iterator on exit after all children have been traversed\n    const renderExp = createCallExpression(helper(RENDER_LIST), [source])\n    const keyProp = findProp(node, `key`)\n    const fragmentFlag = keyProp\n      ? PatchFlags.KEYED_FRAGMENT\n      : PatchFlags.UNKEYED_FRAGMENT\n    const codegenNode = createSequenceExpression([\n      // fragment blocks disable tracking since they always diff their children\n      createCallExpression(helper(OPEN_BLOCK), [`false`]),\n      createCallExpression(helper(CREATE_BLOCK), [\n        helper(FRAGMENT),\n        `null`,\n        renderExp,\n        fragmentFlag + (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``)\n      ])\n    ]) as ForCodegenNode\n\n    context.replaceNode({\n      type: NodeTypes.FOR,\n      loc: dir.loc,\n      source,\n      valueAlias: value,\n      keyAlias: key,\n      objectIndexAlias: index,\n      children: node.tagType === ElementTypes.TEMPLATE ? node.children : [node],\n      codegenNode\n    })\n\n    // bookkeeping\n    scopes.vFor++\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      // scope management\n      // inject identifiers to context\n      value && addIdentifiers(value)\n      key && addIdentifiers(key)\n      index && addIdentifiers(index)\n    }\n\n    return () => {\n      scopes.vFor--\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        value && removeIdentifiers(value)\n        key && removeIdentifiers(key)\n        index && removeIdentifiers(index)\n      }\n\n      // finish the codegen now that all children have been traversed\n      let childBlock\n      const isTemplate = isTemplateNode(node)\n      const slotOutlet = isSlotOutlet(node)\n        ? node\n        : isTemplate &&\n          node.children.length === 1 &&\n          isSlotOutlet(node.children[0])\n          ? node.children[0]\n          : null\n      const keyProperty = keyProp\n        ? createObjectProperty(\n            `key`,\n            keyProp.type === NodeTypes.ATTRIBUTE\n              ? createSimpleExpression(keyProp.value!.content, true)\n              : keyProp.exp!\n          )\n        : null\n      if (slotOutlet) {\n        // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\n        childBlock = slotOutlet.codegenNode!\n        if (isTemplate && keyProperty) {\n          // <template v-for=\"...\" :key=\"...\"><slot/></template>\n          // we need to inject the key to the renderSlot() call.\n          // the props for renderSlot is passed as the 3rd argument.\n          injectProp(childBlock, keyProperty, context)\n        }\n      } else if (isTemplate) {\n        // <template v-for=\"...\">\n        // should generate a fragment block for each loop\n        childBlock = createBlockExpression(\n          createCallExpression(helper(CREATE_BLOCK), [\n            helper(FRAGMENT),\n            keyProperty ? createObjectExpression([keyProperty]) : `null`,\n            node.children\n          ]),\n          context\n        )\n      } else {\n        // Normal element v-for. Directly use the child's codegenNode\n        // arguments, but replace createVNode() with createBlock()\n        let codegenNode = node.codegenNode as ElementCodegenNode\n        if (codegenNode.callee === WITH_DIRECTIVES) {\n          codegenNode.arguments[0].callee = helper(CREATE_BLOCK)\n        } else {\n          codegenNode.callee = helper(CREATE_BLOCK)\n        }\n        childBlock = createBlockExpression(codegenNode, context)\n      }\n\n      renderExp.arguments.push(\n        createFunctionExpression(\n          createForLoopParams(parseResult),\n          childBlock,\n          true /* force newline */\n        )\n      )\n    }\n  }\n)\n\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\n// This regex doesn't cover the case if key or index aliases have destructuring,\n// but those do not make sense in the first place, so this works in practice.\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\nconst stripParensRE = /^\\(|\\)$/g\n\nexport interface ForParseResult {\n  source: ExpressionNode\n  value: ExpressionNode | undefined\n  key: ExpressionNode | undefined\n  index: ExpressionNode | undefined\n}\n\nexport function parseForExpression(\n  input: SimpleExpressionNode,\n  context: TransformContext\n): ForParseResult | undefined {\n  const loc = input.loc\n  const exp = input.content\n  const inMatch = exp.match(forAliasRE)\n  if (!inMatch) return\n\n  const [, LHS, RHS] = inMatch\n\n  const result: ForParseResult = {\n    source: createAliasExpression(\n      loc,\n      RHS.trim(),\n      exp.indexOf(RHS, LHS.length)\n    ),\n    value: undefined,\n    key: undefined,\n    index: undefined\n  }\n  if (!__BROWSER__ && context.prefixIdentifiers) {\n    result.source = processExpression(\n      result.source as SimpleExpressionNode,\n      context\n    )\n  }\n\n  let valueContent = LHS.trim()\n    .replace(stripParensRE, '')\n    .trim()\n  const trimmedOffset = LHS.indexOf(valueContent)\n\n  const iteratorMatch = valueContent.match(forIteratorRE)\n  if (iteratorMatch) {\n    valueContent = valueContent.replace(forIteratorRE, '').trim()\n\n    const keyContent = iteratorMatch[1].trim()\n    let keyOffset: number | undefined\n    if (keyContent) {\n      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)\n      result.key = createAliasExpression(loc, keyContent, keyOffset)\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        result.key = processExpression(result.key, context, true)\n      }\n    }\n\n    if (iteratorMatch[2]) {\n      const indexContent = iteratorMatch[2].trim()\n\n      if (indexContent) {\n        result.index = createAliasExpression(\n          loc,\n          indexContent,\n          exp.indexOf(\n            indexContent,\n            result.key\n              ? keyOffset! + keyContent.length\n              : trimmedOffset + valueContent.length\n          )\n        )\n        if (!__BROWSER__ && context.prefixIdentifiers) {\n          result.index = processExpression(result.index, context, true)\n        }\n      }\n    }\n  }\n\n  if (valueContent) {\n    result.value = createAliasExpression(loc, valueContent, trimmedOffset)\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      result.value = processExpression(result.value, context, true)\n    }\n  }\n\n  return result\n}\n\nfunction createAliasExpression(\n  range: SourceLocation,\n  content: string,\n  offset: number\n): SimpleExpressionNode {\n  return createSimpleExpression(\n    content,\n    false,\n    getInnerRange(range, offset, content.length)\n  )\n}\n\nexport function createForLoopParams({\n  value,\n  key,\n  index\n}: ForParseResult): ExpressionNode[] {\n  const params: ExpressionNode[] = []\n  if (value) {\n    params.push(value)\n  }\n  if (key) {\n    if (!value) {\n      params.push(createSimpleExpression(`_`, false))\n    }\n    params.push(key)\n  }\n  if (index) {\n    if (!key) {\n      if (!value) {\n        params.push(createSimpleExpression(`_`, false))\n      }\n      params.push(createSimpleExpression(`__`, false))\n    }\n    params.push(index)\n  }\n  return params\n}\n","import {\n  ElementNode,\n  ObjectExpression,\n  createObjectExpression,\n  NodeTypes,\n  createObjectProperty,\n  createSimpleExpression,\n  createFunctionExpression,\n  DirectiveNode,\n  ElementTypes,\n  ExpressionNode,\n  Property,\n  TemplateChildNode,\n  SourceLocation,\n  createConditionalExpression,\n  ConditionalExpression,\n  JSChildNode,\n  SimpleExpressionNode,\n  FunctionExpression,\n  CallExpression,\n  createCallExpression,\n  createArrayExpression\n} from '../ast'\nimport { TransformContext, NodeTransform } from '../transform'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { findDir, isTemplateNode, assert, isVSlot, hasScopeRef } from '../utils'\nimport { CREATE_SLOTS, RENDER_LIST } from '../runtimeHelpers'\nimport { parseForExpression, createForLoopParams } from './vFor'\n\nconst isStaticExp = (p: JSChildNode): p is SimpleExpressionNode =>\n  p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStatic\n\nconst defaultFallback = createSimpleExpression(`undefined`, false)\n\n// A NodeTransform that:\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\n//    by transformExpression. This is only applied in non-browser builds with\n//    { prefixIdentifiers: true }.\n// 2. Track v-slot depths so that we know a slot is inside another slot.\n//    Note the exit callback is executed before buildSlots() on the same node,\n//    so only nested slots see positive numbers.\nexport const trackSlotScopes: NodeTransform = (node, context) => {\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    (node.tagType === ElementTypes.COMPONENT ||\n      node.tagType === ElementTypes.TEMPLATE)\n  ) {\n    // We are only checking non-empty v-slot here\n    // since we only care about slots that introduce scope variables.\n    const vSlot = findDir(node, 'slot')\n    if (vSlot) {\n      const slotProps = vSlot.exp\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        slotProps && context.addIdentifiers(slotProps)\n      }\n      context.scopes.vSlot++\n      return () => {\n        if (!__BROWSER__ && context.prefixIdentifiers) {\n          slotProps && context.removeIdentifiers(slotProps)\n        }\n        context.scopes.vSlot--\n      }\n    }\n  }\n}\n\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\nexport const trackVForSlotScopes: NodeTransform = (node, context) => {\n  let vFor\n  if (\n    isTemplateNode(node) &&\n    node.props.some(isVSlot) &&\n    (vFor = findDir(node, 'for'))\n  ) {\n    const result = (vFor.parseResult = parseForExpression(\n      vFor.exp as SimpleExpressionNode,\n      context\n    ))\n    if (result) {\n      const { value, key, index } = result\n      const { addIdentifiers, removeIdentifiers } = context\n      value && addIdentifiers(value)\n      key && addIdentifiers(key)\n      index && addIdentifiers(index)\n\n      return () => {\n        value && removeIdentifiers(value)\n        key && removeIdentifiers(key)\n        index && removeIdentifiers(index)\n      }\n    }\n  }\n}\n\n// Instead of being a DirectiveTransform, v-slot processing is called during\n// transformElement to build the slots object for a component.\nexport function buildSlots(\n  node: ElementNode,\n  context: TransformContext\n): {\n  slots: ObjectExpression | CallExpression\n  hasDynamicSlots: boolean\n} {\n  const { children, loc } = node\n  const slotsProperties: Property[] = []\n  const dynamicSlots: (ConditionalExpression | CallExpression)[] = []\n\n  // If the slot is inside a v-for or another v-slot, force it to be dynamic\n  // since it likely uses a scope variable.\n  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0\n  // with `prefixIdentifiers: true`, this can be further optimized to make\n  // it dynamic only when the slot actually uses the scope variables.\n  if (!__BROWSER__ && context.prefixIdentifiers) {\n    hasDynamicSlots = hasScopeRef(node, context.identifiers)\n  }\n\n  // 1. Check for default slot with slotProps on component itself.\n  //    <Comp v-slot=\"{ prop }\"/>\n  const explicitDefaultSlot = findDir(node, 'slot', true)\n  if (explicitDefaultSlot) {\n    const { arg, exp, loc } = explicitDefaultSlot\n    if (arg) {\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_SLOT_NAMED_SLOT_ON_COMPONENT, loc)\n      )\n    }\n    slotsProperties.push(buildDefaultSlot(exp, children, loc))\n  }\n\n  // 2. Iterate through children and check for template slots\n  //    <template v-slot:foo=\"{ prop }\">\n  let hasTemplateSlots = false\n  let extraneousChild: TemplateChildNode | undefined = undefined\n  const seenSlotNames = new Set<string>()\n  for (let i = 0; i < children.length; i++) {\n    const slotElement = children[i]\n    let slotDir\n\n    if (\n      !isTemplateNode(slotElement) ||\n      !(slotDir = findDir(slotElement, 'slot', true))\n    ) {\n      // not a <template v-slot>, skip.\n      if (slotElement.type !== NodeTypes.COMMENT && !extraneousChild) {\n        extraneousChild = slotElement\n      }\n      continue\n    }\n\n    if (explicitDefaultSlot) {\n      // already has on-component default slot - this is incorrect usage.\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE, slotDir.loc)\n      )\n      break\n    }\n\n    hasTemplateSlots = true\n    const { children: slotChildren, loc: slotLoc } = slotElement\n    const {\n      arg: slotName = createSimpleExpression(`default`, true),\n      exp: slotProps,\n      loc: dirLoc\n    } = slotDir\n\n    // check if name is dynamic.\n    let staticSlotName: string | undefined\n    if (isStaticExp(slotName)) {\n      staticSlotName = slotName ? slotName.content : `default`\n    } else {\n      hasDynamicSlots = true\n    }\n\n    const slotFunction = createFunctionExpression(\n      slotProps,\n      slotChildren,\n      false,\n      slotChildren.length ? slotChildren[0].loc : slotLoc\n    )\n\n    // check if this slot is conditional (v-if/v-for)\n    let vIf: DirectiveNode | undefined\n    let vElse: DirectiveNode | undefined\n    let vFor: DirectiveNode | undefined\n    if ((vIf = findDir(slotElement, 'if'))) {\n      hasDynamicSlots = true\n      dynamicSlots.push(\n        createConditionalExpression(\n          vIf.exp!,\n          buildDynamicSlot(slotName, slotFunction),\n          defaultFallback\n        )\n      )\n    } else if (\n      (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))\n    ) {\n      // find adjacent v-if\n      let j = i\n      let prev\n      while (j--) {\n        prev = children[j]\n        if (prev.type !== NodeTypes.COMMENT) {\n          break\n        }\n      }\n      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\n        // remove node\n        children.splice(i, 1)\n        i--\n        __DEV__ && assert(dynamicSlots.length > 0)\n        // attach this slot to previous conditional\n        let conditional = dynamicSlots[\n          dynamicSlots.length - 1\n        ] as ConditionalExpression\n        while (\n          conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\n        ) {\n          conditional = conditional.alternate\n        }\n        conditional.alternate = vElse.exp\n          ? createConditionalExpression(\n              vElse.exp,\n              buildDynamicSlot(slotName, slotFunction),\n              defaultFallback\n            )\n          : buildDynamicSlot(slotName, slotFunction)\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, vElse.loc)\n        )\n      }\n    } else if ((vFor = findDir(slotElement, 'for'))) {\n      hasDynamicSlots = true\n      const parseResult =\n        vFor.parseResult ||\n        parseForExpression(vFor.exp as SimpleExpressionNode, context)\n      if (parseResult) {\n        // Render the dynamic slots as an array and add it to the createSlot()\n        // args. The runtime knows how to handle it appropriately.\n        dynamicSlots.push(\n          createCallExpression(context.helper(RENDER_LIST), [\n            parseResult.source,\n            createFunctionExpression(\n              createForLoopParams(parseResult),\n              buildDynamicSlot(slotName, slotFunction),\n              true\n            )\n          ])\n        )\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, vFor.loc)\n        )\n      }\n    } else {\n      // check duplicate static names\n      if (staticSlotName) {\n        if (seenSlotNames.has(staticSlotName)) {\n          context.onError(\n            createCompilerError(\n              ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES,\n              dirLoc\n            )\n          )\n          continue\n        }\n        seenSlotNames.add(staticSlotName)\n      }\n      slotsProperties.push(createObjectProperty(slotName, slotFunction))\n    }\n  }\n\n  if (hasTemplateSlots && extraneousChild) {\n    context.onError(\n      createCompilerError(\n        ErrorCodes.X_V_SLOT_EXTRANEOUS_NON_SLOT_CHILDREN,\n        extraneousChild.loc\n      )\n    )\n  }\n\n  if (!explicitDefaultSlot && !hasTemplateSlots) {\n    // implicit default slot.\n    slotsProperties.push(buildDefaultSlot(undefined, children, loc))\n  }\n\n  let slots: ObjectExpression | CallExpression = createObjectExpression(\n    slotsProperties.concat(\n      createObjectProperty(`_compiled`, createSimpleExpression(`true`, false))\n    ),\n    loc\n  )\n  if (dynamicSlots.length) {\n    slots = createCallExpression(context.helper(CREATE_SLOTS), [\n      slots,\n      createArrayExpression(dynamicSlots)\n    ])\n  }\n\n  return {\n    slots,\n    hasDynamicSlots\n  }\n}\n\nfunction buildDefaultSlot(\n  slotProps: ExpressionNode | undefined,\n  children: TemplateChildNode[],\n  loc: SourceLocation\n): Property {\n  return createObjectProperty(\n    `default`,\n    createFunctionExpression(\n      slotProps,\n      children,\n      false,\n      children.length ? children[0].loc : loc\n    )\n  )\n}\n\nfunction buildDynamicSlot(\n  name: ExpressionNode,\n  fn: FunctionExpression\n): ObjectExpression {\n  return createObjectExpression([\n    createObjectProperty(`name`, name),\n    createObjectProperty(`fn`, fn)\n  ])\n}\n","import { NodeTransform, TransformContext } from '../transform'\nimport {\n  NodeTypes,\n  ElementTypes,\n  CallExpression,\n  ObjectExpression,\n  ElementNode,\n  DirectiveNode,\n  ExpressionNode,\n  ArrayExpression,\n  createCallExpression,\n  createArrayExpression,\n  createObjectProperty,\n  createSimpleExpression,\n  createObjectExpression,\n  Property\n} from '../ast'\nimport { PatchFlags, PatchFlagNames, isSymbol } from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  CREATE_VNODE,\n  WITH_DIRECTIVES,\n  RESOLVE_DIRECTIVE,\n  RESOLVE_COMPONENT,\n  RESOLVE_DYNAMIC_COMPONENT,\n  MERGE_PROPS,\n  TO_HANDLERS,\n  PORTAL,\n  SUSPENSE\n} from '../runtimeHelpers'\nimport { getInnerRange, isVSlot, toValidAssetId, findProp } from '../utils'\nimport { buildSlots } from './vSlot'\nimport { isStaticNode } from './hoistStatic'\n\n// some directive transforms (e.g. v-model) may return a symbol for runtime\n// import, which should be used instead of a resolveDirective call.\nconst directiveImportMap = new WeakMap<DirectiveNode, symbol>()\n\n// generate a JavaScript AST for this element's codegen\nexport const transformElement: NodeTransform = (node, context) => {\n  if (\n    node.type !== NodeTypes.ELEMENT ||\n    // handled by transformSlotOutlet\n    node.tagType === ElementTypes.SLOT ||\n    // <template v-if/v-for> should have already been replaced\n    // <templte v-slot> is handled by buildSlots\n    (node.tagType === ElementTypes.TEMPLATE && node.props.some(isVSlot))\n  ) {\n    return\n  }\n  // perform the work on exit, after all child expressions have been\n  // processed and merged.\n  return () => {\n    const isComponent = node.tagType === ElementTypes.COMPONENT\n    let hasProps = node.props.length > 0\n    let patchFlag: number = 0\n    let runtimeDirectives: DirectiveNode[] | undefined\n    let dynamicPropNames: string[] | undefined\n    let dynamicComponent: string | CallExpression | undefined\n\n    // handle dynamic component\n    const isProp = findProp(node, 'is')\n    if (node.tag === 'component') {\n      if (isProp) {\n        // static <component is=\"foo\" />\n        if (isProp.type === NodeTypes.ATTRIBUTE) {\n          const tag = isProp.value && isProp.value.content\n          if (tag) {\n            context.helper(RESOLVE_COMPONENT)\n            context.components.add(tag)\n            dynamicComponent = toValidAssetId(tag, `component`)\n          }\n        }\n        // dynamic <component :is=\"asdf\" />\n        else if (isProp.exp) {\n          dynamicComponent = createCallExpression(\n            context.helper(RESOLVE_DYNAMIC_COMPONENT),\n            [isProp.exp]\n          )\n        }\n      }\n    }\n\n    if (isComponent && !dynamicComponent) {\n      context.helper(RESOLVE_COMPONENT)\n      context.components.add(node.tag)\n    }\n\n    const args: CallExpression['arguments'] = [\n      dynamicComponent\n        ? dynamicComponent\n        : isComponent\n          ? toValidAssetId(node.tag, `component`)\n          : node.tagType === ElementTypes.PORTAL\n            ? context.helper(PORTAL)\n            : node.tagType === ElementTypes.SUSPENSE\n              ? context.helper(SUSPENSE)\n              : `\"${node.tag}\"`\n    ]\n    // props\n    if (hasProps) {\n      const propsBuildResult = buildProps(\n        node,\n        context,\n        // skip reserved \"is\" prop <component is>\n        node.props.filter(p => p !== isProp)\n      )\n      patchFlag = propsBuildResult.patchFlag\n      dynamicPropNames = propsBuildResult.dynamicPropNames\n      runtimeDirectives = propsBuildResult.directives\n      if (!propsBuildResult.props) {\n        hasProps = false\n      } else {\n        args.push(propsBuildResult.props)\n      }\n    }\n    // children\n    const hasChildren = node.children.length > 0\n    if (hasChildren) {\n      if (!hasProps) {\n        args.push(`null`)\n      }\n      if (isComponent) {\n        const { slots, hasDynamicSlots } = buildSlots(node, context)\n        args.push(slots)\n        if (hasDynamicSlots) {\n          patchFlag |= PatchFlags.DYNAMIC_SLOTS\n        }\n      } else if (node.children.length === 1) {\n        const child = node.children[0]\n        const type = child.type\n        // check for dynamic text children\n        const hasDynamicTextChild =\n          type === NodeTypes.INTERPOLATION ||\n          type === NodeTypes.COMPOUND_EXPRESSION\n        if (hasDynamicTextChild && !isStaticNode(child)) {\n          patchFlag |= PatchFlags.TEXT\n        }\n        // pass directly if the only child is a text node\n        // (plain / interpolation / expression)\n        if (hasDynamicTextChild || type === NodeTypes.TEXT) {\n          args.push(child)\n        } else {\n          args.push(node.children)\n        }\n      } else {\n        args.push(node.children)\n      }\n    }\n    // patchFlag & dynamicPropNames\n    if (patchFlag !== 0) {\n      if (!hasChildren) {\n        if (!hasProps) {\n          args.push(`null`)\n        }\n        args.push(`null`)\n      }\n      if (__DEV__) {\n        const flagNames = Object.keys(PatchFlagNames)\n          .map(Number)\n          .filter(n => n > 0 && patchFlag & n)\n          .map(n => PatchFlagNames[n])\n          .join(`, `)\n        args.push(patchFlag + ` /* ${flagNames} */`)\n      } else {\n        args.push(patchFlag + '')\n      }\n      if (dynamicPropNames && dynamicPropNames.length) {\n        args.push(\n          `[${dynamicPropNames.map(n => JSON.stringify(n)).join(`, `)}]`\n        )\n      }\n    }\n\n    const { loc } = node\n    const vnode = createCallExpression(context.helper(CREATE_VNODE), args, loc)\n\n    if (runtimeDirectives && runtimeDirectives.length) {\n      node.codegenNode = createCallExpression(\n        context.helper(WITH_DIRECTIVES),\n        [\n          vnode,\n          createArrayExpression(\n            runtimeDirectives.map(dir => buildDirectiveArgs(dir, context)),\n            loc\n          )\n        ],\n        loc\n      )\n    } else {\n      node.codegenNode = vnode\n    }\n  }\n}\n\nexport type PropsExpression = ObjectExpression | CallExpression | ExpressionNode\n\nexport function buildProps(\n  node: ElementNode,\n  context: TransformContext,\n  props: ElementNode['props'] = node.props\n): {\n  props: PropsExpression | undefined\n  directives: DirectiveNode[]\n  patchFlag: number\n  dynamicPropNames: string[]\n} {\n  const elementLoc = node.loc\n  const isComponent = node.tagType === ElementTypes.COMPONENT\n  let properties: ObjectExpression['properties'] = []\n  const mergeArgs: PropsExpression[] = []\n  const runtimeDirectives: DirectiveNode[] = []\n\n  // patchFlag analysis\n  let patchFlag = 0\n  let hasRef = false\n  let hasClassBinding = false\n  let hasStyleBinding = false\n  let hasDynamicKeys = false\n  const dynamicPropNames: string[] = []\n\n  const analyzePatchFlag = ({ key, value }: Property) => {\n    if (key.type === NodeTypes.SIMPLE_EXPRESSION && key.isStatic) {\n      if (\n        value.type === NodeTypes.JS_CACHE_EXPRESSION ||\n        ((value.type === NodeTypes.SIMPLE_EXPRESSION ||\n          value.type === NodeTypes.COMPOUND_EXPRESSION) &&\n          isStaticNode(value))\n      ) {\n        return\n      }\n      const name = key.content\n      if (name === 'ref') {\n        hasRef = true\n      } else if (name === 'class') {\n        hasClassBinding = true\n      } else if (name === 'style') {\n        hasStyleBinding = true\n      } else if (name !== 'key') {\n        dynamicPropNames.push(name)\n      }\n    } else {\n      hasDynamicKeys = true\n    }\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    // static attribute\n    const prop = props[i]\n    if (prop.type === NodeTypes.ATTRIBUTE) {\n      const { loc, name, value } = prop\n      if (name === 'ref') {\n        hasRef = true\n      }\n      properties.push(\n        createObjectProperty(\n          createSimpleExpression(\n            name,\n            true,\n            getInnerRange(loc, 0, name.length)\n          ),\n          createSimpleExpression(\n            value ? value.content : '',\n            true,\n            value ? value.loc : loc\n          )\n        )\n      )\n    } else {\n      // directives\n      const { name, arg, exp, loc } = prop\n\n      // skip v-slot - it is handled by its dedicated transform.\n      if (name === 'slot') {\n        if (!isComponent) {\n          context.onError(\n            createCompilerError(ErrorCodes.X_V_SLOT_MISPLACED, loc)\n          )\n        }\n        continue\n      }\n\n      // special case for v-bind and v-on with no argument\n      const isBind = name === 'bind'\n      const isOn = name === 'on'\n      if (!arg && (isBind || isOn)) {\n        hasDynamicKeys = true\n        if (exp) {\n          if (properties.length) {\n            mergeArgs.push(\n              createObjectExpression(dedupeProperties(properties), elementLoc)\n            )\n            properties = []\n          }\n          if (isBind) {\n            mergeArgs.push(exp)\n          } else {\n            // v-on=\"obj\" -> toHandlers(obj)\n            mergeArgs.push({\n              type: NodeTypes.JS_CALL_EXPRESSION,\n              loc,\n              callee: context.helper(TO_HANDLERS),\n              arguments: [exp]\n            })\n          }\n        } else {\n          context.onError(\n            createCompilerError(\n              isBind\n                ? ErrorCodes.X_V_BIND_NO_EXPRESSION\n                : ErrorCodes.X_V_ON_NO_EXPRESSION,\n              loc\n            )\n          )\n        }\n        continue\n      }\n\n      const directiveTransform = context.directiveTransforms[name]\n      if (directiveTransform) {\n        // has built-in directive transform.\n        const { props, needRuntime } = directiveTransform(prop, node, context)\n        props.forEach(analyzePatchFlag)\n        properties.push(...props)\n        if (needRuntime) {\n          runtimeDirectives.push(prop)\n          if (isSymbol(needRuntime)) {\n            directiveImportMap.set(prop, needRuntime)\n          }\n        }\n      } else {\n        // no built-in transform, this is a user custom directive.\n        runtimeDirectives.push(prop)\n      }\n    }\n  }\n\n  let propsExpression: PropsExpression | undefined = undefined\n\n  // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\n  if (mergeArgs.length) {\n    if (properties.length) {\n      mergeArgs.push(\n        createObjectExpression(dedupeProperties(properties), elementLoc)\n      )\n    }\n    if (mergeArgs.length > 1) {\n      propsExpression = createCallExpression(\n        context.helper(MERGE_PROPS),\n        mergeArgs,\n        elementLoc\n      )\n    } else {\n      // single v-bind with nothing else - no need for a mergeProps call\n      propsExpression = mergeArgs[0]\n    }\n  } else if (properties.length) {\n    propsExpression = createObjectExpression(\n      dedupeProperties(properties),\n      elementLoc\n    )\n  }\n\n  // patchFlag analysis\n  if (hasDynamicKeys) {\n    patchFlag |= PatchFlags.FULL_PROPS\n  } else {\n    if (hasClassBinding) {\n      patchFlag |= PatchFlags.CLASS\n    }\n    if (hasStyleBinding) {\n      patchFlag |= PatchFlags.STYLE\n    }\n    if (dynamicPropNames.length) {\n      patchFlag |= PatchFlags.PROPS\n    }\n  }\n  if (patchFlag === 0 && (hasRef || runtimeDirectives.length > 0)) {\n    patchFlag |= PatchFlags.NEED_PATCH\n  }\n\n  return {\n    props: propsExpression,\n    directives: runtimeDirectives,\n    patchFlag,\n    dynamicPropNames\n  }\n}\n\n// Dedupe props in an object literal.\n// Literal duplicated attributes would have been warned during the parse phase,\n// however, it's possible to encounter duplicated `onXXX` handlers with different\n// modifiers. We also need to merge static and dynamic class / style attributes.\n// - onXXX handlers / style: merge into array\n// - class: merge into single expression with concatenation\nfunction dedupeProperties(properties: Property[]): Property[] {\n  const knownProps: Record<string, Property> = {}\n  const deduped: Property[] = []\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i]\n    // dynamic keys are always allowed\n    if (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {\n      deduped.push(prop)\n      continue\n    }\n    const name = prop.key.content\n    const existing = knownProps[name]\n    if (existing) {\n      if (\n        name === 'style' ||\n        name === 'class' ||\n        name.startsWith('on') ||\n        name.startsWith('vnode')\n      ) {\n        mergeAsArray(existing, prop)\n      }\n      // unexpected duplicate, should have emitted error during parse\n    } else {\n      knownProps[name] = prop\n      deduped.push(prop)\n    }\n  }\n  return deduped\n}\n\nfunction mergeAsArray(existing: Property, incoming: Property) {\n  if (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {\n    existing.value.elements.push(incoming.value)\n  } else {\n    existing.value = createArrayExpression(\n      [existing.value, incoming.value],\n      existing.loc\n    )\n  }\n}\n\nfunction buildDirectiveArgs(\n  dir: DirectiveNode,\n  context: TransformContext\n): ArrayExpression {\n  const dirArgs: ArrayExpression['elements'] = []\n  const runtime = directiveImportMap.get(dir)\n  if (runtime) {\n    context.helper(runtime)\n    dirArgs.push(context.helperString(runtime))\n  } else {\n    // inject statement for resolving directive\n    context.helper(RESOLVE_DIRECTIVE)\n    context.directives.add(dir.name)\n    dirArgs.push(toValidAssetId(dir.name, `directive`))\n  }\n  const { loc } = dir\n  if (dir.exp) dirArgs.push(dir.exp)\n  if (dir.arg) {\n    if (!dir.exp) {\n      dirArgs.push(`void 0`)\n    }\n    dirArgs.push(dir.arg)\n  }\n  if (Object.keys(dir.modifiers).length) {\n    if (!dir.arg) {\n      if (!dir.exp) {\n        dirArgs.push(`void 0`)\n      }\n      dirArgs.push(`void 0`)\n    }\n    dirArgs.push(\n      createObjectExpression(\n        dir.modifiers.map(modifier =>\n          createObjectProperty(\n            modifier,\n            createSimpleExpression(`true`, false, loc)\n          )\n        ),\n        loc\n      )\n    )\n  }\n  return createArrayExpression(dirArgs, dir.loc)\n}\n","import { NodeTransform } from '../transform'\nimport {\n  NodeTypes,\n  CallExpression,\n  createCallExpression,\n  ExpressionNode\n} from '../ast'\nimport { isSlotOutlet } from '../utils'\nimport { buildProps } from './transformElement'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { RENDER_SLOT } from '../runtimeHelpers'\n\nexport const transformSlotOutlet: NodeTransform = (node, context) => {\n  if (isSlotOutlet(node)) {\n    const { props, children, loc } = node\n    const $slots = context.prefixIdentifiers ? `_ctx.$slots` : `$slots`\n    let slotName: string | ExpressionNode = `\"default\"`\n\n    // check for <slot name=\"xxx\" OR :name=\"xxx\" />\n    let nameIndex: number = -1\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i]\n      if (prop.type === NodeTypes.ATTRIBUTE) {\n        if (prop.name === `name` && prop.value) {\n          // static name=\"xxx\"\n          slotName = JSON.stringify(prop.value.content)\n          nameIndex = i\n          break\n        }\n      } else if (prop.name === `bind`) {\n        const { arg, exp } = prop\n        if (\n          arg &&\n          exp &&\n          arg.type === NodeTypes.SIMPLE_EXPRESSION &&\n          arg.isStatic &&\n          arg.content === `name`\n        ) {\n          // dynamic :name=\"xxx\"\n          slotName = exp\n          nameIndex = i\n          break\n        }\n      }\n    }\n\n    const slotArgs: CallExpression['arguments'] = [$slots, slotName]\n    const propsWithoutName =\n      nameIndex > -1\n        ? props.slice(0, nameIndex).concat(props.slice(nameIndex + 1))\n        : props\n    let hasProps = propsWithoutName.length > 0\n    if (hasProps) {\n      const { props: propsExpression, directives } = buildProps(\n        node,\n        context,\n        propsWithoutName\n      )\n      if (directives.length) {\n        context.onError(\n          createCompilerError(\n            ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\n            directives[0].loc\n          )\n        )\n      }\n      if (propsExpression) {\n        slotArgs.push(propsExpression)\n      } else {\n        hasProps = false\n      }\n    }\n\n    if (children.length) {\n      if (!hasProps) {\n        slotArgs.push(`{}`)\n      }\n      slotArgs.push(children)\n    }\n\n    node.codegenNode = createCallExpression(\n      context.helper(RENDER_SLOT),\n      slotArgs,\n      loc\n    )\n  }\n}\n","import { DirectiveTransform, DirectiveTransformResult } from '../transform'\nimport {\n  DirectiveNode,\n  createObjectProperty,\n  createSimpleExpression,\n  ExpressionNode,\n  NodeTypes,\n  createCompoundExpression,\n  SimpleExpressionNode\n} from '../ast'\nimport { capitalize } from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { processExpression } from './transformExpression'\nimport { isMemberExpression, hasScopeRef } from '../utils'\n\nconst fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/\n\nexport interface VOnDirectiveNode extends DirectiveNode {\n  // v-on without arg is handled directly in ./element.ts due to it affecting\n  // codegen for the entire props object. This transform here is only for v-on\n  // *with* args.\n  arg: ExpressionNode\n  // exp is guaranteed to be a simple expression here because v-on w/ arg is\n  // skipped by transformExpression as a special case.\n  exp: SimpleExpressionNode | undefined\n}\n\nexport const transformOn: DirectiveTransform = (\n  dir: VOnDirectiveNode,\n  node,\n  context,\n  augmentor\n) => {\n  const { loc, modifiers, arg } = dir\n  if (!dir.exp && !modifiers.length) {\n    context.onError(createCompilerError(ErrorCodes.X_V_ON_NO_EXPRESSION, loc))\n  }\n  let eventName: ExpressionNode\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n    if (arg.isStatic) {\n      eventName = createSimpleExpression(\n        `on${capitalize(arg.content)}`,\n        true,\n        arg.loc\n      )\n    } else {\n      eventName = createCompoundExpression([`\"on\" + (`, arg, `)`])\n    }\n  } else {\n    // already a compound expression.\n    eventName = arg\n    eventName.children.unshift(`\"on\" + (`)\n    eventName.children.push(`)`)\n  }\n\n  // handler processing\n  let exp: ExpressionNode | undefined = dir.exp\n  let isCacheable: boolean = !exp\n  if (exp) {\n    const isMemberExp = isMemberExpression(exp.content)\n    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))\n\n    // process the expression since it's been skipped\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      context.addIdentifiers(`$event`)\n      exp = processExpression(exp, context)\n      context.removeIdentifiers(`$event`)\n      // with scope analysis, the function is hoistable if it has no reference\n      // to scope variables.\n      isCacheable =\n        context.cacheHandlers && !hasScopeRef(exp, context.identifiers)\n      // If the expression is optimizable and is a member expression pointing\n      // to a function, turn it into invocation (and wrap in an arrow function\n      // below) so that it always accesses the latest value when called - thus\n      // avoiding the need to be patched.\n      if (isCacheable && isMemberExp) {\n        if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          exp.content += `($event)`\n        } else {\n          exp.children.push(`($event)`)\n        }\n      }\n    }\n\n    if (isInlineStatement || (isCacheable && isMemberExp)) {\n      // wrap inline statement in a function expression\n      exp = createCompoundExpression([\n        `$event => (`,\n        ...(exp.type === NodeTypes.SIMPLE_EXPRESSION ? [exp] : exp.children),\n        `)`\n      ])\n    }\n  }\n\n  let ret: DirectiveTransformResult = {\n    props: [\n      createObjectProperty(\n        eventName,\n        exp || createSimpleExpression(`() => {}`, false, loc)\n      )\n    ],\n    needRuntime: false\n  }\n\n  // apply extended compiler augmentor\n  if (augmentor) {\n    ret = augmentor(ret)\n  }\n\n  if (isCacheable) {\n    // cache handlers so that it's always the same handler being passed down.\n    // this avoids unnecessary re-renders when users use inline hanlders on\n    // components.\n    ret.props[0].value = context.cache(ret.props[0].value)\n  }\n\n  return ret\n}\n","import { DirectiveTransform } from '../transform'\nimport { createObjectProperty, createSimpleExpression, NodeTypes } from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { camelize } from '@vue/shared'\nimport { CAMELIZE } from '../runtimeHelpers'\n\n// v-bind without arg is handled directly in ./element.ts due to it affecting\n// codegen for the entire props object. This transform here is only for v-bind\n// *with* args.\nexport const transformBind: DirectiveTransform = (dir, node, context) => {\n  const { exp, modifiers, loc } = dir\n  const arg = dir.arg!\n  if (!exp) {\n    context.onError(createCompilerError(ErrorCodes.X_V_BIND_NO_EXPRESSION, loc))\n  }\n  // .prop is no longer necessary due to new patch behavior\n  // .sync is replaced by v-model:arg\n  if (modifiers.includes('camel')) {\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n      if (arg.isStatic) {\n        arg.content = camelize(arg.content)\n      } else {\n        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`\n      }\n    } else {\n      arg.children.unshift(`${context.helperString(CAMELIZE)}(`)\n      arg.children.push(`)`)\n    }\n  }\n  return {\n    props: [\n      createObjectProperty(arg!, exp || createSimpleExpression('', true, loc))\n    ],\n    needRuntime: false\n  }\n}\n","import { NodeTransform } from '../transform'\nimport {\n  NodeTypes,\n  TemplateChildNode,\n  TextNode,\n  InterpolationNode,\n  CompoundExpressionNode,\n  createCallExpression\n} from '../ast'\nimport { TEXT, CREATE_VNODE } from '../runtimeHelpers'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\n\nconst isText = (\n  node: TemplateChildNode\n): node is TextNode | InterpolationNode =>\n  node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT\n\n// Merge adjacent text nodes and expressions into a single expression\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\nexport const transformText: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.ROOT || node.type === NodeTypes.ELEMENT) {\n    // perform the transform on node exit so that all expressions have already\n    // been processed.\n    return () => {\n      const children = node.children\n      let currentContainer: CompoundExpressionNode | undefined = undefined\n      let hasText = false\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n        if (isText(child)) {\n          hasText = true\n          for (let j = i + 1; j < children.length; j++) {\n            const next = children[j]\n            if (isText(next)) {\n              if (!currentContainer) {\n                currentContainer = children[i] = {\n                  type: NodeTypes.COMPOUND_EXPRESSION,\n                  loc: child.loc,\n                  children: [child]\n                }\n              }\n              // merge adjacent text node into current\n              currentContainer.children.push(` + `, next)\n              children.splice(j, 1)\n              j--\n            } else {\n              currentContainer = undefined\n              break\n            }\n          }\n        }\n      }\n\n      if (hasText && children.length > 1) {\n        // when an element has mixed text/element children, convert text nodes\n        // into createVNode(Text) calls.\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i]\n          if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {\n            const callArgs = [context.helper(TEXT), `null`, child]\n            if (child.type !== NodeTypes.TEXT) {\n              callArgs.push(\n                `${PatchFlags.TEXT} /* ${PatchFlagNames[PatchFlags.TEXT]} */`\n              )\n            }\n            children[i] = {\n              type: NodeTypes.TEXT_CALL,\n              content: child,\n              loc: child.loc,\n              codegenNode: createCallExpression(\n                context.helper(CREATE_VNODE),\n                callArgs\n              )\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import {\n  DirectiveTransform,\n  createObjectProperty,\n  createSimpleExpression\n} from '@vue/compiler-core'\n\nexport const transformOnce: DirectiveTransform = dir => {\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`$once`, true, dir.loc),\n        createSimpleExpression('true', false)\n      )\n    ],\n    needRuntime: false\n  }\n}\n","import { DirectiveTransform } from '../transform'\nimport {\n  createSimpleExpression,\n  createObjectProperty,\n  createCompoundExpression,\n  NodeTypes,\n  Property,\n  ElementTypes\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { isMemberExpression, isSimpleIdentifier, hasScopeRef } from '../utils'\n\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\n  const { exp, arg } = dir\n  if (!exp) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_NO_EXPRESSION, dir.loc)\n    )\n    return createTransformProps()\n  }\n\n  const expString =\n    exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : exp.loc.source\n  if (!isMemberExpression(expString)) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION, exp.loc)\n    )\n    return createTransformProps()\n  }\n\n  if (\n    !__BROWSER__ &&\n    context.prefixIdentifiers &&\n    isSimpleIdentifier(expString) &&\n    context.identifiers[expString]\n  ) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE, exp.loc)\n    )\n    return createTransformProps()\n  }\n\n  const propName = arg ? arg : createSimpleExpression('modelValue', true)\n  const eventName = arg\n    ? arg.type === NodeTypes.SIMPLE_EXPRESSION && arg.isStatic\n      ? createSimpleExpression('onUpdate:' + arg.content, true)\n      : createCompoundExpression([\n          createSimpleExpression('onUpdate:', true),\n          '+',\n          ...(arg.type === NodeTypes.SIMPLE_EXPRESSION ? [arg] : arg.children)\n        ])\n    : createSimpleExpression('onUpdate:modelValue', true)\n\n  const props = [\n    // modelValue: foo\n    createObjectProperty(propName, dir.exp!),\n    // \"onUpdate:modelValue\": $event => (foo = $event)\n    createObjectProperty(\n      eventName,\n      createCompoundExpression([\n        `$event => (`,\n        ...(exp.type === NodeTypes.SIMPLE_EXPRESSION ? [exp] : exp.children),\n        ` = $event)`\n      ])\n    )\n  ]\n\n  // cache v-model handler if applicable (when it doesn't refer any scope vars)\n  if (\n    !__BROWSER__ &&\n    context.prefixIdentifiers &&\n    !hasScopeRef(exp, context.identifiers)\n  ) {\n    props[1].value = context.cache(props[1].value)\n  }\n\n  // modelModifiers: { foo: true, \"bar-baz\": true }\n  if (dir.modifiers.length && node.tagType === ElementTypes.COMPONENT) {\n    const modifiers = dir.modifiers\n      .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\n      .join(`, `)\n    props.push(\n      createObjectProperty(\n        `modelModifiers`,\n        createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, true)\n      )\n    )\n  }\n\n  return createTransformProps(props)\n}\n\nfunction createTransformProps(props: Property[] = []) {\n  return { props, needRuntime: false }\n}\n","const range: number = 2\n\nexport function generateCodeFrame(\n  source: string,\n  start: number = 0,\n  end: number = source.length\n): string {\n  const lines = source.split(/\\r?\\n/)\n  let count = 0\n  const res = []\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue\n        res.push(\n          `${j + 1}${' '.repeat(3 - String(j + 1).length)}|  ${lines[j]}`\n        )\n        const lineLength = lines[j].length\n        if (j === i) {\n          // push underline\n          const pad = start - (count - lineLength) + 1\n          const length = end > count ? lineLength - pad : end - start\n          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length))\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.min(end - count, lineLength)\n            res.push(`   |  ` + '^'.repeat(length))\n          }\n          count += lineLength + 1\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n","import { parse, ParserOptions } from './parse'\nimport { transform, TransformOptions } from './transform'\nimport { generate, CodegenOptions, CodegenResult } from './codegen'\nimport { RootNode } from './ast'\nimport { isString } from '@vue/shared'\nimport { transformIf } from './transforms/vIf'\nimport { transformFor } from './transforms/vFor'\nimport { transformExpression } from './transforms/transformExpression'\nimport { transformSlotOutlet } from './transforms/transformSlotOutlet'\nimport { transformElement } from './transforms/transformElement'\nimport { transformOn } from './transforms/vOn'\nimport { transformBind } from './transforms/vBind'\nimport { defaultOnError, createCompilerError, ErrorCodes } from './errors'\nimport { trackSlotScopes, trackVForSlotScopes } from './transforms/vSlot'\nimport { transformText } from './transforms/transformText'\nimport { transformOnce } from './transforms/vOnce'\nimport { transformModel } from './transforms/vModel'\n\nexport type CompilerOptions = ParserOptions & TransformOptions & CodegenOptions\n\n// we name it `baseCompile` so that higher order compilers like @vue/compiler-dom\n// can export `compile` while re-exporting everything else.\nexport function baseCompile(\n  template: string | RootNode,\n  options: CompilerOptions = {}\n): CodegenResult {\n  /* istanbul ignore if */\n  if (__BROWSER__) {\n    const onError = options.onError || defaultOnError\n    if (options.prefixIdentifiers === true) {\n      onError(createCompilerError(ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED))\n    } else if (options.mode === 'module') {\n      onError(createCompilerError(ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED))\n    }\n  }\n\n  const ast = isString(template) ? parse(template, options) : template\n\n  const prefixIdentifiers =\n    !__BROWSER__ &&\n    (options.prefixIdentifiers === true || options.mode === 'module')\n\n  transform(ast, {\n    ...options,\n    prefixIdentifiers,\n    nodeTransforms: [\n      transformIf,\n      transformFor,\n      ...(prefixIdentifiers\n        ? [\n            // order is important\n            trackVForSlotScopes,\n            transformExpression\n          ]\n        : []),\n      transformSlotOutlet,\n      transformElement,\n      trackSlotScopes,\n      transformText,\n      ...(options.nodeTransforms || []) // user transforms\n    ],\n    directiveTransforms: {\n      on: transformOn,\n      bind: transformBind,\n      once: transformOnce,\n      model: transformModel,\n      ...(options.directiveTransforms || {}) // user transforms\n    }\n  })\n\n  return generate(ast, {\n    ...options,\n    prefixIdentifiers\n  })\n}\n\n// Also expose lower level APIs & types\nexport { parse, ParserOptions, TextModes } from './parse'\nexport {\n  transform,\n  createStructuralDirectiveTransform,\n  TransformOptions,\n  TransformContext,\n  NodeTransform,\n  StructuralDirectiveTransform,\n  DirectiveTransform\n} from './transform'\nexport {\n  generate,\n  CodegenOptions,\n  CodegenContext,\n  CodegenResult\n} from './codegen'\nexport {\n  ErrorCodes,\n  CoreCompilerError,\n  CompilerError,\n  createCompilerError\n} from './errors'\nexport * from './ast'\nexport * from './utils'\nexport * from './codeframe'\nexport { registerRuntimeHelpers } from './runtimeHelpers'\n\n// expose transforms so higher-order compilers can import and extend them\nexport { transformModel } from './transforms/vModel'\nexport { transformOn } from './transforms/vOn'\n","import { makeMap } from '../../shared/src/makeMap'\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS =\n  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n  'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +\n  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n  'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +\n  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n  'option,output,progress,select,textarea,details,dialog,menu,menuitem,' +\n  'summary,content,element,shadow,template,blockquote,iframe,tfoot'\n\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS =\n  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n  'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n  'foreignObject,g,hatch,hatchpath,image,line,lineGradient,marker,mask,' +\n  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n  'text,textPath,title,tspan,unknown,use,view'\n\nconst VOID_TAGS =\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\n\nexport const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)\nexport const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)\nexport const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)\n","import {\n  TextModes,\n  ParserOptions,\n  ElementNode,\n  Namespaces,\n  NodeTypes\n} from '@vue/compiler-core'\nimport { isVoidTag, isHTMLTag, isSVGTag } from './tagConfig'\n\nexport const enum DOMNamespaces {\n  HTML = Namespaces.HTML,\n  SVG,\n  MATH_ML\n}\n\nexport const parserOptionsMinimal: ParserOptions = {\n  isVoidTag,\n\n  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),\n\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace(tag: string, parent: ElementNode | undefined): DOMNamespaces {\n    let ns = parent ? parent.ns : DOMNamespaces.HTML\n\n    if (parent && ns === DOMNamespaces.MATH_ML) {\n      if (parent.tag === 'annotation-xml') {\n        if (tag === 'svg') {\n          return DOMNamespaces.SVG\n        }\n        if (\n          parent.props.some(\n            a =>\n              a.type === NodeTypes.ATTRIBUTE &&\n              a.name === 'encoding' &&\n              a.value != null &&\n              (a.value.content === 'text/html' ||\n                a.value.content === 'application/xhtml+xml')\n          )\n        ) {\n          ns = DOMNamespaces.HTML\n        }\n      } else if (\n        /^m(?:[ions]|text)$/.test(parent.tag) &&\n        tag !== 'mglyph' &&\n        tag !== 'malignmark'\n      ) {\n        ns = DOMNamespaces.HTML\n      }\n    } else if (parent && ns === DOMNamespaces.SVG) {\n      if (\n        parent.tag === 'foreignObject' ||\n        parent.tag === 'desc' ||\n        parent.tag === 'title'\n      ) {\n        ns = DOMNamespaces.HTML\n      }\n    }\n\n    if (ns === DOMNamespaces.HTML) {\n      if (tag === 'svg') {\n        return DOMNamespaces.SVG\n      }\n      if (tag === 'math') {\n        return DOMNamespaces.MATH_ML\n      }\n    }\n    return ns\n  },\n\n  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\n  getTextMode(tag: string, ns: DOMNamespaces): TextModes {\n    if (ns === DOMNamespaces.HTML) {\n      if (tag === 'textarea' || tag === 'title') {\n        return TextModes.RCDATA\n      }\n      if (\n        /^(?:style|xmp|iframe|noembed|noframes|script|noscript)$/i.test(tag)\n      ) {\n        return TextModes.RAWTEXT\n      }\n    }\n    return TextModes.DATA\n  }\n}\n","import {\n  NodeTransform,\n  NodeTypes,\n  createSimpleExpression\n} from '@vue/compiler-core'\n\n// Parse inline CSS strings for static style attributes into an object.\n// This is a NodeTransform since it works on the static `style` attribute and\n// converts it into a dynamic equivalent:\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\n// It is then processed by `transformElement` and included in the generated\n// props.\nexport const transformStyle: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.ELEMENT) {\n    node.props.forEach((p, i) => {\n      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {\n        // replace p with an expression node\n        const parsed = JSON.stringify(parseInlineCSS(p.value.content))\n        const exp = context.hoist(createSimpleExpression(parsed, false, p.loc))\n        node.props[i] = {\n          type: NodeTypes.DIRECTIVE,\n          name: `bind`,\n          arg: createSimpleExpression(`style`, true, p.loc),\n          exp,\n          modifiers: [],\n          loc: p.loc\n        }\n      }\n    })\n  }\n}\n\nconst listDelimiterRE = /;(?![^(]*\\))/g\nconst propertyDelimiterRE = /:(.+)/\n\nfunction parseInlineCSS(cssText: string): Record<string, string> {\n  const res: Record<string, string> = {}\n  cssText.split(listDelimiterRE).forEach(function(item) {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE)\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim())\n    }\n  })\n  return res\n}\n","import { DirectiveTransform } from 'packages/compiler-core/src/transform'\n\nexport const transformCloak: DirectiveTransform = (node, context) => {\n  return { props: [], needRuntime: false }\n}\n","import {\n  SourceLocation,\n  CompilerError,\n  createCompilerError,\n  ErrorCodes\n} from '@vue/compiler-core'\n\nexport interface DOMCompilerError extends CompilerError {\n  code: DOMErrorCodes\n}\n\nexport function createDOMCompilerError(\n  code: DOMErrorCodes,\n  loc?: SourceLocation\n): DOMCompilerError {\n  return createCompilerError(\n    code,\n    loc,\n    __DEV__ || !__BROWSER__ ? DOMErrorMessages : undefined\n  )\n}\n\nexport const enum DOMErrorCodes {\n  X_V_HTML_NO_EXPRESSION = ErrorCodes.__EXTEND_POINT__,\n  X_V_HTML_WITH_CHILDREN,\n  X_V_TEXT_NO_EXPRESSION,\n  X_V_TEXT_WITH_CHILDREN,\n  X_V_MODEL_ON_INVALID_ELEMENT,\n  X_V_MODEL_ARG_ON_ELEMENT,\n  X_V_MODEL_ON_FILE_INPUT_ELEMENT\n}\n\nexport const DOMErrorMessages: { [code: number]: string } = {\n  [DOMErrorCodes.X_V_HTML_NO_EXPRESSION]: `v-html is missing expression.`,\n  [DOMErrorCodes.X_V_HTML_WITH_CHILDREN]: `v-html will override element children.`,\n  [DOMErrorCodes.X_V_TEXT_NO_EXPRESSION]: `v-text is missing expression.`,\n  [DOMErrorCodes.X_V_TEXT_WITH_CHILDREN]: `v-text will override element children.`,\n  [DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\n  [DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT]: `v-model argument is not supported on plain elements.`,\n  [DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT]: `v-model cannot used on file inputs since they are read-only. Use a v-on:change listener instead.`\n}\n","import {\n  DirectiveTransform,\n  createObjectProperty,\n  createSimpleExpression\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\n\nexport const transformVHtml: DirectiveTransform = (dir, node, context) => {\n  const { exp, loc } = dir\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_NO_EXPRESSION, loc)\n    )\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_WITH_CHILDREN, loc)\n    )\n    node.children.length = 0\n  }\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`innerHTML`, true, loc),\n        exp || createSimpleExpression('', true)\n      )\n    ],\n    needRuntime: false\n  }\n}\n","import {\n  DirectiveTransform,\n  createObjectProperty,\n  createSimpleExpression\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\n\nexport const transformVText: DirectiveTransform = (dir, node, context) => {\n  const { exp, loc } = dir\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_NO_EXPRESSION, loc)\n    )\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_WITH_CHILDREN, loc)\n    )\n    node.children.length = 0\n  }\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`textContent`, true, loc),\n        exp || createSimpleExpression('', true)\n      )\n    ],\n    needRuntime: false\n  }\n}\n","import { registerRuntimeHelpers } from '@vue/compiler-core'\n\nexport const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)\nexport const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)\nexport const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)\nexport const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)\nexport const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)\n\nexport const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)\nexport const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)\n\nregisterRuntimeHelpers({\n  [V_MODEL_RADIO]: `vModelRadio`,\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\n  [V_MODEL_TEXT]: `vModelText`,\n  [V_MODEL_SELECT]: `vModelSelect`,\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\n  [V_ON_WITH_KEYS]: `withKeys`\n})\n","import {\n  transformModel as baseTransform,\n  DirectiveTransform,\n  ElementTypes,\n  findProp,\n  NodeTypes\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\nimport {\n  V_MODEL_CHECKBOX,\n  V_MODEL_RADIO,\n  V_MODEL_SELECT,\n  V_MODEL_TEXT,\n  V_MODEL_DYNAMIC\n} from '../runtimeHelpers'\n\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\n  const baseResult = baseTransform(dir, node, context)\n  // base transform has errors\n  if (!baseResult.props.length) {\n    return baseResult\n  }\n\n  const { tag, tagType } = node\n  if (tagType === ElementTypes.ELEMENT) {\n    if (dir.arg) {\n      context.onError(\n        createDOMCompilerError(\n          DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT,\n          dir.arg.loc\n        )\n      )\n    }\n\n    if (tag === 'input' || tag === 'textarea' || tag === 'select') {\n      let directiveToUse = V_MODEL_TEXT\n      let isInvalidType = false\n      if (tag === 'input') {\n        const type = findProp(node, `type`)\n        if (type) {\n          if (type.type === NodeTypes.DIRECTIVE) {\n            // :type=\"foo\"\n            directiveToUse = V_MODEL_DYNAMIC\n          } else if (type.value) {\n            switch (type.value.content) {\n              case 'radio':\n                directiveToUse = V_MODEL_RADIO\n                break\n              case 'checkbox':\n                directiveToUse = V_MODEL_CHECKBOX\n                break\n              case 'file':\n                isInvalidType = true\n                context.onError(\n                  createDOMCompilerError(\n                    DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT,\n                    dir.loc\n                  )\n                )\n                break\n            }\n          }\n        }\n      } else if (tag === 'select') {\n        directiveToUse = V_MODEL_SELECT\n      }\n      // inject runtime directive\n      // by returning the helper symbol via needRuntime\n      // the import will replaced a resolveDirective call.\n      if (!isInvalidType) {\n        baseResult.needRuntime = context.helper(directiveToUse)\n      }\n    } else {\n      context.onError(\n        createDOMCompilerError(\n          DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT,\n          dir.loc\n        )\n      )\n    }\n  }\n  return baseResult\n}\n","import {\n  transformOn as baseTransform,\n  DirectiveTransform,\n  createObjectProperty,\n  createCallExpression,\n  createObjectExpression,\n  createSimpleExpression,\n  NodeTypes\n} from '@vue/compiler-core'\nimport { V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS } from '../runtimeHelpers'\nimport { makeMap } from '@vue/shared'\n\nconst isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)\nconst isNonKeyModifier = /*#__PURE__*/ makeMap(\n  // event propagation management\n  `stop,prevent,self,` +\n    // system modifiers + exact\n    `ctrl,shift,alt,meta,exact,` +\n    // mouse\n    `left,middle,right`\n)\nconst isKeyboardEvent = /*#__PURE__*/ makeMap(\n  `onkeyup,onkeydown,onkeypress`,\n  true\n)\n\nexport const transformOn: DirectiveTransform = (dir, node, context) => {\n  return baseTransform(dir, node, context, baseResult => {\n    const { modifiers } = dir\n    if (!modifiers.length) return baseResult\n\n    let { key, value: handlerExp } = baseResult.props[0]\n\n    // modifiers for addEventListener() options, e.g. .passive & .capture\n    const eventOptionModifiers = modifiers.filter(isEventOptionModifier)\n    // modifiers that needs runtime guards\n    const runtimeModifiers = modifiers.filter(m => !isEventOptionModifier(m))\n\n    // built-in modifiers that are not keys\n    const nonKeyModifiers = runtimeModifiers.filter(isNonKeyModifier)\n    if (nonKeyModifiers.length) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\n        handlerExp,\n        JSON.stringify(nonKeyModifiers)\n      ])\n    }\n\n    const keyModifiers = runtimeModifiers.filter(m => !isNonKeyModifier(m))\n    if (\n      keyModifiers.length &&\n      // if event name is dynamic, always wrap with keys guard\n      (key.type === NodeTypes.COMPOUND_EXPRESSION ||\n        !key.isStatic ||\n        isKeyboardEvent(key.content))\n    ) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\n        handlerExp,\n        JSON.stringify(keyModifiers)\n      ])\n    }\n\n    if (eventOptionModifiers.length) {\n      handlerExp = createObjectExpression([\n        createObjectProperty('handler', handlerExp),\n        createObjectProperty(\n          'options',\n          createObjectExpression(\n            eventOptionModifiers.map(modifier =>\n              createObjectProperty(\n                modifier,\n                createSimpleExpression('true', false)\n              )\n            )\n          )\n        )\n      ])\n    }\n\n    return {\n      props: [createObjectProperty(key, handlerExp)],\n      needRuntime: false\n    }\n  })\n}\n","import { baseCompile, CompilerOptions, CodegenResult } from '@vue/compiler-core'\nimport { parserOptionsMinimal } from './parserOptionsMinimal'\nimport { parserOptionsStandard } from './parserOptionsStandard'\nimport { transformStyle } from './transforms/transformStyle'\nimport { transformCloak } from './transforms/vCloak'\nimport { transformVHtml } from './transforms/vHtml'\nimport { transformVText } from './transforms/vText'\nimport { transformModel } from './transforms/vModel'\nimport { transformOn } from './transforms/vOn'\n\nexport function compile(\n  template: string,\n  options: CompilerOptions = {}\n): CodegenResult {\n  return baseCompile(template, {\n    ...options,\n    ...(__BROWSER__ ? parserOptionsMinimal : parserOptionsStandard),\n    nodeTransforms: [transformStyle, ...(options.nodeTransforms || [])],\n    directiveTransforms: {\n      cloak: transformCloak,\n      html: transformVHtml,\n      text: transformVText,\n      model: transformModel, // override compiler-core\n      on: transformOn,\n      ...(options.directiveTransforms || {})\n    }\n  })\n}\n\nexport * from '@vue/compiler-core'\nexport * from './tagConfig'\n"],"names":["PatchFlagNames","1","2","4","8","32","16","64","128","256","[object Object]","makeMap","str","expectsLowerCase","map","Object","create","list","split","i","length","val","toLowerCase","NO","extend","a","b","key","isArray","Array","isFunction","isString","isSymbol","isObject","camelizeRE","defaultOnError","error","createCompilerError","code","loc","messages","msg","locInfo","start","line","column","SyntaxError","locStub","source","offset","end","createArrayExpression","elements","type","createObjectExpression","properties","createObjectProperty","value","createSimpleExpression","content","isStatic","isConstant","createCompoundExpression","children","createCallExpression","callee","args","arguments","createFunctionExpression","params","returns","newline","createSequenceExpression","expressions","createConditionalExpression","test","consequent","alternate","createCacheExpression","index","FRAGMENT","Symbol","PORTAL","COMMENT","TEXT","SUSPENSE","OPEN_BLOCK","CREATE_BLOCK","CREATE_VNODE","RESOLVE_COMPONENT","RESOLVE_DYNAMIC_COMPONENT","RESOLVE_DIRECTIVE","WITH_DIRECTIVES","RENDER_LIST","RENDER_SLOT","CREATE_SLOTS","TO_STRING","MERGE_PROPS","TO_HANDLERS","CAMELIZE","helperNameMap","registerRuntimeHelpers","helpers","getOwnPropertySymbols","forEach","s","_parse","_walk","loadDep","name","process","require","window","_deps","nonIdentifierRE","isSimpleIdentifier","memberExpRE","isMemberExpression","path","getInnerRange","newLoc","substr","advancePositionWithClone","pos","numberOfCharacters","advancePositionWithMutation","linesCount","lastNewLinePos","charCodeAt","Math","max","assert","condition","Error","findDir","node","allowEmpty","props","p","exp","findProp","dynamicOnly","isEmpty","arg","createBlockExpression","blockExp","context","helper","isVSlot","isTemplateNode","tagType","isSlotOutlet","injectProp","prop","propsWithInjection","first","unshift","toValidAssetId","replace","defaultParserOptions","delimiters","ignoreSpaces","getNamespace","getTextMode","isVoidTag","isCustomElement","namedCharacterReferences","gt;","lt;","amp;","apos;","quot;","onError","parse","options","originalSource","maxCRNameLength","keys","reduce","inPre","createParserContext","getCursor","parseChildren","components","directives","hoists","cached","codegenNode","undefined","getSelection","mode","ancestors","parent","last","ns","nodes","isEnd","startsWith","parseInterpolation","emitError","parseComment","parseBogusComment","parseCDATA","advanceBy","parseTag","parseElement","parseText","pushNode","prev","trim","push","match","exec","slice","prevIndex","nestedIndex","indexOf","contentStart","closeIndex","wasInPre","element","isPreBoundary","isSelfClosing","tag","pop","startsWithEndTagOpen","advanceSpaces","cursor","currentSource","parseAttributes","some","filter","isNativeTag","attributeNames","Set","attr","parseAttribute","nameSet","has","add","pattern","m","quote","isQuoted","endIndex","parseTextData","unexpectedChars","parseAttributeValue","startOffset","shift","getNewPosition","endsWith","valueLoc","modifiers","open","close","innerStart","innerEnd","rawContentLength","rawContent","preTrimContent","min","n","text","head","remaining","semi","hex","body","cp","Number","parseInt","CCR_REPLACEMENTS","String","fromCodePoint","xs","searchString","130","131","132","133","134","135","136","137","138","139","140","142","145","146","147","148","149","150","151","152","153","154","155","156","158","159","hoistStatic","root","walk","resultCache","doNotHoistNode","child","isStaticNode","hoist","flag","getPatchFlag","hasDynamicKeyOrRef","hasCachedProps","getVNodeArgAt","getVNodeCall","branches","branchChildren","Map","isSingleElementRoot","get","set","every","transform","prefixIdentifiers","cacheHandlers","nodeTransforms","directiveTransforms","identifiers","scopes","vFor","vSlot","vPre","vOnce","currentNode","childIndex","helperString","removalIndex","onNodeRemoved","splice","cache","createTransformContext","traverseNode","finalizeRoot","traverseChildren","nodeRemoved","exitFns","onExit","createStructuralDirectiveTransform","fn","matches","generate","ast","sourceMap","filename","indentLevel","openOnly","withoutNewLine","repeat","createCodegenContext","indent","deindent","hasHelpers","useWithBlock","join","includes","genHoists","genAssets","genNode","toJSON","assets","resolver","id","JSON","stringify","genNodeListAsArray","multilines","genNodeList","genText","genExpression","genInterpolation","genCompoundExpression","genCallExpression","resetMapping","genExpressionAsPropertyKey","lastChar","genObjectExpression","genArrayExpression","genFunctionExpression","genSequenceExpression","needsParens","isNested","genConditionalExpression","genCacheExpression","transformIf","dir","branch","createIfBranch","replaceNode","createCodegenNodeForBranch","siblings","sibling","removeNode","parentCondition","createChildrenCodegenNode","keyProperty","blockArgs","forBlockArgs","childCodegen","vnodeCall","transformFor","parseResult","parseForExpression","addIdentifiers","removeIdentifiers","renderExp","keyProp","fragmentFlag","valueAlias","keyAlias","objectIndexAlias","childBlock","isTemplate","slotOutlet","createForLoopParams","forAliasRE","forIteratorRE","stripParensRE","input","inMatch","LHS","RHS","result","createAliasExpression","valueContent","trimmedOffset","iteratorMatch","keyContent","keyOffset","indexContent","range","isStaticExp","defaultFallback","trackSlotScopes","buildDefaultSlot","slotProps","buildDynamicSlot","directiveImportMap","WeakMap","transformElement","isComponent","runtimeDirectives","dynamicPropNames","dynamicComponent","hasProps","patchFlag","isProp","propsBuildResult","buildProps","hasChildren","slots","hasDynamicSlots","slotsProperties","dynamicSlots","explicitDefaultSlot","hasTemplateSlots","extraneousChild","seenSlotNames","slotElement","slotDir","slotChildren","slotLoc","slotName","dirLoc","staticSlotName","slotFunction","vIf","vElse","j","conditional","concat","buildSlots","hasDynamicTextChild","vnode","dirArgs","runtime","modifier","buildDirectiveArgs","elementLoc","mergeArgs","hasRef","hasClassBinding","hasStyleBinding","hasDynamicKeys","analyzePatchFlag","isBind","isOn","dedupeProperties","directiveTransform","needRuntime","propsExpression","knownProps","deduped","existing","mergeAsArray","incoming","transformSlotOutlet","$slots","nameIndex","slotArgs","propsWithoutName","fnExpRE","transformOn","augmentor","eventName","charAt","toUpperCase","capitalize","isCacheable","isMemberExp","ret","transformBind","_","c","camelize","isText","transformText","currentContainer","hasText","next","callArgs","transformOnce","transformModel","createTransformProps","expString","propName","baseCompile","template","on","bind","once","model","isHTMLTag","isSVGTag","parserOptionsMinimal","transformStyle","parsed","cssText","res","listDelimiterRE","item","tmp","propertyDelimiterRE","parseInlineCSS","transformCloak","createDOMCompilerError","transformVHtml","transformVText","V_MODEL_RADIO","V_MODEL_CHECKBOX","V_MODEL_TEXT","V_MODEL_SELECT","V_MODEL_DYNAMIC","V_ON_WITH_MODIFIERS","V_ON_WITH_KEYS","baseResult","baseTransform","directiveToUse","isInvalidType","isEventOptionModifier","isNonKeyModifier","isKeyboardEvent","handlerExp","eventOptionModifiers","runtimeModifiers","nonKeyModifiers","keyModifiers","cloak","html","lines","count","lineLength","pad","hasScopeRef","ids","walker"],"mappings":"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"}