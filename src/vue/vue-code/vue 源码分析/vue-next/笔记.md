1. vue2 
{
    $set ==>object.definproperty
    1. Observer==>object.definproperty==>Object(key),array(重写) 
        get     dep.depend==>Watcher.addSub==>Dep[watcher]
        set     Dep.notify==>watcher.update==>render==>get()==>Vnode==>dom diff(修改diff 对应的component！！并不是整个页面的dom diff)
        react （diff 整个页面的Vnode）

    2. Dep 收集依赖  订阅发布模式  (大爷电话本)  EventEmit (node)
    3. Watcher  连接对应的render函数 -->  component(teamplate)  
        1. dep.target=Watcher
    4. render  ==>
    with(this){
        ...(name)
    }
}

2. vue3 


vue2 vue3 react(操作系统、fiber（协程）、并发模式)


function a(){
    if(){
        return 
    }
    a()
}

https://vue-template-explorer.netlify.app/  （vue2在线编译地址）
with 提升作用域链
vue2  正则匹配（文档匹配次数越多越慢）  ==>替换成with(this){
    a
}



vue3  AST(抽象语法数) 通过语言规则把他解析出来构建成为一个树 
ast explorer

1. 模板解析  AST ==> render(){return Vnode()} AST直接创建vnode，不用with创建vnode（vue2用with缩短作用域链， vue3通过词法分析可以直接找到变量）
2. vue3 内部的数据监听发生了变换（vue2不能监听对象的新key,数组重写也很慢，需要遍历所有key,对每一个key监听）
    vue3(基于Proxy，实现响应式数据)
    Proxy  ==》整个对象的操作的拦截，不需要遍历所有的key，新增的key也会拦截
        1. 数组的改变，会触发多次（改变数组第一位，会触发多次）
        2. 不能代理嵌套对象，数组对象 （不能监听嵌套对象里的属性）

es AST==>(修改树中的节点)==>转换回来==>es5
lerna多包管理工具


词法分析  语法分析 形成ast
a=`var a=1`
function a(){
    return 
}

[function ,a ,(,),{,}]
[var,a,=,1]  ==>词法分析  每个词按照自己的语法规则分析， var后面必须接个变量名

var a = b 词法分析不会报错，是运行时报错

antlr grammar


for(a ){

}

var ==> 

```teampate
<div >
    asasas
</div> ==>
```
编译时 优化  ：编辑成with语句，编译时发现节点是否是静态的，如果是静态的，下次diff不用diff该节点

   




react   运行时 ==>优化
jsx 
<div></div>


react编译完后是createElement，jsx只能在运行时优化，必须整个页面diff
render(){
    return React.createElement()
}

临渊慕鱼 不如退而结网 



vue3
reactivity    数据响应式系统  Proxy （get set ）
        reactive ==>把数据处理成为响应式数据
            proxy
            targetMap
            {
                {a:1} :{
                    a:[effect()]
                }
            }

        effect==>   
        1.首先会执行一次对应监听的函数
        2.修改对应监听函数内使用的响应式数据，对应的监听函数就会重新执行，重新执行的过程就会获取到新的数据

        effect(fn)

            ==>  createReactiveEffect==warpFn==>lazy ==Effect()==> run(effect, fn, args)
            ==> effectStack(维护一个堆栈)
            ==》effectStack.push (Effect)
            ==>fn()
            ==>get==>track(target,get,'key')==> {
                target:{
                    key:[Effect]
                }
            }



        Reactive==>{a:1}==>Proxy==>


        基本数据类型不能处理成为 reactive 数据
        基本数据类型能不能被监听  Ref
compiler-core   编译器 转义成AST 
compiler-dom    AST==>转义成render
compiler-sfc   解析.vue文件
compiler-ssr  服务端渲染的处理，拼接dom字符串，加到html中
runtime-core  与平台无关的运行时 
runtime-dom   document  setSate 与端接触的运行时（浏览器端）  暴露了端口 接入平台相关操作的端口，不同的端怎么处理dom
runtime-test
server-renderer
template-explorer vue3 模板在线编译代码



```
<div></div>
```




reactive 
ref


```js
var obj=reactive({foo:1})
var obj2=reactive({a:1,...toRefs(obj)});



effect(()=>{
    console.log(obj2.foo.value)
})

obj.foo=2
```




jest runner






<div>
    <p>foo</p>
    <p>{{ bar }}</p>
</div>




const vnode = {
    tag: 'div',
    children: [
        { tag: 'p', children: 'foo' },
        { tag: 'div', children: [
            { tag: 'p', children: ctx.bar }
        ] 
        }, 
    ],
    dynamicChildren:[
        { tag: 'p', children: ctx.bar }, 
    ]
}


BlockTree dynamicChildren